% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dcpf.R
\name{dcpf_plot_1d}
\alias{dcpf_plot_1d}
\title{Plot one-dimensional depth time series from the DCPF algorithm}
\usage{
dcpf_plot_1d(
  archival,
  paths,
  scale = -1,
  pretty_axis_args = list(side = 3:2),
  xlab = "Time (index)",
  ylab = "Depth (m)",
  type = "b",
  add_lines = list(col = "royalblue", type = "b"),
  prompt = FALSE,
  ...
)
}
\arguments{
\item{archival}{A dataframe of depth (m) observations named `depth', as used by \code{\link[flapper]{dcpf}}.}

\item{paths}{A dataframe containing reconstructed movement path(s) from \code{\link[flapper]{dcpf}} via \code{\link[flapper]{dcpf_simplify}} (see \code{\link[flapper]{dcpf-class}}). At a minimum, this should contain a unique identifier for each path (named `path_idâ€™), timesteps (`timestep') and the depth associated with each cell along each path (`cell_z').}

\item{scale}{A number that vertically scales the depth time series for the observations and the reconstructed path(s). By default, absolute values for depth are assumed and negated for ease of visualisation.}

\item{pretty_axis_args, xlab, ylab, type, ...}{Plot customisation arguments passed to \code{\link[prettyGraphics]{pretty_plot}}.}

\item{add_lines}{A named list, passed to \code{\link[graphics]{lines}}, to customise the appearance of the depth time series for reconstructed path(s).}

\item{prompt}{A logical input that defines whether or not plot the observed depth time series with each reconstructed depth time series on a separate plot, sequentially, with a pause between plots (\code{prompt = TRUE}), or with all reconstructed time series on a single plot (\code{prompt = FALSE}).}
}
\value{
The function returns a plot of the observed and reconstructed depth time series, either for all paths at once (if \code{prompt = FALSE}) or each path separately (if \code{prompt = TRUE}).
}
\description{
This function plots the observed depth time series and the depth time series associated with each path reconstructed by the depth-contour particle filtering (DCPF) algorithm.
}
\details{
Observed and reconstructed depth time series can differ due to measurement error, which is controlled via the \code{calc_depth_error} function in the DCPF algorithm (see \code{\link[flapper]{dcpf}}).
}
\examples{
#### Implement dcpf() algorithm
# Here, we use pre-defined outputs for speed
archival <- dat_dcpf_histories$args$archival
paths    <- dat_dcpf_paths

#### Example (1): The default implementation
dcpf_plot_1d(archival, paths)

#### Example (2): Plot customisation options, e.g.:
dcpf_plot_1d(archival, paths, scale = 1, pretty_axis_args = list(side = 1:2))
dcpf_plot_1d(archival, paths, type = "l")
dcpf_plot_1d(archival, paths, add_lines = list(col = "red", lwd = 0.5))

#### Example (3): Plot individual comparisons
if(interactive()){
  pp <- graphics::par(mfrow = c(3, 4))
  dcpf_plot_1d(depth, paths, prompt = TRUE)
  graphics::par(pp)
}

}
\seealso{
\code{\link[flapper]{dcpf}} implements the DCPF algorithm. \code{\link[flapper]{dcpf_plot_history}} visualises particle histories and \code{\link[flapper]{dcpf_simplify}} processes the outputs into a dataframe of movement paths. \code{\link[flapper]{dcpf_plot_1d}}, \code{\link[flapper]{dcpf_plot_2d}} and \code{\link[flapper]{dcpf_plot_3d}} provide plotting routines for paths. \code{\link[flapper]{dcpf_loglik}} calculates the log-likelihood of each path.
}
\author{
Edward Lavender
}
