% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_analyse_either.R
\name{pf_plot_map}
\alias{pf_plot_map}
\title{Plot `probability of use' from a PF algorithm}
\usage{
pf_plot_map(
  xpf,
  map,
  transform = NULL,
  scale = c("original", "max", "sum"),
  add_rasters = list(),
  ...
)
}
\arguments{
\item{xpf}{A \code{\link[flapper]{pf_archive-class}} object (from \code{\link[flapper]{pf}} plus \code{\link[flapper]{pf_simplify}} with \code{return = "archive"}) or a \code{\link[flapper]{pf_path-class}} object (from \code{\link[flapper]{pf}} plus \code{\link[flapper]{pf_simplify}} with \code{return = "path"}).}

\item{map}{A \code{\link[raster]{raster}} that defines a grid across the area of interest.}

\item{transform}{(optional) A function to transform cell weights (e.g, \code{\link[base]{log}}).}

\item{scale}{A character that defines how \code{\link[raster]{raster}} values are scaled: \code{"original"} uses the original values; \code{"max"} scales values by the maximum value (so that, if \code{transform = NULL}, they lie between zero and one; and \code{"sum"} scales values by their sum so that they sum to one.}

\item{add_rasters}{A named list, passed to \code{\link[prettyGraphics]{pretty_map}}, to customise the appearance of the plotted surface.}

\item{...}{Additional arguments passed to \code{\link[prettyGraphics]{pretty_map}}.}
}
\value{
The function invisibly returns a \code{\link[raster]{raster}}, in which each cell contains the `probability of use' score  and produces a plot of this surface.
}
\description{
This function creates a plot of the `probability of use' across an area based on (a) particles sampled or (b) paths reconstructed by a particle filtering (PF) algorithm. To implement the function, an (a) \code{\link[flapper]{pf_archive-class}} object that contains connected particles (locations) sampled by \code{\link[flapper]{pf}} and processed by \code{\link[flapper]{pf_simplify}} or (b) \code{\link[flapper]{pf_path-class}} object that contains reconstructed paths must be supplied. The function extracts sampled locations and, for each location, calculates `the probability of use' for that location over the time series (see Details). This is plotted and returned (invisibly) as a \code{\link[raster]{raster}}.
}
\details{
For particle-based implementations, this function is designed to be implemented for the subset of sampled particles that formed continuous paths from the start to the end of the time series (see \code{\link[flapper]{pf_simplify}}). At each time step, only one record of each location (derived by summarising the probabilities of multiple samples of the same location with the \code{summarise_pf} argument in \code{\link[flapper]{pf_simplify}}) should be passed to \code{\link[flapper]{pf_plot_map}} to ensure that cell scores depend on the number of time steps when the individual could have occupied a given cell, rather than the total number of samples of a location. For each location, the 'probability of use' is calculated as the sum of the number of times (time steps) that the location was sampled, weighted by the associated probabilities of each sample, over the total number of time steps. The benefit of this approach is that all particles that were part of paths from the start to the end of the time series are incorporated in the resultant map. However, this comes at the cost of simplifying cell probabilities for duplicate records and ignoring variation in the overall likelihood of different movement paths.

For path-based implementations, the function is designed to be implemented for paths reconstructed by \code{\link[flapper]{pf_simplify}}. For each path, as for particle-based implementations, for each location, the 'probability of use' is calculated as the sum of the number of times (time steps) that the location was sampled, weighted by the associated probabilities of each sample, over the total number of time steps. (This is equivalent to calculating a weighted sum of the paths). Scores are then averaged across paths. This benefit of this approach is that it is possible to account for both location probabilities (in the weighted summation) and path probabilities (in the averaging of cell scores across paths, although this is not yet implemented). However, this approach can usually only be implemented for a subset of all possible paths (see \code{max_n_copies} in \code{\link[flapper]{pf_simplify}}) and these paths may not be independent (they may share substantial sections).

For either implementation, raw scores can be transformed or scaled to facilitate comparisons.
}
\examples{
#### Prepare data
## Particle-based implementation
# The example data 'dat_dcpf_histories' contains all particles sampled
# ... by an implementation of the DCPF algorithm. However, not all particles
# ... that were sampled at one time step may have been near to particles sampled
# ... at the next time step. In addition, some particles may have been sampled
# ... multiple times at one time step, but our maps of space use should reflect
# ... the number of time steps that the individual could have occupied a location,
# ... rather than the total number of samples of a location. Hence, to map
# ... space use, we should focus on the subset of particles that were connected
# ... between time steps and only retain one record of each particle at each time step
# ... using pf_simplify() with return = "archive"
dat_dcpf_histories_connected <-
  pf_simplify(dat_dcpf_histories,
             summarise_pr = max,
             return = "archive")
## Path based implementation
# The example data 'dat_dcpf_paths' contains a sample of paths reconstructed
# ... by the DCPF algorithm and we can also implement the function for these paths.

#### Example (1): Implement the function with default options
pf_plot_map(dat_dcpf_histories_connected, map = dat_dc$args$bathy)

#### Example (2): Re-scale the map
pf_plot_map(dat_dcpf_histories_connected, map = dat_dc$args$bathy, scale = "max")
pf_plot_map(dat_dcpf_histories_connected, map = dat_dc$args$bathy, scale = "sum")

#### Example (3): Customise the map
pf_plot_map(dat_dcpf_histories_connected, map = dat_dc$args$bathy,
            add_rasters = list(col = grDevices::grey.colors(n = 100)),
            xlab = "x", ylab = "y")

}
\seealso{
\code{\link[flapper]{pf}} implements PF. \code{\link[flapper]{pf_simplify}} assembles paths from particle histories. \code{\link[flapper]{pf_plot_history}} visualises particle histories. \code{\link[flapper]{pf_plot_1d}}, \code{\link[flapper]{pf_plot_2d}} and \code{\link[flapper]{pf_plot_3d}} provide plotting routines for paths. \code{\link[flapper]{pf_loglik}} calculates the log-likelihood of each path.
}
\author{
Edward Lavender
}
