% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sims.R
\name{sim_array}
\alias{sim_array}
\title{Simulate (marine) monitoring arrays}
\usage{
sim_array(
  boundaries = raster::extent(-10, 10, -10, 10),
  coastline = NULL,
  land_inside_coastline = TRUE,
  n_receivers = 10,
  arrangement = "random",
  seed = NULL,
  plot = TRUE,
  xlim = NULL,
  ylim = NULL,
  add_sea = NULL,
  add_land = NULL,
  add_receivers = list(),
  verbose = TRUE,
  ...
)
}
\arguments{
\item{boundaries}{A \code{\link[raster]{extent}} object that defines the boundaries of simulated study site.}

\item{coastline}{(optional) This argument is used to incorporate the presence of barriers, such as coastline, within an array. There are three options. If \code{coastline = NULL}, no barriers are incorporated. If \code{coastline = "simple_random"}, then some coastline is simulated in the study area. Alternatively, a spatial object, such as a SpatialPolygonsDataFrame that defines the coastline in an area can be incorporated into the array design by passing this \code{coastline}.}

\item{land_inside_coastline}{A logical variable that defines whether or not the land is 'inside' the polygon defined by \code{coastline} (\code{land_inside_coastline = TRUE}) or the sea is 'inside' (\code{land_inside_coastline = FALSE}).}

\item{n_receivers}{An integer that defines the number of receivers in the array. This is ignored if receiver locations are specified via \code{arrangement}.}

\item{arrangement, ...}{A character string or a SpatialPoints object that defines the arrangement of receivers. Supported character strings options for simulated arrays are \code{"regular"}, \code{"random"} and \code{"stratified"}, \code{"nonaligned"}, \code{"hexagonal"} and \code{"clustered"} (see \code{\link[sp]{spsample}}, which is used to simulate receiver locations). Additional arguments can be passed to this function via \code{...} for further control. Otherwise, a SpatialPoints object that defines the coordinates of receivers (in the same coordinate reference system as \code{boundaries} and, if applicable, \code{coastline}) is assumed to have been provided.}

\item{seed}{An integer that is used to set the seed to enable reproducible simulations (see \code{\link[base]{set.seed}}).}

\item{plot}{A logical variable that defines whether or not plot the array.}

\item{xlim, ylim}{(optional) Axis limits for the plot. These can be specified in any way supported by \code{\link[prettyGraphics]{pretty_axis}}.}

\item{add_sea}{(optional) If \code{plot = TRUE}, \code{add_sea} is a named list of arguments, passed to \code{\link[raster]{plot}}, to customise the appearance of the sea on the plot. \code{add_sea = NULL} suppresses the addition of the sea to the plot. To use the default graphical parameters, simply specify \code{add_sea = list()}.}

\item{add_land}{(optional) If \code{plot = TRUE}, \code{add_land} is a named list of arguments, passed to \code{\link[raster]{plot}}, to customise the appearance of the land on the plot. \code{add_sea = NULL} suppresses the addition of the land to the plot. To use the default graphical parameters, simply specify \code{add_sea = list()}.}

\item{add_receivers}{(optional) If \code{plot = TRUE}, \code{add_receivers} is a named list of arguments, passed to \code{\link[graphics]{points}}, to customise the appearance of receivers on the plot. \code{add_receivers = NULL} suppresses the addition of the receivers to the plot. To use the default graphical parameters, simply specify \code{add_receivers = list()}.}

\item{verbose}{A logical variable that defines whether or not to print messages to the console to relay function progress.}
}
\value{
The function returns a named list of (a) spatial objects that define the simulated array ('array') and (b) the arguments used to generate this array ('args'). The 'array' element if this list contains the following elements: 'boundaries', a \code{\link[raster]{Extent-class}} object that defines the boundaries of the area (as inputted); 'area', a \code{\link[sp]{SpatialPolygons-class}} object that defines the boundaries of the area; 'land' and 'sea' are \code{\link[sp]{SpatialPolygons-class}} or \code{\link[sp]{SpatialPolygonsDataFrame-class}} objects that define the land and sea respectively; and 'xy' is a \code{\link[sp]{SpatialPoints-class}} object that defines receiver locations. If \code{plot = TRUE}, the function also returns a plot.
}
\description{
This function is designed to simulate different kinds of array designs for monitoring stations. The function has been particularly inspired by the need to simulate passive acoustic telemetry array designs, which comprise networks of acoustic hydrophones that listen for acoustic transmissions from tagged marine animals. To implement the function, it is necessary to define the boundaries of the area (\code{boundaries}), within which barriers to movement, such as coastline, can be simulated or included from real datasets. Within this area, a specified number of receivers (\code{n_receivers}) can be simulated under different array designs (namely, uniform, regular or random arrangements) or incorporated from real data. The function returns a list of spatial objects that define the array and, if requested, a plot of the area.
}
\examples{
#### Example (1): Simulate an array using default parameters
# ... And force reproducible simulations by defining seed
seed <- 1
array <- sim_array(boundaries = raster::extent(-10, 10, -10, 10),
                   seed = 1)

#### Example (2): Simulate coastline and customise plot
# ... via add_land and add_sea
array <- sim_array(boundaries = raster::extent(-10, 10, -10, 10),
                   coastline = "simple_random",
                   add_land = list(col = "darkgreen"),
                   add_sea = list(col = scales::alpha("skyblue", 0.2)),
                   seed = 1
                   )

#### Example (3) Add custom coastline
array <- sim_array(boundaries = raster::extent(dat_coast),
                   coastline = dat_coast,
                   add_land = list(col = "darkgreen"),
                   add_sea = list(col = scales::alpha("skyblue", 0.2)),
                   seed = 1
                   )

#### Example (4) Change the number of receivers
array <- sim_array(n_receivers = 5)
array <- sim_array(n_receivers = 25)

#### Example (5) Change the arrangement of receivers
## Explore different arrangements
array <- sim_array(n_receivers = 25, arrangement = "random")
array <- sim_array(n_receivers = 25, arrangement = "regular")
array <- sim_array(n_receivers = 25, arrangement = "clustered", nclusters = 5)
array <- sim_array(n_receivers = 25, arrangement = "stratified")
array <- sim_array(n_receivers = 25, arrangement = "nonaligned")
array <- sim_array(n_receivers = 25, arrangement = "hexagonal")
## Force arrangements around coastline
# Simulated island
array <- sim_array(n_receivers = 25,
                   coastline = "simple_random",
                   arrangement = "regular",
                   add_land = list())
# Real coastline
array <- sim_array(boundaries = raster::extent(dat_coast),
                   n_receivers = 25,
                   coastline = dat_coast,
                   arrangement = "regular",
                   add_land = list())
## Incorporate custom arrangements
# Define receiver locations as a SpatialPoints object with a UTM CRS
# ... to match other spatial datasets
proj_wgs84 <- sp::CRS("+init=epsg:4326")
proj_utm <- sp::CRS(paste("+proj=utm +zone=29 +datum=WGS84",
                          "+units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
xy <- sp::SpatialPoints(dat_moorings[, c("receiver_long", "receiver_lat")],
                        proj_wgs84)
xy <- sp::spTransform(xy, proj_utm)
# Make array
array <- sim_array(boundaries = raster::extent(dat_coast),
                   coastline = dat_coast,
                   arrangement = xy,
                   add_land = list()
                   )

}
\author{
Edward Lavender
}
