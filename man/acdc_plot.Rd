% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acdc.R
\name{acdc_plot}
\alias{acdc_plot}
\title{Plot the results of the ACDC algorithm}
\usage{
acdc_plot(
  acdc,
  plot = 1,
  add_coastline = NULL,
  add_receivers = NULL,
  add_raster = list(col = rev(grDevices::terrain.colors(255))),
  add_centroids = list(),
  add_additional = NULL,
  crop_spatial = FALSE,
  xlim = NULL,
  ylim = NULL,
  fix_zlim = FALSE,
  pretty_axis_args = list(side = 1:4, axis = list(list(), list(), list(labels = FALSE),
    list(labels = FALSE)), control_axis = list(las = TRUE), control_sci_notation =
    list(magnitude = 16L, digits = 0)),
  par_param = list(),
  png_param = list(),
  cl = NULL,
  verbose = TRUE,
  check = TRUE,
  ...
)
}
\arguments{
\item{acdc}{A named list from \code{\link[flapper]{.acdc}}.}

\item{plot}{An integer vector that defines the time steps for which to make plots. If \code{plot = NULL}, the function will make a plot for all time steps for which the necessary information is available in \code{acdc}.}

\item{add_coastline}{(optional) A named list of arguments, passed to \code{\link[raster]{plot}}, to add a polygon (i.e., of the coastline), to the plot. If provided, this must contain an 'x' element that contains the coastline as a spatial object (e.g., a SpatialPolygonsDataFrame: see \code{\link[flapper]{dat_coast}} for an example).}

\item{add_receivers}{(optional) A named list of arguments, passed to \code{\link[graphics]{points}}, to add points (i.e., receivers) to the plot. If provided, this must contain an 'x' element that is a SpatialPoints object that specifies receiver locations (in the same coordinate reference system as other spatial data).}

\item{add_raster}{(optional) A named list of arguments, passed to \code{\link[fields]{image.plot}}, to plot the RasterLayer of possible locations that is extracted from \code{acdc}.}

\item{add_centroids}{(optional) A named list of arguments, passed to \code{\link[raster]{plot}}, to add the acoustic centroid to the plot.}

\item{add_additional}{(optional) A stand-alone function, to be executed after the background plot has been made and any specified spatial layers have been added to this, to customise the result (see Examples).}

\item{crop_spatial}{A logical variable that defines whether or not to crop spatial data to lie within the axis limits.}

\item{xlim, ylim, fix_zlim, pretty_axis_args}{Axis control arguments. \code{xlim} and \code{ylim} control the axis limits, following the rules of the 'lim' argument in \code{\link[prettyGraphics]{pretty_axis}}. \code{fix_zlim} is a logical input that defines whether or not to fix z axis limits across all plots (to facilitate comparisons), or a vector of two numbers that define a custom range for the z axis which is fixed across all plots. \code{fix_zlim = FALSE} produces plots in which the z axis is allowed to vary flexibly between time units. Other axis options supported by \code{\link[prettyGraphics]{pretty_axis}} are implemented by passing a named list of arguments to this function via \code{pretty_axis_args}.}

\item{par_param}{(optional) A named list of arguments, passed to \code{\link[graphics]{par}} to control the plotting window. This is executed before plotting is initiated and therefore affects all plots.}

\item{png_param}{(optional) A named list of arguments, passed to \code{\link[grDevices]{png}}, to save plots to file. If supplied, the plot for each time step is saved separately. The 'filename' argument should be the directory in which plots are saved. Plots are then saved as "1.png", "2.png" and so on.}

\item{cl}{A cluster object created by \code{\link[parallel]{makeCluster}}. If supplied, the function loops over specified time steps in parallel to make plots. This is only implemented if plots are saved to file (i.e., \code{png_param} is supplied). If supplied, the connection to the cluster is closed within the function.}

\item{verbose}{A logical variable that defines whether or not relay messages to the console to monitor function progress.}

\item{check}{A logical variable that defines whether or not to check user inputs to the function before its initiation.}

\item{...}{Additional arguments, passed to \code{\link[raster]{plot}}, to customise the blank background plot onto which spatial layers are added, such as \code{xlab}, \code{ylab} and \code{main}.}
}
\value{
The function plots the results of the ACDC algorithm at specified time steps, with one plot per time step. Plots are saved to file if \code{png_param} is supplied.
}
\description{
This function is used to plot the results of the ACDC algorithm. To implement the function, a named list from \code{\link[flapper]{.acdc}} must be supplied, from which the results can be extracted and plotted. For each specified time step, the function extracts the necessary information; sets up a blank background plot using \code{\link[raster]{plot}} and \code{\link[prettyGraphics]{pretty_axis}} and then adds requested spatial layers to this plot. Depending on user-inputs, this will usually show a cumulative map of where the individual could have spent more or less time, summed from the start of the algorithm to each time point. Coastline, receivers and acoustic centroids can be added and customised and the finalised plots can be returned or saved to file.
}
\examples{
#### Example (1): The default options simply plot the first surface
acdc_plot(acdc = dat_acdc)

#### Example (2): Define the number of plots to be produced and control the plotting window
acdc_plot(acdc = dat_acdc,
          plot = 1:2,
          par_param = list(mfrow = c(1, 2), mar = c(8, 8, 8, 8)))

#### Example (3): Add and customise spatial information via add_* args
## Define a SpatialPoints object of receiver locations
proj_wgs84 <- sp::CRS("+init=epsg:4326")
proj_utm <- sp::CRS(paste("+proj=utm +zone=29 +datum=WGS84",
                          "+units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
rsp <- sp::SpatialPoints(dat_moorings[, c("receiver_long", "receiver_lat")], proj_wgs84)
rsp <- sp::spTransform(rsp, proj_utm)
## Plot with receiver locations and coastline, customise the centroids and the raster
acdc_plot(acdc = dat_acdc,
          add_coastline = list(x = dat_coast, col = "darkgreen"),
          add_receivers = list(x = rsp, pch = 4, col = "royalblue"),
          add_centroids = list(col = "red"),
          add_raster = list(col = rev(topo.colors(100)))
          )

#### Example (4): Control axis properties
# ... via smallplot argument for raster, pretty_axis_args, xlim, ylim and fix_zlim
# ... set crop_spatial = TRUE to crop spatial data within adjusted limits
acdc_plot(acdc = dat_acdc,
          add_coastline = list(x = dat_coast, col = "darkgreen"),
          add_receivers = list(x = rsp, pch = 4, col = "royalblue"),
          add_centroids = list(col = "red"),
          add_raster = list(smallplot= c(0.85, 0.9, 0.25, 0.75)),
          crop_spatial = TRUE,
          pretty_axis_args = list(side = 1:4,
                                  control_sci_notation = list(magnitude = 16L, digits = 0)),
          xlim = raster::extent(dat_coast)[1:2],
          ylim = raster::extent(dat_coast)[3:4],
          fix_zlim = c(0, 1)
          )

#### Example (5): Modify each plot after it is produced via add_additional
# Specify a function to add titles to a plot
add_titles <- function(){
  mtext(side = 1, "x (UTM)", line = 2)
  mtext(side = 2, "y (UTM)", line = -8)
}
# Make plots with added titles
acdc_plot(acdc = dat_acdc,
          plot = 1:2,
          par_param = list(mfrow = c(1, 2), mar = c(8, 8, 8, 8)),
          add_coastline = list(x = dat_coast, col = "darkgreen"),
          add_receivers = list(x = rsp, pch = 4, col = "royalblue"),
          add_centroids = list(col = "red"),
          add_raster = list(),
          crop_spatial = TRUE,
          xlim = raster::extent(dat_coast)[1:2],
          ylim = raster::extent(dat_coast)[3:4],
          add_additional = add_titles
          )

#### Example (6) Save plots via png_param
list.files(tempdir())
acdc_plot(acdc = dat_acdc,
          plot = 1:2,
          png_param = list(filename = tempdir())
          )
list.files(tempdir())
}
\author{
Edward Lavender
}
