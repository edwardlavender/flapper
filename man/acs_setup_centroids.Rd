% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs_setup.R
\name{acs_setup_centroids}
\alias{acs_setup_centroids}
\title{Setup the detection centroids required for the AC* algorithm(s)}
\usage{
acs_setup_centroids(
  xy,
  detection_range,
  coastline = NULL,
  boundaries = NULL,
  plot = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{xy}{A \code{\link[sp]{SpatialPointsDataFrame}} object that defines receiver IDs and locations. The \code{data} slot must include a dataframe with a column that provides a unique, integer identifier for each receiver (`receiver_id'). The coordinate reference system should be the Universal Transverse Mercator system with distances in metres (to match \code{detection_range}, see below).}

\item{detection_range}{A number that defines the maximum detection range (m) at which an individual could be detected from a receiver.}

\item{coastline}{(optional) A \code{\link[sp]{SpatialPolygonsDataFrame-class}} object that defines the coastline in an area. If provided, detection centroids are processed to remove any areas on land. Algorithm speed declines with the complexity of the coastline.}

\item{boundaries}{(optional) An \code{\link[raster]{extent}} object that defines the boundaries of an area within which individuals are assumed to have remained. If provided, acoustic centroids are processed to remain within this area.}

\item{plot}{A logical input that defines whether or not to produce a plot of the area, including receivers, the coastline and the area boundaries (if provided), and acoustic centroids. This is useful for checking purposes but it can reduce algorithm speed.}

\item{verbose}{A logical input that defines whether or not to print messages to the console to relay function progress.}

\item{...}{Additional arguments passed to \code{\link[flapper]{get_detection_centroids}} and, ultimately, \code{\link[rgeos]{gBuffer}}, except \code{byid} which is necessarily \code{TRUE}.}
}
\value{
The function returns a list of \code{\link[sp]{SpatialPolygonsDataFrame-class}} objects, with one element for all numbers from 1 to the maximum receiver number (\code{xy$receiver_id}). Any list elements that do not correspond to receivers contain a \code{NULL} element. List elements that correspond to receivers contain a \code{\link[sp]{SpatialPolygonsDataFrame-class}} object containing the detection centroid for that receiver.
}
\description{
This function produces the detection centroids required by the acoustic-centroid (AC) and acoustic-centroid depth-contour (ACDC) algorithms.
}
\details{
Given a detection at a particular receiver at a particular time, the detection centroid defines the boundaries of the area around a receiver within which the individual must have been located (from the perspective of that receiver).

For the AC* algorithms, note that in some coastal settings the representation of detection centroids as \code{\link[sp]{SpatialPolygonsDataFrame-class}} objects may cause a mismatch with detection kernels and the bathymetry \code{\link[raster]{raster}} in terms of what is defined as water versus land. At the time of writing, in the AC* algorithms the detection kernels/bathymetry data take precedence, with any grid cells that have a value of \code{NA} masked, even if within `detection centroids'. In the future, these disparities should be resolved by redefining detection centroids on the bathymetry grid too.
}
\examples{
#### Define data for acs_setup_centroids()
## Define coordinates of receivers as SpatialPointsDataFrame with UTM CRS
# CRS of receiver locations as recorded in dat_moorings
proj_wgs84 <- sp::CRS(SRS_string = "EPSG:4326")
# CRS of receiver locations required
proj_utm   <- sp::CRS(SRS_string = "EPSG:32629")
# Define SpatialPoints object
xy_wgs84 <- sp::SpatialPoints(dat_moorings[, c("receiver_long", "receiver_lat")], proj_wgs84)
xy_utm <- sp::spTransform(xy_wgs84, proj_utm)
# Link with receiver IDs to define a SpatialPointsDataFrame
xy_utm <-
 sp::SpatialPointsDataFrame(xy_utm,
                            dat_moorings[, "receiver_id", drop = FALSE])

#### Example (1): Define a list of centroids with specified parameters
# ... (Argument values are small to reduce computation time for examples)
centroids <- acs_setup_centroids(xy = xy_utm,
                                 detection_range = 500
                                 )
# A list of SpatialPolygonsDataFrames is returned
# with elements from 1:max(xy_utm$receiver_id)
# NULL elements correspond to numbers in this sequence that do not refer to receivers
# Otherwise a SpatialPolygonsDataFrame is returned with all the centroids for that receiver
centroids

#### Example (2): Visualise the centroids produced via plot = TRUE
centroids <- acs_setup_centroids(xy = xy_utm,
                                  detection_range = 500,
                                  plot = TRUE
                                  )

#### Example (3): Remove areas of the centroids that overlap with coastline
centroids <- acs_setup_centroids(xy = xy_utm,
                                  detection_range = 500,
                                  plot = TRUE,
                                  coastline = dat_coast
                                  )

#### Example (4): Remove areas of the centroids beyond a boundary
xy_utm_coords <- sp::coordinates(xy_utm)
boundaries <- raster::extent(min(xy_utm_coords[, 1]),
                             max(xy_utm_coords[, 1]),
                             min(xy_utm_coords[, 2]),
                             max(xy_utm_coords[, 2])
                        )
centroids <- acs_setup_centroids(xy = xy_utm,
                                  detection_range = 500,
                                  plot = TRUE,
                                  coastline = dat_coast,
                                  boundaries = boundaries
                                  )

}
\author{
Edward Lavender
}
