% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_access.R
\name{pf_access_distance_matrix}
\alias{pf_access_distance_matrix}
\title{Calculate distances between particles from PF}
\usage{
pf_access_distance_matrix(
  archive,
  bathy = NULL,
  mobility = NULL,
  calc_distance = NULL,
  calc_distance_graph = NULL,
  ...,
  verbose = TRUE
)
}
\arguments{
\item{archive}{A \code{\link[flapper]{pf_archive-class}} object from \code{\link[flapper]{pf}}.}

\item{bathy}{(optional) The bathymetry \code{\link[raster]{raster}} (see \code{\link[flapper]{pf}}). If unsupplied, \code{bathy} can be extracted from \code{archive$args$bathy}.}

\item{mobility}{(optional) The mobility parameter (see \code{\link[flapper]{pf}}). If supplied, distances that exceed \code{mobility} are set to zero in the sparse \code{\link[Matrix]{dgCMatrix-class}} that is returned (see Details). Particularly for shortest-distances implementations (see \code{calc_distance}), supplying \code{mobility} should reduce memory requirements and computation time (see Details).}

\item{calc_distance}{A character that defines the method used to calculate distances between sequential combinations of particles (see \code{\link[flapper]{pf}}). Currently supported options are Euclidean distances ("euclid") or shortest (least-cost) distances ("lcp"). Note that \code{calc_distance} does not need to be the same method as used for \code{\link[flapper]{pf}}. If \code{calc_distance = NULL}, the method saved in \code{archive} is used.}

\item{calc_distance_graph}{(optional) If \code{calc_distance = "lcp"}, \code{calc_distance_graph} is a graph object that defines the distances between connected cells in \code{bathy}. If unsupplied, this is taken from \code{archive$args$calc_distance_graph}, if available, or computed via \code{\link[flapper]{lcp_graph_surface}}.}

\item{...}{If \code{calc_distance = "lcp"}, \code{...} are additional arguments passed to \code{\link[cppRouting]{get_distance_pair}} to calculate shortest distances. Allowed arguments are \code{algorithm}, \code{constant} and \code{allcores}.}

\item{verbose}{A logical input that defines whether or not to print messages to the console to monitor function progress.}
}
\value{
The function returns a \code{\link[Matrix]{dgCMatrix-class}} sparse matrix with one row and one column for each pairwise cell combination in \code{bathy}. By default cells are empty (value zero). For the unique, pairwise cells in \code{archive} (that are less than \code{mobility} apart, if applicable), cell values represent the Euclidean or shortest distance between those cells in metres.
}
\description{
This function calculates the Euclidean or shortest distances between unique particle samples from a particle filtering (PF) algorithm (\code{\link[flapper]{pf}}). This is designed to support particle processing and the reconstruction of movement paths via \code{\link[flapper]{pf_simplify}} (see Details).
}
\details{
This function implements a stepwise approach to calculate distances between all unique pairwise combinations of sampled particles:
\enumerate{
  \item All unique particle samples are extracted from \code{archive} (via \code{\link[flapper]{pf_access_particles_unique}}).
  \item The Euclidean distances between all unique pairwise combinations are calculated (via \code{\link[raster]{pointDistance}}).
  \item If \code{calc_distance = "lcp"}, for all pairwise particle combinations for which Euclidean distances are less than \code{mobility} (if supplied), shortest distances are calculated (via \code{\link[cppRouting]{get_distance_pair}}).
  \item All pairwise particle combinations for which calculated distances are less than \code{mobility} are represented on a sparse \code{\link[Matrix]{dgCMatrix-class}} matrix, with one row and one column for each cell in \code{bathy}. Pairwise distances between unsampled cells and between sampled cells for which the distance exceeds \code{mobility} are represented as zeros.
}

The resultant matrix can be passed to \code{\link[flapper]{pf_simplify}} to streamline distance calculations and/or integrate shortest distances in particle processing/movement path reconstruction. In both cases, the stepwise approach implemented by this function helps to minimise the computation time required for distance calculations because (a) only distances between relevant locations are calculated (once) and (b) any Euclidean distances that exceed \code{mobility} can be ignored when it comes to shortest-distance calculations.
}
\examples{
#### Example (1): Implement function with the default options
# Implement function
bathy <- dat_dcpf_histories$args$bathy
mat <- pf_access_distance_matrix(dat_dcpf_histories, bathy = bathy)
# The function returns a dgCMatrix-class matrix
str(mat)
# There is one row and one column for each cell in bathy
mat@Dim == raster::ncell(bathy)
# For cells that were not sampled & for cells that are more than mobility apart
# ... (if applicable), distances have not been calculated and are given as zero.
# ... For example:
mat[4, 5]
# For cells that were sampled, either Euclidean or shortest distances are given
# ... depending on calc_distance. For example, here is the distance from an example
# ... sampled cell to every other cell (where zero is the default 'non calculated')
# ... distance:
cells <- pf_access_particles_unique(dat_dcpf_histories)
mat[cells[1], ] # or equivalently mat[, cells[1]]
# Here is the distance between two sampled cells, which we can check as follows:
mat[cells[1], cells[2]]
mat[cells[2], cells[1]]
raster::pointDistance(raster::xyFromCell(bathy, cells[1]),
                      raster::xyFromCell(bathy, cells[2]),
                      lonlat = FALSE)

#### Example (2): Implement the function using shortest distances
# Implement algorithm
mat <- pf_access_distance_matrix(dat_dcpf_histories,
                                 bathy = bathy,
                                 calc_distance = "lcp")
# Check shortest distances for our example cell pair
mat[cells[1], cells[2]]
mat[cells[2], cells[1]]
lcp_over_surface(origin = raster::xyFromCell(bathy, cells[1]),
                 destination = raster::xyFromCell(bathy, cells[2]),
                 surface = bathy,
                 goal = 1L)$dist_lcp

#### Example (3): For shortest distances, supply additional args via ...
mat <- pf_access_distance_matrix(dat_dcpf_histories,
                                 bathy = bathy,
                                 calc_distance = "lcp",
                                 allcores = TRUE)

}
\seealso{
\code{\link[flapper]{pf}}, \code{\link[flapper]{pf_simplify}}
}
\author{
Edward Lavender
}
