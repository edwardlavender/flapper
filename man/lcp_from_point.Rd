% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lcps.R
\name{lcp_from_point}
\alias{lcp_from_point}
\title{Create a Raster* of the least-cost distances around a point}
\usage{
lcp_from_point(
  origin,
  surface,
  destination = NULL,
  cost = NULL,
  graph = NULL,
  use_all_cores = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{origin}{A matrix which defines the coordinates (x, y) of the point from which to calculate least-cost distances. Unlike \code{\link[raster]{distanceFromPoints}}, only a single point is expected.}

\item{surface}{A \code{\link[raster]{raster}} across which to implement least-cost distance calculations. If the \code{cost} matrix is derived from \code{\link[flapper]{lcp_costs}} (see below), there are some constraints on the form of this \code{surface}; namely, equal resolution in x and y directions and a Universal Transverse Mercator coordinate reference system with units of metres. The \code{surface} defines the properties of the returned \code{\link[raster]{raster}} (see Value).}

\item{destination}{(optional) An matrix of destination coordinates; an integer vector of cell IDs; or function that defines a subset of destination cells, given their \code{surface} value, for which to implement calculations. For example \code{destination = function(x) x > 0} would restrict least-cost distance calculations to cells of the \code{surface} that have a value of more than zero. Other cells are set to NA. This can improve computational efficiency.}

\item{cost}{(optional) A sparse \code{\link[Matrix]{dsCMatrix-class}} matrix that defines the cost of movement between connected cells (see \code{\link[flapper]{lcp_costs}}). If unsupplied, if the \code{graph} is also unsupplied (see below), a matrix of distances from \code{\link[flapper]{lcp_costs}} is computed internally and taken to define the cost surface. For this to be appropriate, the \code{surface} should have a Universal Transverse Mercator projection, with equal resolution in the x and y directions and units of metres (see \code{surface}, above). If a \code{graph} is supplied, \code{cost} is unnecessary.}

\item{graph}{(optional) A graph object that defines cell nodes and edge costs for connected cells within the \code{surface} (see \code{\link[flapper]{lcp_graph_surface}}). If supplied, the calculation of the cost surface and the construction of the graph stages in the computation of least-cost distances are skipped (see Details), which is desirable in iterative applications.}

\item{use_all_cores}{A logical input that defines whether or not to parallelise least-cost distance calculations across all cores. This is passed to \code{\link[cppRouting]{get_distance_matrix}} which implements calculations.}

\item{verbose}{A logical input that defines whether or not to print messages to the console to relay function progress.}
}
\value{
The function returns a \code{\link[raster]{raster}} in which each cell represents the least-cost distance from a specified \code{origin} to that cell. The \code{origin} is assigned a value of zero. Any cells excluded by the \code{destination} filter have a value of NA.
}
\description{
This function calculates the least-cost distances from a point to all (or some) of the cells in a surrounding \code{\link[raster]{raster}} object, returning a \code{\link[raster]{raster}}. This is the least-cost distance equivalent of \code{\link[raster]{distanceFromPoints}}.
}
\details{
This function implements routines provided via \code{\link[flapper]{flapper}} and the \code{\link[cppRouting]{cppRouting}} package to calculate least-cost distances. The main steps are:
\enumerate{
  \item The calculation of distances between adjacent cells (i.e., \code{cost}, if not supplied, via \code{\link[flapper]{lcp_costs}});
  \item The construction of a graph that defines cell connections from the \code{origin} to surrounding cells on the \code{surface} as a network (via \code{\link[cppRouting]{makegraph}});
  \item The calculation of shortest distances between the \code{origin} and surrounding cells from the graph (via \code{\link[cppRouting]{get_distance_matrix}});
  \item The expression of shortest distances as a \code{\link[raster]{raster}} which is returned.
}
}
\examples{
#### Step (1): Define example origin
proj     <- sp::CRS(SRS_string = "EPSG:4326")
proj_utm <- sp::CRS(SRS_string = "EPSG:32629")
origin   <- matrix(c(-5.616, 56.388), ncol = 2)
origin   <- sp::SpatialPoints(origin, proj)
origin   <- sp::spTransform(origin, proj_utm)

#### Step (2): Select and process surface
# We will focus on an area within the dat_gebco bathymetry raster
boundaries <- raster::extent(707884.6, 709884.6, 6253404, 6255404)
blank      <- raster::raster(boundaries, res = c(5, 5))
r          <- raster::resample(dat_gebco, blank)

#### Example (1): Implement function using default options
lcp_dist <- lcp_from_point(origin = origin, surface = r)
## Visualise outputs
pp <- par(mfrow = c(2, 2))
# Plot surface
raster::plot(r)
# Examine Euclidean distances from point
raster::plot(raster::distanceFromPoints(r, origin))
# Compare to shortest distances
raster::plot(lcp_dist)
par(pp)

if(flapper_run_slow){

#### Example (2): Implement function across specific destinations
## Supply destination cell coordinates/IDs directly
# E.g., consider distances to cells shallower than 125 m
destination_cells <- raster::Which(r < 125, cells = TRUE, na.rm = TRUE)
lcp_dist <- lcp_from_point(origin = origin,
                           surface = r,
                           destination = destination_cells)
raster::plot(lcp_dist)
## Use a function instead to consider distances to cells shallower than 125 m
filter_destination_cells <- function(x) x < 125
lcp_dist <- lcp_from_point(origin = origin,
                           surface = r,
                           destination = filter_destination_cells)
raster::plot(lcp_dist)

#### Example (3): Define cost surfaces for LCP calculations outside of function
# This can be implemented internally, but we compute it here via lcp_costs().
# Note this imposes restrictions on the nature of the surface, such as equal
# ... resolution, which we have forced above.
costs <- lcp_costs(r)
cost  <- costs$dist_total
lcp_dist <- lcp_from_point(origin = origin,
                           surface = r,
                           destination = filter_destination_cells,
                           cost = cost)

#### Example (4): Supply a graph object
graph    <- lcp_graph_surface(surface = r, cost = cost)
lcp_dist <- lcp_from_point(origin = origin, surface = r, graph = graph)

#### Example (5): Implement algorithm in parallel via use_all_cores
lcp_dist <- lcp_from_point(origin = origin, surface = r, use_all_cores = TRUE)

}

}
\seealso{
This function is similar to \code{\link[raster]{distanceFromPoints}}, which returns a Raster* of Euclidean distances. For iterative applications across the same surface, \code{\link[flapper]{lcp_costs}} and \code{\link[flapper]{lcp_graph_surface}} can be implemented to define the cost matrix and the graph object outside of this function. These can be passed to \code{\link[flapper]{lcp_from_point}}, skipping the need to recompute these objects. For shortest-distances and/or paths between specific origin and destination coordinates, the \code{\link[flapper]{lcp_over_surface}} can be used. The particle filtering movement algorithms in \code{\link[flapper]{flapper}} (i.e., \code{\link[flapper]{pf}}) can implement this approach to ensure that movement paths are biologically realistic.
}
\author{
Edward Lavender
}
