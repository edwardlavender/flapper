% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sims.R
\name{sim_path_sa}
\alias{sim_path_sa}
\alias{sim_steps}
\alias{sim_angles}
\title{Simulate discrete-time movement paths from step lengths and turning angles}
\usage{
sim_path_sa(
  n = 10,
  area = NULL,
  p_1 = NULL,
  sim_angle = sim_angles,
  sim_step = sim_steps,
  lag = 0L,
  plot = TRUE,
  add_points = list(pch = 21, bg = "darkgreen"),
  add_path = list(length = 0.05, col = viridis::viridis(n)),
  seed = NULL,
  verbose = TRUE,
  ...
)

sim_steps(...)

sim_angles(...)
}
\arguments{
\item{n}{An integer that defines the number of time steps in the simulation.}

\item{area}{(optional) A \code{\link[sp]{SpatialPolygons-class}} or \code{\link[sp]{SpatialPolygonsDataFrame-class}} object that defines the area(s) within which movement is allowed.}

\item{p_1}{(optional) A matrix with one row and two columns that defines the starting location (x, y). If \code{p_1 = NULL}, then a random location is sampled from \code{area}, if applicable, or simulated from a uniform distribution with a minimum and maximum value of 0 and 1 respectively.}

\item{sim_angle}{A function that is used to simulate turning angles. This must accept a single number that represents some previous turning angle (degrees), even if this is simply ignored (see \code{lag}, below). For example, \code{sim_angle = function() 1} will break but \code{sim_angle = function(...) 1} is fine. For convenience, a default function is included that simulates angles from a wrapped normal circular distribution with a mean and standard deviation of 1 (see \code{\link[circular]{rwrappednormal}}). Functions that actually depend on some previous angle also need to be able to generate initial angles before enough previous angles have been generated for the function to depend on those (see \code{lag}, below). All functions should return a single number that defines the turning angle in degrees.}

\item{sim_step}{A function that is used to simulate step lengths. This follows the same rules as for \code{sim_angle}. For convenience, a default function is included that simulates angles from a gamma distribution with shape and scale parameters of 15 (see \code{\link[stats]{rgamma}}).}

\item{lag}{If \code{sim_angle} and/or \code{sim_step} have been defined such that they depend on some previous angle/step length, then \code{lag} is an integer that defines the number of time steps between the current time step and some previous time step that affects the current turning angle and/or step length.}

\item{plot}{A logical variable that defines whether or not to produce a plot of the area (if provided) and the simulated movement path.}

\item{add_points, add_path}{(optional) Named lists of arguments that are used to customise the appearance of points (the starting location) and the path on the map.}

\item{seed}{(optional) An integer that defines the seed (for reproducible simulations: see \code{\link[base]{set.seed}}).}

\item{verbose}{A logical variable that defines whether or not to print messages to the console that relay function progress.}

\item{...}{Additional arguments. For \code{\link[flapper]{sim_path_sa}}, these are passed to \code{\link[prettyGraphics]{pretty_map}} to customise the map. For the default \code{\link[flapper]{sim_angles}} and \code{\link[flapper]{sim_steps}} functions, \code{...} is required but additional parameters are ignored.}
}
\value{
The function returns a named list of arguments that defines the simulated path ('xy_mat', 'angle_mat', 'step_mat' and 'path') and a named list of arguments that were used to generate the path ('args'). 'xy_mat' is an n-row, two-column matrix that defines the simulated position (x, y) at each time step; 'angle_mat' and 'step_mat' are n-row, one-column matrices that define the simulated turning angle (degrees) and step length (in map units) at each time step; and 'path' is a \code{\link[sp]{SpatialLines}} representation of the movement path.
}
\description{
This function simulates movement paths from step lengths and turning angles. To implement the function, the number of time steps (\code{n}) needs to be specified and, if applicable, the area within which movement should occur. For example, in marine environments, the inclusion of the sea as a spatial layer would restrict movement within the sea. The starting location (\code{p_1}) can be provided or simulated. At each time step, user-defined functions are used to simulate step lengths and turning angles, which can depend previous values of those variables via a \code{lag} parameter, from which the next position is calculated. This implementation enables movement paths to be simulated under a variety of movement models, including random walks and correlated random walks, providing that they are conceptualised in terms of step lengths and turning angles. The function returns a list of outputs that includes the simulated path and, if requested, produces a plot of the simulated path.
}
\details{
This function requires the \code{\link[circular]{circular}} package.
}
\examples{
#### Example (1): Simulate movement path under default parameters
# Simulate path
path <- sim_path_sa()
# The function returns a list of parameters that define the array and a plot
summary(path)

#### Example (2): Change the number of time steps
path <- sim_path_sa(n = 100)

#### Example (3): Change the characteristics of the study area
# .. and define the starting location of the individual
sea  <- invert_poly(dat_coast)
path <- sim_path_sa(n = 100,
                    area = sea,
                    p_1 = matrix(c(706529.1, 6262293), ncol = 2),
                    add_polys = list(x = sea, col = "skyblue"))

#### Example (4): Change the movement model(s) to use alternative distributions/parameters

## Step lengths
# Define new function to simulate step lengths
sim_step_lengths <- function(...) stats::rgamma(1, shape = 10, scale = 1)
# Check outputs suitable values
prettyGraphics::pretty_hist(replicate(n = 1000, expr = sim_step_lengths()))
# Implement simulation
path <- sim_path_sa(n = 100, sim_step = sim_step_lengths)
prettyGraphics::pretty_hist(as.numeric(path$step_mat))

## Turning angles
# E.g., Random walk: draw turning angle from von Mises distribution
sim_angles_vmd <- function(...){
  angle <- circular::rvonmises(n = 1,
                               mu = circular::circular(0),
                               kappa = 0,
                               control.circular = list(units = "degrees"))
  return(as.numeric(angle))
}
path <- sim_path_sa(n = 100, sim_angle = sim_angles_vmd)

# E.g., Correlated random walk: draw turning angle from wrapped normal distribution
sim_angles_rwn <- function(...){
  angle <- circular::rwrappednormal(n = 1,
                                    mu = circular::circular(0),
                                    rho = 0.999,
                                    sd = 0,
                                    control.circular = list(units = "degrees"))
  return(as.numeric(angle))
}
path <- sim_path_sa(n = 100, sim_angle = sim_angles_rwn)

#### Example (5) Change the movement models to depend on some lagged value
# ... of the variable in question
# Define a sim_angle function that depends on some previous angle
# While the time step is less than the lag, the function needs to be
# ... able to handle missing angles and return sensible values in these
# ... cases e.g., via is.null structure:
sim_angles_wrn_with_lag <- function(angle = NULL,...){
  if(is.null(angle)) {
    cat("\n... ... method (1) activated...\n") # useful check
    angle_out <- circular::circular(0)
  } else{
    angle_out <- circular::rwrappednormal(n = 1,
                                          mu = circular::circular(angle, units = "degrees"),
                                          rho = 0.9,
                                          sd = 0.1,
                                          control.circular = list(units = "degrees"))
  }
  return(as.numeric(angle_out))
}
# Check function
sim_angles_wrn_with_lag(NULL)
sim_angles_wrn_with_lag(1)
# Implement algorithm
path <- sim_path_sa(sim_angle = sim_angles_wrn_with_lag, lag = 1)
path <- sim_path_sa(sim_angle = sim_angles_wrn_with_lag, lag = 2)

}
\seealso{
\code{\link[flapper]{sim_path_ou_1}} simulates a movement path based on past locations according to an Ornstein-Uhlenbeck process (which is not based on step lengths and turning angles).
}
\author{
Edward Lavender
}
