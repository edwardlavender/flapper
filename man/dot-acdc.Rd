% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acdc-backend.R
\name{.acdc}
\alias{.acdc}
\title{Back-end implementation of the AC* algorithms}
\usage{
.acdc(
  acoustics,
  archival = NULL,
  step = 120,
  bathy,
  map = NULL,
  detection_range,
  detection_kernels = NULL,
  detection_kernels_overlap = NULL,
  detection_time_window = 5,
  acc_centroids,
  mobility,
  calc_depth_error = function(...) c(-2.5, 2.5),
  normalise = FALSE,
  plot = 1L,
  plot_ts = TRUE,
  verbose = TRUE,
  con = "",
  progress = 1L,
  keep_args = TRUE,
  check = TRUE,
  ...
)
}
\arguments{
\item{acoustics}{A dataframe that contains passive acoustic telemetry detection time series for a specific individual (see \code{\link[flapper]{dat_acoustics}} for an example). This should contain the following columns: an integer vector of receiver IDs, named `receiver_id' (that must match that inputted to the \code{rs} argument of \code{\link[flapper]{acdc_setup_centroids}}); a POSIXct vector of time stamps when detections were made, named `timestamp'; and a numeric vector of those time stamps, named `timestamp_num'.}

\item{archival}{A dataframe that contains depth time series for the same individual (see \code{\link[flapper]{dat_archival}} for an example). This is required for the ACDC* algorithm(s). This should contain the following columns: a numeric vector of observed depths, named `depth'; a POSIXct vector of time stamps when observations were made, named `timestamp'; and a numeric vector of those time stamps, named `timestamp_num'. Depths should be recorded in the same units and with the same sign as the bathymetry data (see \code{bathy}). Absolute depths (m) are suggested. Unlike the detection time series, archival time stamps are assumed to have occurred at regular intervals. Two-minute intervals are currently assumed.}

\item{step}{A number that defines the time step length (s) between consecutive detections. If \code{archival} is supplied, this is the resolution of the archival data (e.g., 120 s).}

\item{bathy}{A \code{\link[raster]{raster}} that defines the area (for the AC algorithm(s)) or bathymetry (for the ACDC* algorithm(s)) across the area within which the individual could have moved. This must be recorded in the same units and with the same sign as the depth observations (see \code{archival}). The coordinate reference system should be the Universal Transverse Mercator system, with distances in metres (see also \code{\link[flapper]{acdc_setup_centroids}}).}

\item{map}{(optional) A blank \code{\link[raster]{raster}}, with the same properties (i.e., dimensions, resolution, extent and coordinate reference system) as the bathymetry raster (see \code{bathy}), but in which all values are 0. If \code{NULL}, this is computed internally, but supplying a pre-defined raster can be more computationally efficient if the function is applied iteratively (e.g., over different time windows).}

\item{detection_range}{A number that defines the maximum detection range (m) at which an individual could be detected from a receiver (see also \code{\link[flapper]{acdc_setup_centroids}}).}

\item{detection_kernels}{A named list of detection probability kernels, from \code{\link[flapper]{acdc_setup_detection_kernels}} and created using consistent parameters as specified for other \code{acdc_setup_*} functions and here (i.e., see the \code{overlaps}, \code{calc_detection_pr} and \code{map} arguments in \code{\link[flapper]{acdc_setup_detection_kernels}}).}

\item{detection_kernels_overlap}{(optional) A named list, from \code{\link[flapper]{get_detection_centroids_overlap}}, that defines, for each receiver, for each day over its deployment period, whether or not its detection centroid overlapped with those of other receivers. If \code{detection_kernels_overlap} and \code{detection_time_window} (below) are supplied, the implementation of detection probability kernels when a detection is made accounts for overlaps in receivers' detection centroids; if un-supplied, receiver detection probability kernels are assumed not to overlap.}

\item{detection_time_window}{(optional) A number that defines the maximum duration (s) between consecutive detections at different receivers such that they can be said to have occurred at `effectively the same time'. This indicates that the same transmission was detected by multiple receivers. If \code{detection_kernels_overlap} (above) and \code{detection_time_window} are supplied, the implementation of detection probability kernels when a detection is made accounts for overlaps in receivers' detection centroids, by up-weighting overlapping areas between receivers that detected the transmission and down-weighting overlapping areas between receivers that did not detect the transmission (see Details in \code{\link[flapper]{acdc_setup_detection_kernels}}).}

\item{acc_centroids}{A list of acoustic centroids, with one element for each number from \code{1:max(acoustics$receiver_id)}, from \code{\link[flapper]{acdc_setup_centroids}}.}

\item{mobility}{A number that defines the distance (m) that an individual could move in the time period between archival observations (see also \code{\link[flapper]{acdc_setup_centroids}}).}

\item{calc_depth_error}{In the ACDC* algorithm(s), \code{calc_depth_error} is function that returns the depth error around a given depth. This should accept a single depth value (from \code{archival$depth}) and return two numbers that, when added to that depth, define the range of depths on the bathymetry raster (\code{bathy}) that the individual could plausibly have occupied at any time, given its depth. Since the depth errors are added to the individual's depth, the first number should be negative (i.e., the individual could have been slightly shallower that observed) and the second positive (i.e., the individual could have been slightly deeper than observed). For example, the constant function \code{calc_depth_error = function(...) c(-2.5, 2.5)} implies that the individual could have occupied bathymetric cells whose depth lies within the interval defined by the observed depth + (-2.5) and + (+2.5) m. The appropriate form for \code{calc_depth_error} depends on measurement error for the depth observations in \code{archival} and bathymetry (\code{bathy}) data, as well as the tidal range (m) across the area (over the duration of observations), but this implementation allows the depth error to depend on depth and for the lower and upper error around an observation to differ.}

\item{normalise}{A logical variable that defines whether or not to normalise the map of possible locations at each time step. In both cases, at each time step the possible locations of the individual are scaled so that the most probable locations have a score of 1 and other scores vary between 0--1. If \code{normalise = FALSE}, these scores are simply summed at each time step, in which case scores on the final map can be interpreted as the number of time steps when the individual could have been in any given location. In contrast, if \code{normalise = TRUE}, at each time step scores are normalised so that they sum to one; the consequence is that time steps with detections, when uncertainty in the individual's location concentrates in the detection centroid around a receiver, are weighted more strongly than time steps between detections, when the uncertainty in the individual's location is spread across a larger area. At the end of the summation process, in the front-end function (e.g., \code{\link[flapper]{acdc}}), the final surface is also normalised, with the scores in each cell (0--1) providing a measure of the relative potential use of each location.}

\item{plot}{An integer vector that defines the time steps for which to return the necessary spatial information required to plot the plausible locations of the individual, given detection and depth time series. \code{plot = 0} suppresses the return of this information and \code{plot = NULL} returns this information for all time steps. This spatial information can be used to plot time-specific results of the algorithm using \code{\link[flapper]{acdc_plot}}.}

\item{plot_ts}{A logical input that defines whether or not to the plot detection and depth time series before the algorithm is initiated. This provides a useful visualisation of the extent to which they overlap.}

\item{verbose}{A logical variable that defines whether or not to print messages to the console or to file to relay function progress. If \code{con = ""}, messages are printed to the console; otherwise, they are written to file (see below).}

\item{con}{If \code{verbose = TRUE}, \code{con} is character string that defines the full pathway to a .txt file into which messages are written to relay function progress. This approach, rather than printing to the console, is recommended for clarity, speed and debugging.}

\item{progress}{An integer (\code{1}, \code{2} or \code{3}) that defines whether or not to display a progress bar in the console as the algorithm moves over acoustic time steps (\code{1}), the archival time steps between each pair of acoustic detections (\code{2}) or both acoustic and archival time steps (\code{3}), in which case the overall acoustic progress bar is punctuated by an archival progress bar for each pair of acoustic detections. This option is useful if there is a large number of archival observations between acoustic detections. Any other input will suppress the progress bar.}

\item{keep_args}{A logical input that defines whether or not to include a list of function arguments in the outputs. This can be switched off if the function is applied iteratively.}

\item{check}{A logical input that defines whether or not to check function inputs. This can be switched off to improve computation time when the function is applied iteratively.}

\item{...}{Additional arguments (none implemented).}
}
\value{
The function returns a \code{\link[flapper]{.acdc-class}} object with the following elements: `map', `record', `time', `args', `chunks' and `simplify'. The main output element is the `map' RasterLayer that shows where the individual could have spent more or less time over the duration of the movement time series. The `record' element records time-specific information on the possible locations of the individual, and can be used to plot maps of specific time points or to produce animations (for the time steps specified by \code{plot}). The `time' element is a dataframe that defines the times of sequential stages in the algorithm's progression, providing a record of computation time. The `args' element is a named list of user inputs that record the parameters used to generate the outputs (if \code{keep_args = TRUE}, otherwise the `args' element is \code{NULL}).
}
\description{
This function is the back-end of the AC, ACDC, ACPF and ACDCPF algorithms.
}
\examples{
#### Step (1) Prepare study site grid
# Grid resolution needs to be sufficiently high to capture detection probability/movement
# And sufficiently low to minimise computational costs
blank <- raster::raster(raster::extent(dat_gebco), res = c(75, 75))
gebco <- raster::resample(dat_gebco, blank)

#### Step (2) Implement setup_acdc_*() steps
# ... Define acoustic centroids required for algorithm(s) (see acdc_setup_centroids())

#### Step (3) Prepare movement time series for algorithm(s)
# Add required columns to dataframes:
dat_acoustics$timestamp_num <- as.numeric(dat_acoustics$timestamp)
dat_archival$timestamp_num  <- as.numeric(dat_archival$timestamp)
# Focus on an example individual
id <- 25
acc <- dat_acoustics[dat_acoustics$individual_id == id, ]
arc <- dat_archival[dat_archival$individual_id == id, ]
# Focus on the subset of data for which we have both acoustic and archival detections
acc <- acc[acc$timestamp >= min(arc$timestamp) - 2*60 &
             acc$timestamp <= max(arc$timestamp) + 2*60, ]
arc <- arc[arc$timestamp >= min(acc$timestamp) - 2*60 &
             arc$timestamp <= max(acc$timestamp) + 2*60, ]
# We'll focus on a one day period with overlapping detection/depth time series for speed
end <- as.POSIXct("2016-03-18")
acc <- acc[acc$timestamp <= end, ]
arc <- arc[arc$timestamp <= end, ]
arc <- arc[arc$timestamp >= min(acc$timestamp) - 2*60 &
             arc$timestamp <= max(acc$timestamp) + 2*60, ]

#### Example (1) Implement AC algorithm with default arguments
out_acdc <- .acdc(acoustics = acc,
                  bathy = gebco,
                  detection_range = 425,
                  mobility = 200,
                  acc_centroids = dat_centroids)

#### Example (2) Implement ACDC algorithm with default arguments
out_acdc <- .acdc(acoustics = acc,
                  archival = arc,
                  bathy = gebco,
                  detection_range = 425,
                  mobility = 200,
                  calc_depth_error = function(...) c(-2.5, 2.5),
                  acc_centroids = dat_centroids,
                  )

#### Example (3) Implement AC or ACDC algorithm with detection probability kernels

## (A) Get detection centroid overlaps
# Define receiver locations as a SpatialPointsDataFrame object with a UTM CRS
proj_wgs84 <- sp::CRS("+init=epsg:4326")
proj_utm <- sp::CRS(paste("+proj=utm +zone=29 +datum=WGS84",
                          "+units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
rownames(dat_moorings) <- dat_moorings$receiver_id
xy <- sp::SpatialPoints(dat_moorings[, c("receiver_long", "receiver_lat")],
                        proj_wgs84)
xy <- sp::spTransform(xy, proj_utm)
xy <- sp::SpatialPointsDataFrame(xy, dat_moorings[, c("receiver_id",
                                                      "receiver_start_date",
                                                      "receiver_end_date")])
# Get detection overlap(s) as a SpatialPolygonsDataFrame
centroids <- get_detection_centroids(xy = sp::SpatialPoints(xy),
                                     detection_range = 425,
                                     coastline = dat_coast,
                                     byid = TRUE)
centroids_df <- dat_moorings[, c("receiver_id",
                                 "receiver_start_date",
                                 "receiver_end_date")]
row.names(centroids_df) <- names(centroids)
centroids <- sp::SpatialPolygonsDataFrame(centroids, centroids_df)
overlaps <- get_detection_centroids_overlap(centroids =  centroids)

## (B) Define detection probability function based on distance and detection_range
calc_dpr <-
  function(x){
    ifelse(x <= 425, stats::plogis(2.5 + -0.02 * x), 0)
  }

## (C) Get detection kernels (a slow step)
kernels <- acdc_setup_detection_kernels(xy = xy,
                                        centroids = dat_centroids,
                                        overlaps = overlaps,
                                        calc_detection_pr = calc_dpr,
                                        map = gebco,
                                        coastline = invert_poly(dat_coast))
## (D) Implement algorithm
out_acdc <- .acdc(acoustics = acc,
                  archival = arc,
                  bathy = gebco,
                  detection_range = 425,
                  detection_kernels = kernels,
                  detection_kernels_ovelaps = overlaps,
                  detection_time_window = 10,
                  mobility = 200,
                  calc_depth_error = function(...) c(-2.5, 2.5),
                  acc_centroids = dat_centroids,
                  )

#### Example (4): Implement AC or ACDC algorithm and write messages to file via 'con'
\dontrun{
out_acdc <- .acdc(acoustics = acc,
                  archival = arc,
                  bathy = gebco,
                  detection_range = 425,
                  mobility = 200,
                  calc_depth_error = function(...) c(-2.5, 2.5),
                  acc_centroids = dat_centroids,
                  verbose = TRUE,
                  con = paste0(tempdir(), "/", "acdc_log.txt")
                 )
# Check log
utils::head(readLines(paste0(tempdir(), "/", "acdc_log.txt")))
utils::tail(readLines(paste0(tempdir(), "/", "acdc_log.txt")))
}

#### Example (5): Implement AC or ACDC algorithm and return plotting information
# Specify plot = NULL to include plotting information for all time steps
# ... or a vector to include this information for specific time steps
\dontrun{
out_acdc <- .acdc(acoustics = acc,
                  archival = arc,
                  bathy = gebco,
                  space_use = NULL,
                  detection_range = 425,
                  mobility = 200,
                  calc_depth_error = function(...) c(-2.5, 2.5),
                  acc_centroids = dat_centroids,
                  plot = NULL,
                  verbose = TRUE,
                  con = paste0(tempdir(), "/", "acdc_log.txt")
                  )
}

}
\seealso{
\code{\link[flapper]{acdc_setup_centroids}} defines the acoustic centroids required by this function. This is supported by \code{\link[flapper]{acdc_setup_n_centroids}} which suggests a suitable number of centroids.  \code{\link[flapper]{acdc_setup_mobility}} is used to examine the assumption of the constant `mobility' parameter.\code{\link[flapper]{acdc_setup_detection_kernels}} produces detection probability kernels for incorporation into the function. \code{\link[flapper]{acdc}} is the front-end of the ACDC algorithm. \code{\link[flapper]{acdc_plot}} and \code{\link[flapper]{acdc_animate}} visualise the results.
}
\author{
Edward Lavender
}
