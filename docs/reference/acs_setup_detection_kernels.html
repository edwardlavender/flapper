<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Setup detection probability kernels for the AC* algorithm(s) — acs_setup_detection_kernels • flapper</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Setup detection probability kernels for the AC* algorithm(s) — acs_setup_detection_kernels" />
<meta property="og:description" content="This function produces detection probability kernels for incorporation into the acoustic-contour* (AC*) algorithms. Within acoustic centroids, the incorporation of detection probability kernels reduces uncertainty and increases precision in simulated patterns of space use by up-weighting areas nearer to receivers when an individual is detected and down-weighing areas nearer to receivers when an individual is not detected (see Details).
To implement the function, a SpatialPointsDataFrame that defines receiver IDs, locations and deployment dates must be supplied (via xy). A record of servicing events for receivers can also be supplied (via services). Detection probability kernels are calculated around each receiver, using a user-defined function based on Euclidean distances (calc_detection_pr) across a raster (map). Kernels can be restricted by the coastline and boundaries of an area if applicable. These kernels are used to weight possible locations around a receiver when an individual is detected.
For each unique array design (i.e. set of active receivers, given receiver deployment dates and servicing events, if applicable), a detection probability surface across the whole area is also created, which is used to weight possible locations of the individual in the time steps between detections (up-weighting locations away from receivers). By default, these calculations account for any areas of overlap in the detection probability kernels of multiple receivers. This step is computationally demanding, but it can be suppressed or sped-up via the overlaps argument. Outputs are returned in a named list that is designed to be incorporated into the AC* algorithm(s)." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flapper</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/flapper.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/edwardlavender/flapper/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Setup detection probability kernels for the AC* algorithm(s)</h1>
    <small class="dont-index">Source: <a href='https://github.com/edwardlavender/flapper/blob/master/R/acs_setup.R'><code>R/acs_setup.R</code></a></small>
    <div class="hidden name"><code>acs_setup_detection_kernels.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function produces detection probability kernels for incorporation into the acoustic-contour* (AC*) algorithms. Within acoustic centroids, the incorporation of detection probability kernels reduces uncertainty and increases precision in simulated patterns of space use by up-weighting areas nearer to receivers when an individual is detected and down-weighing areas nearer to receivers when an individual is not detected (see Details).</p>
<p>To implement the function, a <code><a href='https://rdrr.io/pkg/sp/man/SpatialPoints.html'>SpatialPointsDataFrame</a></code> that defines receiver IDs, locations and deployment dates must be supplied (via <code>xy</code>). A record of servicing events for receivers can also be supplied (via <code>services</code>). Detection probability kernels are calculated around each receiver, using a user-defined function based on Euclidean distances (<code>calc_detection_pr</code>) across a <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> (<code>map</code>). Kernels can be restricted by the <code>coastline</code> and <code>boundaries</code> of an area if applicable. These kernels are used to weight possible locations around a receiver when an individual is detected.</p>
<p>For each unique array design (i.e. set of active receivers, given receiver deployment dates and servicing events, if applicable), a detection probability surface across the whole area is also created, which is used to weight possible locations of the individual in the time steps between detections (up-weighting locations away from receivers). By default, these calculations account for any areas of overlap in the detection probability kernels of multiple receivers. This step is computationally demanding, but it can be suppressed or sped-up via the <code>overlaps</code> argument. Outputs are returned in a named list that is designed to be incorporated into the AC* algorithm(s).</p>
    </div>

    <pre class="usage"><span class='fu'>acs_setup_detection_kernels</span><span class='op'>(</span>
  <span class='va'>xy</span>,
  services <span class='op'>=</span> <span class='cn'>NULL</span>,
  <span class='va'>centroids</span>,
  overlaps <span class='op'>=</span> <span class='cn'>NULL</span>,
  <span class='va'>calc_detection_pr</span>,
  <span class='va'>map</span>,
  coastline <span class='op'>=</span> <span class='cn'>NULL</span>,
  boundaries <span class='op'>=</span> <span class='cn'>NULL</span>,
  verbose <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>xy</th>
      <td><p>A <code><a href='https://rdrr.io/pkg/sp/man/SpatialPoints.html'>SpatialPointsDataFrame</a></code> that defines receiver IDs, locations and deployment dates. The <code>data</code> slot must include a dataframe with the following columns: an unique, integer identifier for each receiver (`receiver_id') and receiver deployment <code><a href='https://rdrr.io/r/base/Dates.html'>Dates</a></code> (`receiver_start_date' and `receiver_end_date'). For receiver locations, the coordinate reference system should be the Universal Transverse Mercator system with distances in metres (as for <code>map</code>, below).</p></td>
    </tr>
    <tr>
      <th>services</th>
      <td><p>(optional) A dataframe that defines receiver IDs and servicing <code><a href='https://rdrr.io/r/base/Dates.html'>Dates</a></code> (times during the deployment period of a receiver when it was not active due to servicing). If provided, this must contain the following columns: an integer identifier for serviced receivers (named ‘receiver_id’) and two columns that define the time of the service(s) (‘service_start_date’ and ‘service_end_date’) (see <code><a href='make_matrix_receivers.html'>make_matrix_receivers</a></code>).</p></td>
    </tr>
    <tr>
      <th>centroids</th>
      <td><p>The list of detection centroids, with one element for each number from <code>1:max(xy$receiver_id)</code>, from <code><a href='acs_setup_centroids.html'>acs_setup_centroids</a></code>.</p></td>
    </tr>
    <tr>
      <th>overlaps</th>
      <td><p>(optional) A named list, from <code><a href='get_detection_centroids_overlap.html'>get_detection_centroids_overlap</a></code>, that defines, for each receiver, for each day over its deployment period, whether or not its detection centroid overlapped with those of other receivers. If provided, this speeds up detection probability calculations in overlapping regions by focusing on only the subset of receivers with overlapping detection probability kernels. If there are no overlapping receivers, <code>FALSE</code> can be supplied instead to suppress these calculations.</p></td>
    </tr>
    <tr>
      <th>calc_detection_pr</th>
      <td><p>A function that takes in a vector of distances and returns a vector of detection probabilities (around a receiver). Detection probability should decline to 0 after the <code>detection_range</code> distance from a receiver (see <code><a href='acs_setup_centroids.html'>acs_setup_centroids</a></code>).</p></td>
    </tr>
    <tr>
      <th>map</th>
      <td><p>A (blank) <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> on which receiver locations and detection probability kernels are represented. As for <code>xy</code>, the coordinate reference system should be the Universal Transverse Mercator system with distances in metres. Resolution needs to be sufficiently high such that detection probability can be represented effectively, given <code>calc_detection_pr</code>, but sufficiently low for convenient run times. For the <code><a href='acdc.html'>acdc</a></code> algorithm, this should have the same properties as <code>bathy</code>.</p></td>
    </tr>
    <tr>
      <th>coastline</th>
      <td><p>(optional) A <code><a href='https://rdrr.io/pkg/sp/man/SpatialPolygonsDataFrame-class.html'>SpatialPolygonsDataFrame-class</a></code> mask applied to detection probability kernels (e.g. on land, as in  <code><a href='acs_setup_centroids.html'>acs_setup_centroids</a></code>). Algorithm speed declines with the complexity of <code>coastline</code>.</p></td>
    </tr>
    <tr>
      <th>boundaries</th>
      <td><p>An <code><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></code> object that defines the boundaries of an area within which individuals are assumed to have remained (as in <code><a href='acs_setup_centroids.html'>acs_setup_centroids</a></code>), if these are different from the extent of <code>map</code>. If provided, detection probability kernels are processed to remain within this area.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>A logical input that defines whether or not to print messages to the console to relay function progress.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The function returns a named list with five elements:</p><ol>
<li><p><strong>receiver_specific_kernels.</strong> A list, with one element for all integers from 1 to the maximum receiver number. Any elements that do not correspond to receivers contain a <code>NULL</code> element. List elements that correspond to receivers contain a <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> of the detection probability kernel around the relevant receiver. Cells values define the detection probability around a receiver, given <code>calc_detection_pr</code>. In the AC* algorithm(s), these kernels are used to up-weight location probabilities near to a receiver when it is detected (following modification to account for overlapping areas, if necessary).</p></li>
<li><p><strong>receiver_specific_inv_kernels.</strong> A list, as for <code>receiver_specific_kernels</code>, but in which elements contain the inverse detection probability kernels (i.e., 1 - detection probability). In the AC* algorithm(s), these is used to down-weight-weight location probabilities in the overlapping regions between a receiver that recorded detections and others that did not at the same time.</p></li>
<li><p><strong>array_design_intervals.</strong> A dataframe that defines the number and deployment times of each unique array design, resulting from receiver deployment, servicing and removal. In the times between detections, this is used to select the appropriate `background' detection probability surface (see below). This contains the following columns:</p><ul>
<li><p><code>array_id</code> An integer vector that defines each unique array design.</p></li>
<li><p><code>array_start_date</code> A Date that defines the start date of each array design.</p></li>
<li><p><code>array_end_date</code> A Date that defines the end date of each array design.</p></li>
<li><p><code>array_interval</code> An <code><a href='https://lubridate.tidyverse.org/reference/Interval-class.html'>Interval-class</a></code> vector that defines the deployment period of each array design.</p></li>
</ul></li>
<li><p><strong>bkg_surface_by_design.</strong> A list, with one element for each array design, that defines the detection probability surface across all receivers deployed in that phase of the study. In areas that are covered by the detection probability kernel of a single receiver, the detection probability depends only on distance to that receiver (via <code>calc_detection_pr</code>). In areas covered by multiple, overlapping kernels, detection probability represents the combined detection probability across all overlapping kernels (see Details).</p></li>
<li><p><strong>bkg_inv_surface_by_design.</strong> A list, as above for <code>bkg_surface_by_design</code>, but which contains the inverse detection probability surface (i.e., 1 - <code>bkg_surface_by_design</code>). In the AC* algorithm(s), this is used to up-weight areas away from receivers (or, equivalently, down-weight areas near to receivers) in the time steps between detections.</p></li>
</ol>

    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>A detection probability kernel is a bivariate probability density function that describes detection probability around a receiver. Typically, this takes the shape of a dome whereby detection probability declines uniformly around a receiver with increasing distance. Accordingly, this function assumes that detection probability kernels only depend on distance (via <code>calc_detection_pr</code>) and are constant in space and time. Spatially variable detection probability kernels can be incorporated just as easily into the AC* algorithm(s) but need to be created manually. For example, in areas of complex coastline, narrow peninsulas that punctuate detection centroids may effectively block transmissions from the outer regions of detection centroids from being detected at receivers, in which case a model that incorporates the `line of sight' between receivers and the surrounding regions may be appropriate. However, temporally variable detection probability kernels are not currently supported by the AC* algorithm(s).</p>
<p>The purpose of detection probability kernels within the AC* algorithm(s) is to reduce the uncertainty of the possible positions of an individual within the acoustic centroids, both when an individual is detected and when it is not. When an individual is detected at a receiver, a central assumption of the AC* algorithm(s) is that the individual is within a finite radius of that receiver in an area defined as the ‘detection centroid’. Under the simplest implementation of the algorithm, this represents a threshold detection probability model in which the probability of detection is certain within the centroid and zero outside. Under this model, the individual is equally likely to have been in any location within the centroid and all possible locations of the individual are weighted equally. This approach is suitable for the most conservative analyses, since even unlikely positions of the individual receive equal weighting. However, detection probability typically declines with distance around a receiver and the incorporation of this information in the form of kernels around the receiver at which is detected (and any receivers with overlapping kernels) improve precision by increasing the weighting for some areas over others. The way in which this increase in precision is realised over space depends on whether or not detection probability kernels and the timing of detections at multiple receivers overlap.</p>
<p>In the simplest scenario, an individual is detected at a receiver whose centroid does not overlap with any other receiver and the kernel simply increases the weight of locations nearest to the receiver (according to a user-specified detection probability function). For some array designs, an alternative possibility is that an individual is detected at a receiver whose centroid overlaps with other receiver(s). In this case, detection or lack of detection at the same moment at the receivers with overlapping centroids provides further information on the location of the individual. One the one hand, if the individual is not detected at the other receiver(s), then the probability that the individual is in the overlapping region(s) is reduced in line with the overlap in detection probability, which decreases the weight of potential locations in these areas. On the other hand, if the individual is detected at effectively the same time at multiple receiver(s), then the individual is more likely to be within the overlapping parts of their centroids, and the weight of possible locations here is correspondingly elevated. The definition of ‘effectively’ is context specific but depends on the accuracy with which the clocks of different receivers are synchronised. (For example, ± 5 s might be reasonable.) In these situations, the detection centroid essentially just acts as a computational device by restricting calculations to the centroid(s) and ‘cutting’ the probability of detection to zero beyond this area.</p>
<p>This process follows the standard rules of probability, with the probability of any location (xy) when the individual is detected given by the product of the detection probability at all the receivers at which the individual was detected (\(\prod Pr(det)_{xy, detection = 1}\), which up-weights areas that intersect between receivers that recorded detections), multiplied by the product of not being detected at all the receivers at which it was not detected (\(\prod (1 - Pr(det)_{xy, detection = 0}\), which down-weights areas that intersect with receivers that did not record detections); i.e.,</p>
<p>$$\prod Pr(det)_{xy, detection = 1} \times \prod (1 - Pr(det)_{xy, detection = 0}$$</p>
<p>By way of illustration, consider a simple array comprising three equidistant receivers with equally overlapping detection centroids. An individual is detected at two receivers but not the third. In this scenario, the individual must be located in the intersection between the centroids of the two receivers at which it was detected, but it is more likely to be located in the part of this region that does not intersect with the third receiver (call this area A and the intersecting area for all three receivers B). To assign some numbers to this example, consider the overlap of a single detection probability, say the contour \(Pr(det) = 0.2\). In this case, the probability of the individual being located in area A is the probability of being detected at receiver 1 (0.2) and receiver 2 (0.2) but not receiver (3) (\(1 - 0\)), which equals 0.04. In comparison, the probability of the individual being located in area B is the probability of being detected at receiver 1 (0.2) and receiver 2 (0.2), but not receiver 3 (\(1 - 0.2\)), which equals 0.032. (In the AC* algorithms(s), these probabilities are re-scaled, but the point is detection probability kernels up-weight some areas and down-weight others, using the rules of probability, in line with intuitive expectations.)</p>
<p>When an individual is not detected, the detection centroid grows into a set of ‘acoustic centroids’ that describe our increasing uncertainty in the location of the individual. As they grow, they may encompass other detection centroids before they shrink towards the receiver at which the individual is next detected. During this time, the AC* algorithm(s) identify the possible locations of the individual within these areas. Under the most conservative approach, at each time step all positions are treated as equally likely (although normalisation within the algorithm(s) can be implemented to down-weight time steps in which the location of the individual is more uncertain). This includes any positions within the detection centroids of other receivers since, under realistic conditions, there is usually a non-zero probability that an individual can be near a receiver and yet remain undetected. However, this is typically unlikely and when the goal of the analysis is to create more precise estimates of space use, the incorporation of detection probability kernel(s) around receivers effectively reduces the probability that the individual is within their detection centroids during this time. Again, to incorporate detection probability kernels in this way, it is necessary to account for overlapping detection ranges, where the probability of detection is higher and, therefore, the probability of a possible location in such an area is lower given the absence of a detection. As above, this process follows the laws of probability. In any given location, the probability of no detection(s) is given by the product of receivers' inverse detection probability kernels. This is used to down-weight possible locations near receivers, especially in areas with overlapping kernels, effectively up-weighting possible locations further away, when an individual is not detected.</p>
<p>In summary, in the AC* algorithm(s), detection and acoustic centroids describe the spatial extent of our uncertainty when an individual is detected and in the time between detections respectively. The purpose of this function is to pre-process and package the information provided by detection probability kernels in such a way as to facilitate its incorporation into the AC* algorithm(s). This improves the precision of simulated patterns of space use by down- or up-weighting areas according to a model of detection probability. This provides a reasonable overall assessment of the places in which an individual could have spend more or less time over a period of study.</p>
<p>However, it is worth noting that, within acoustic centroids, unrealistic areas may be highlighted in which an individual could not have been located because of movement constraints which are not captured by centroid-level expansion and contraction. For example, there may be parts of a centroid that are highly unlikely given a detection at a nearby receiver because they are too far away from the receiver at which the individual was subsequently detected. In the AC*PF algorithm(s), the incorporation of a movement model further reduces uncertainty by accounting for the constraints imposed by an individual’s current position on its next position.</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p>This is one of a number of functions used to set up the AC and ACDC algorithms implemented by <code><a href='ac.html'>ac</a></code> and <code><a href='acdc.html'>acdc</a></code>: <code><a href='acs_setup_mobility.html'>acs_setup_mobility</a></code>, <code><a href='acs_setup_centroids.html'>acs_setup_centroids</a></code> and <code>acs_setup_detection_kernels</code>. This function is supported by <code><a href='make_matrix_receivers.html'>make_matrix_receivers</a></code>, which defines receiver activity statuses; <code><a href='acs_setup_centroids.html'>acs_setup_centroids</a></code>, which defines acoustic centroids; and <code><a href='get_detection_centroids_overlap.html'>get_detection_centroids_overlap</a></code>, which defines detection centroid overlaps</p></div>
    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Edward Lavender</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'>#### Set up data for examples</span>

<span class='co'>## Define receiver IDs, locations and deployment dates</span>
<span class='co'># Focus on a subset of receivers for example speed</span>
<span class='va'>moorings</span> <span class='op'>&lt;-</span> <span class='va'>dat_moorings</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>5</span>, <span class='op'>]</span>
<span class='co'># Define receiver locations as a SpatialPoints object with a UTM CRS</span>
<span class='va'>proj_wgs84</span> <span class='op'>&lt;-</span> <span class='fu'>sp</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/sp/man/CRS-class.html'>CRS</a></span><span class='op'>(</span>SRS_string <span class='op'>=</span> <span class='st'>"EPSG:4326"</span><span class='op'>)</span>
<span class='va'>proj_utm</span>   <span class='op'>&lt;-</span> <span class='fu'>sp</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/sp/man/CRS-class.html'>CRS</a></span><span class='op'>(</span>SRS_string <span class='op'>=</span> <span class='st'>"EPSG:32629"</span><span class='op'>)</span>
<span class='va'>xy</span> <span class='op'>&lt;-</span> <span class='fu'>sp</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/sp/man/SpatialPoints.html'>SpatialPoints</a></span><span class='op'>(</span><span class='va'>moorings</span><span class='op'>[</span>, <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"receiver_long"</span>, <span class='st'>"receiver_lat"</span><span class='op'>)</span><span class='op'>]</span>,
                        <span class='va'>proj_wgs84</span><span class='op'>)</span>
<span class='va'>xy</span> <span class='op'>&lt;-</span> <span class='fu'>sp</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/sp/man/spTransform.html'>spTransform</a></span><span class='op'>(</span><span class='va'>xy</span>, <span class='va'>proj_utm</span><span class='op'>)</span>
<span class='co'># Link receiver IDs, locations and deployment dates to form a SpatialPointsDataFrame</span>
<span class='co'># ... Note required column names and class types.</span>
<span class='va'>xy</span> <span class='op'>&lt;-</span> <span class='fu'>sp</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/sp/man/SpatialPoints.html'>SpatialPointsDataFrame</a></span><span class='op'>(</span><span class='va'>xy</span>, <span class='va'>moorings</span><span class='op'>[</span>, <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"receiver_id"</span>,
                                                  <span class='st'>"receiver_start_date"</span>,
                                                  <span class='st'>"receiver_end_date"</span><span class='op'>)</span><span class='op'>]</span><span class='op'>)</span>

<span class='co'>## Define blank map of area for which AC* algorithm(s) will be implemented</span>
<span class='co'># ... The resolution must be sufficiently high</span>
<span class='co'># ... such that there are areas with non zero detection probability.</span>
<span class='co'># ... However, function speed will fall with large, high resolution rasters.</span>
<span class='co'># ... Here, we set a low resolution for example speed.</span>
<span class='va'>map_blank</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></span><span class='op'>(</span><span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>dat_gebco</span><span class='op'>)</span>, res <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>50</span>, <span class='fl'>50</span><span class='op'>)</span><span class='op'>)</span>
<span class='va'>map_blank</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/setValues.html'>setValues</a></span><span class='op'>(</span><span class='va'>map_blank</span>, <span class='fl'>0</span><span class='op'>)</span>

<span class='co'>## Define detection probability function</span>
<span class='co'># This should depend on distance alone</span>
<span class='co'># Detection probability should decline to 0 after detection_range</span>
<span class='co'># ... (defined in flapper::acs_setup_centroids()).</span>
<span class='co'># ... Here, we assume detection_range = 425 m.</span>
<span class='va'>calc_dpr</span> <span class='op'>&lt;-</span>
  <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span><span class='op'>{</span>
    <span class='fu'><a href='https://rdrr.io/r/base/ifelse.html'>ifelse</a></span><span class='op'>(</span><span class='va'>x</span> <span class='op'>&lt;=</span> <span class='fl'>425</span>, <span class='fu'>stats</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/stats/Logistic.html'>plogis</a></span><span class='op'>(</span><span class='fl'>2.5</span> <span class='op'>+</span> <span class='op'>-</span><span class='fl'>0.02</span> <span class='op'>*</span> <span class='va'>x</span><span class='op'>)</span>, <span class='fl'>0</span><span class='op'>)</span>
  <span class='op'>}</span>
<span class='fu'><a href='https://rdrr.io/r/graphics/plot.default.html'>plot</a></span><span class='op'>(</span><span class='fl'>0</span><span class='op'>:</span><span class='fl'>1000</span>, <span class='fu'>calc_dpr</span><span class='op'>(</span><span class='fl'>0</span><span class='op'>:</span><span class='fl'>1000</span><span class='op'>)</span>, type <span class='op'>=</span> <span class='st'>"l"</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-1.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'>## Get detection centroids and, if applicable, information on their overlap(s)</span>
<span class='co'># We'll use the example centroids provided in dat_centroids</span>
<span class='co'># We'll get their overlaps via flapper::get_detection_centroids_overlap</span>
<span class='va'>overlaps</span> <span class='op'>&lt;-</span>
  <span class='fu'><a href='get_detection_centroids_overlap.html'>get_detection_centroids_overlap</a></span><span class='op'>(</span>
    centroids <span class='op'>=</span> <span class='fu'><a href='get_detection_centroids.html'>get_detection_centroids</a></span><span class='op'>(</span>xy <span class='op'>=</span> <span class='va'>xy</span>, byid <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
  <span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-2.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'>#### Example (1): Implement function using default options</span>
<span class='va'>kernels</span> <span class='op'>&lt;-</span> <span class='fu'>acs_setup_detection_kernels</span><span class='op'>(</span>xy <span class='op'>=</span> <span class='va'>xy</span>,
                                       centroids <span class='op'>=</span> <span class='va'>dat_centroids</span>,
                                       overlaps <span class='op'>=</span> <span class='va'>overlaps</span>,
                                       calc_detection_pr <span class='op'>=</span> <span class='va'>calc_dpr</span>,
                                       map <span class='op'>=</span> <span class='va'>map_blank</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::acs_setup_detection_kernels() called (@ 2021-12-02 14:35:52)... 
#&gt; ... Setting up function... 
#&gt; ... Getting receiver-specific kernels (for detection)... 
#&gt; 
#&gt; ... ... For receiver 3 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; 
#&gt; ... ... For receiver 4 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; 
#&gt; ... ... For receiver 7 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; 
#&gt; ... ... For receiver 9 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; 
#&gt; ... ... For receiver 11 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; ... Getting receiver-specific inverse kernels... 
#&gt; ... Getting area-wide kernels (for non-detection)... 
#&gt; ... ... Get unique array designs... 
#&gt; ... ... Get area wide kernels for each array design... 
#&gt; 
#&gt; ... ... ... For design 1/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; 
#&gt; ... ... ... For design 2/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; 
#&gt; ... ... ... For design 3/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; 
#&gt; ... ... ... For design 4/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; 
#&gt; ... ... ... For design 5/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; ... Process detection probability kernels ... 
#&gt; ... flapper::acs_setup_detection_kernels() call completed (@ 2021-12-02 14:35:54) after ~0.03 minutes. </div><div class='input'>
<span class='co'># Examine list elements</span>
<span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>)</span>
</div><div class='output co'>#&gt;                               Length Class      Mode
#&gt; receiver_specific_kernels     11     -none-     list
#&gt; receiver_specific_inv_kernels 11     -none-     list
#&gt; array_design_intervals         4     data.frame list
#&gt; bkg_surface_by_design          5     -none-     list
#&gt; bkg_inv_surface_by_design      5     -none-     list</div><div class='input'>
<span class='co'># Examine example receiver-specific kernels</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>receiver_specific_kernels</span><span class='op'>[[</span><span class='fl'>3</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span><span class='op'>(</span><span class='va'>xy</span><span class='op'>[</span><span class='va'>xy</span><span class='op'>$</span><span class='va'>receiver_id</span> <span class='op'>==</span> <span class='fl'>3</span>, <span class='op'>]</span>, cex <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>receiver_specific_kernels</span><span class='op'>[[</span><span class='fl'>4</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span>
</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span><span class='op'>(</span><span class='va'>xy</span><span class='op'>[</span><span class='va'>xy</span><span class='op'>$</span><span class='va'>receiver_id</span> <span class='op'>==</span> <span class='fl'>4</span>, <span class='op'>]</span>, cex <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-3.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

<span class='co'># Examine example receiver-specific inverse kernels</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>receiver_specific_inv_kernels</span><span class='op'>[[</span><span class='fl'>3</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span><span class='op'>(</span><span class='va'>xy</span><span class='op'>[</span><span class='va'>xy</span><span class='op'>$</span><span class='va'>receiver_id</span> <span class='op'>==</span> <span class='fl'>3</span>, <span class='op'>]</span>, cex <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>receiver_specific_inv_kernels</span><span class='op'>[[</span><span class='fl'>4</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span>
</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span><span class='op'>(</span><span class='va'>xy</span><span class='op'>[</span><span class='va'>xy</span><span class='op'>$</span><span class='va'>receiver_id</span> <span class='op'>==</span> <span class='fl'>4</span>, <span class='op'>]</span>, cex <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-4.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

<span class='co'># Examine background detection Pr surfaces</span>
<span class='co'># (for each unique combination of receivers that were deployed)</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>2</span>, <span class='fl'>3</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/base/lapply.html'>lapply</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>bkg_surface_by_design</span>, <span class='kw'>function</span><span class='op'>(</span><span class='va'>bkg</span><span class='op'>)</span> <span class='op'>{</span>
  <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>bkg</span>, axes <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
  <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/box.html'>box</a></span><span class='op'>(</span><span class='op'>)</span>
<span class='op'>}</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [[1]]
#&gt; NULL
#&gt; 
#&gt; [[2]]
#&gt; NULL
#&gt; 
#&gt; [[3]]
#&gt; NULL
#&gt; 
#&gt; [[4]]
#&gt; NULL
#&gt; 
#&gt; [[5]]
#&gt; NULL
#&gt; </div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-5.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'># Examine background inverse detection Pr surfaces</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>2</span>, <span class='fl'>3</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/base/lapply.html'>lapply</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>bkg_inv_surface_by_design</span>, <span class='kw'>function</span><span class='op'>(</span><span class='va'>bkg</span><span class='op'>)</span> <span class='op'>{</span>
  <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>bkg</span>, axes <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
  <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/box.html'>box</a></span><span class='op'>(</span><span class='op'>)</span>
<span class='op'>}</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [[1]]
#&gt; NULL
#&gt; 
#&gt; [[2]]
#&gt; NULL
#&gt; 
#&gt; [[3]]
#&gt; NULL
#&gt; 
#&gt; [[4]]
#&gt; NULL
#&gt; 
#&gt; [[5]]
#&gt; NULL
#&gt; </div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-6.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'>#### Example (2): Incorporate spatial information (coastline, area boundaries)</span>

<span class='co'># Define spatial mask for the land and check this via a plot</span>
<span class='va'>sea</span> <span class='op'>&lt;-</span> <span class='fu'><a href='invert_poly.html'>invert_poly</a></span><span class='op'>(</span><span class='va'>dat_coast</span><span class='op'>)</span>
<span class='va'>area</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/setValues.html'>setValues</a></span><span class='op'>(</span><span class='va'>map_blank</span>, <span class='fl'>1</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/mask.html'>mask</a></span><span class='op'>(</span><span class='va'>area</span>, <span class='va'>sea</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-7.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'># Implement algorithm</span>
<span class='va'>kernels</span> <span class='op'>&lt;-</span> <span class='fu'>acs_setup_detection_kernels</span><span class='op'>(</span>xy <span class='op'>=</span> <span class='va'>xy</span>,
                                        centroids <span class='op'>=</span> <span class='va'>dat_centroids</span>,
                                        overlaps <span class='op'>=</span> <span class='va'>overlaps</span>,
                                        calc_detection_pr <span class='op'>=</span> <span class='va'>calc_dpr</span>,
                                        map <span class='op'>=</span> <span class='va'>map_blank</span>,
                                        coastline <span class='op'>=</span> <span class='va'>sea</span>,
                                        boundaries <span class='op'>=</span> <span class='fu'><a href='update_extent.html'>update_extent</a></span><span class='op'>(</span><span class='va'>map_blank</span>, <span class='op'>-</span><span class='fl'>1000</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::acs_setup_detection_kernels() called (@ 2021-12-02 14:35:56)... 
#&gt; ... Setting up function... 
#&gt; ... Getting receiver-specific kernels (for detection)... 
#&gt; 
#&gt; ... ... For receiver 3 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; 
#&gt; ... ... For receiver 4 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; 
#&gt; ... ... For receiver 7 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; 
#&gt; ... ... For receiver 9 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; 
#&gt; ... ... For receiver 11 ... 
#&gt; ... ... ... Isolating detection centroid ... 
#&gt; ... ... ... Calculating distances from the receiver ... 
#&gt; ... ... ... Calculating detection probability ... 
#&gt; ... ... ... Processing kernel ... 
#&gt; ... Getting receiver-specific inverse kernels... 
#&gt; ... Getting area-wide kernels (for non-detection)... 
#&gt; ... ... Get unique array designs... 
#&gt; ... ... Get area wide kernels for each array design... 
#&gt; 
#&gt; ... ... ... For design 1/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; 
#&gt; ... ... ... For design 2/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; 
#&gt; ... ... ... For design 3/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; 
#&gt; ... ... ... For design 4/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; 
#&gt; ... ... ... For design 5/5... 
#&gt; ... ... ... ... Extract detection probability kernels for active receivers... 
#&gt; ... ... ... ... Combining detection kernels to calculate the background detection probability surfaces (this is a slow step)... 
#&gt; ... Process detection probability kernels ... 
#&gt; ... flapper::acs_setup_detection_kernels() call completed (@ 2021-12-02 14:35:58) after ~0.03 minutes. </div><div class='input'>
<span class='co'># Examine example receiver-specific kernels</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>receiver_specific_kernels</span><span class='op'>[[</span><span class='fl'>3</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span><span class='op'>(</span><span class='va'>xy</span><span class='op'>[</span><span class='va'>xy</span><span class='op'>$</span><span class='va'>receiver_id</span> <span class='op'>==</span> <span class='fl'>3</span>, <span class='op'>]</span>, cex <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>receiver_specific_kernels</span><span class='op'>[[</span><span class='fl'>4</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span>
</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span><span class='op'>(</span><span class='va'>xy</span><span class='op'>[</span><span class='va'>xy</span><span class='op'>$</span><span class='va'>receiver_id</span> <span class='op'>==</span> <span class='fl'>4</span>, <span class='op'>]</span>, cex <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-8.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

<span class='co'># Examine example receiver-specific inverse kernels</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>receiver_specific_inv_kernels</span><span class='op'>[[</span><span class='fl'>3</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span><span class='op'>(</span><span class='va'>xy</span><span class='op'>[</span><span class='va'>xy</span><span class='op'>$</span><span class='va'>receiver_id</span> <span class='op'>==</span> <span class='fl'>3</span>, <span class='op'>]</span>, cex <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>receiver_specific_inv_kernels</span><span class='op'>[[</span><span class='fl'>4</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span>
</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span><span class='op'>(</span><span class='va'>xy</span><span class='op'>[</span><span class='va'>xy</span><span class='op'>$</span><span class='va'>receiver_id</span> <span class='op'>==</span> <span class='fl'>4</span>, <span class='op'>]</span>, cex <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-9.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

<span class='co'># Examine background detection Pr surfaces</span>
<span class='co'># ... (for each unique combination of receivers that were deployed)</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>2</span>, <span class='fl'>3</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/base/lapply.html'>lapply</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>bkg_surface_by_design</span>, <span class='kw'>function</span><span class='op'>(</span><span class='va'>bkg</span><span class='op'>)</span> <span class='op'>{</span>
  <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>bkg</span>, axes <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
  <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/box.html'>box</a></span><span class='op'>(</span><span class='op'>)</span>
<span class='op'>}</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [[1]]
#&gt; NULL
#&gt; 
#&gt; [[2]]
#&gt; NULL
#&gt; 
#&gt; [[3]]
#&gt; NULL
#&gt; 
#&gt; [[4]]
#&gt; NULL
#&gt; 
#&gt; [[5]]
#&gt; NULL
#&gt; </div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-10.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'># Examine background inverse detection Pr surfaces</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>2</span>, <span class='fl'>3</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/base/lapply.html'>lapply</a></span><span class='op'>(</span><span class='va'>kernels</span><span class='op'>$</span><span class='va'>bkg_inv_surface_by_design</span>, <span class='kw'>function</span><span class='op'>(</span><span class='va'>bkg</span><span class='op'>)</span> <span class='op'>{</span>
  <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>bkg</span>, axes <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
  <span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/box.html'>box</a></span><span class='op'>(</span><span class='op'>)</span>
<span class='op'>}</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [[1]]
#&gt; NULL
#&gt; 
#&gt; [[2]]
#&gt; NULL
#&gt; 
#&gt; [[3]]
#&gt; NULL
#&gt; 
#&gt; [[4]]
#&gt; NULL
#&gt; 
#&gt; [[5]]
#&gt; NULL
#&gt; </div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>
</div><div class='img'><img src='acs_setup_detection_kernels-11.png' alt='' width='700' height='433' /></div><div class='input'>
</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Edward Lavender.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


