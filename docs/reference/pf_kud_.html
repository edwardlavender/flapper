<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>(Experimental) Alternative kernel smoothing routines for particles or paths from a PF algorithm — pf_kud_ • flapper</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="(Experimental) Alternative kernel smoothing routines for particles or paths from a PF algorithm — pf_kud_" />
<meta property="og:description" content="These functions are wrappers designed to apply kernel utilisation distribution (KUD) estimation to the outputs of a particle filtering (PF) algorithm. To implement these routines, an (a) pf_archive-class object from pf (plus pf_simplify with the return = &quot;archive&quot; argument) containing particle histories for connected particles or (b) a pf_path-class object containing reconstructed paths must be supplied. Depending on the implementation, using a subset, all or an expanded sample of sampled locations, the functions apply KUD smoother(s) via a user-supplied estimation routine (i.e., kernelUD or kud_around_coastline). The functions extract the utilisation distribution(s) as raster(s), combine distribution(s) (if necessary), apply a spatial mask (e.g. coastline), plot the processed distribution (if specified) and return this as a raster." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flapper</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/flapper.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/edwardlavender/flapper/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>(Experimental) Alternative kernel smoothing routines for particles or paths from a PF algorithm</h1>
    <small class="dont-index">Source: <a href='https://github.com/edwardlavender/flapper/blob/master/R/pf_analyse_either.R'><code>R/pf_analyse_either.R</code></a></small>
    <div class="hidden name"><code>pf_kud_.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>These functions are wrappers designed to apply kernel utilisation distribution (KUD) estimation to the outputs of a particle filtering (PF) algorithm. To implement these routines, an (a) <code><a href='pf_archive-class.html'>pf_archive-class</a></code> object from <code><a href='pf.html'>pf</a></code> (plus <code><a href='pf_simplify.html'>pf_simplify</a></code> with the <code>return = "archive"</code> argument) containing particle histories for connected particles or (b) a <code><a href='pf_path-class.html'>pf_path-class</a></code> object containing reconstructed paths must be supplied. Depending on the implementation, using a subset, all or an expanded sample of sampled locations, the functions apply KUD smoother(s) via a user-supplied estimation routine (i.e., <code><a href='https://rdrr.io/pkg/adehabitatHR/man/kernelUD.html'>kernelUD</a></code> or <code><a href='kud_around_coastline.html'>kud_around_coastline</a></code>). The functions extract the utilisation distribution(s) as <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>(s), combine distribution(s) (if necessary), apply a spatial mask (e.g. coastline), plot the processed distribution (if specified) and return this as a <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>.</p>
    </div>

    <pre class="usage"><span class='fu'>pf_kud_1</span><span class='op'>(</span>
  <span class='va'>xpf</span>,
  <span class='va'>bathy</span>,
  sample_size <span class='op'>=</span> <span class='cn'>NULL</span>,
  estimate_ud <span class='op'>=</span> <span class='fu'>adehabitatHR</span><span class='fu'>::</span><span class='va'><a href='https://rdrr.io/pkg/adehabitatHR/man/kernelUD.html'>kernelUD</a></span>,
  <span class='va'>grid</span>,
  <span class='va'>...</span>,
  scale <span class='op'>=</span> <span class='cn'>FALSE</span>,
  plot_by_time <span class='op'>=</span> <span class='cn'>FALSE</span>,
  prompt <span class='op'>=</span> <span class='cn'>TRUE</span>,
  chunks <span class='op'>=</span> <span class='fl'>1L</span>,
  cl <span class='op'>=</span> <span class='cn'>NULL</span>,
  varlist <span class='op'>=</span> <span class='cn'>NULL</span>,
  mask <span class='op'>=</span> <span class='cn'>NULL</span>,
  plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
  verbose <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span>

<span class='fu'>pf_kud_2</span><span class='op'>(</span>
  <span class='va'>xpf</span>,
  <span class='va'>bathy</span>,
  sample_size <span class='op'>=</span> <span class='cn'>NULL</span>,
  estimate_ud <span class='op'>=</span> <span class='fu'>adehabitatHR</span><span class='fu'>::</span><span class='va'><a href='https://rdrr.io/pkg/adehabitatHR/man/kernelUD.html'>kernelUD</a></span>,
  <span class='va'>grid</span>,
  <span class='va'>...</span>,
  mask <span class='op'>=</span> <span class='cn'>NULL</span>,
  plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
  verbose <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>xpf</th>
      <td><p>A <code><a href='pf_archive-class.html'>pf_archive-class</a></code> object (from <code><a href='pf.html'>pf</a></code> plus <code><a href='pf_simplify.html'>pf_simplify</a></code> with <code>return = "archive"</code>) or a <code><a href='pf_path-class.html'>pf_path-class</a></code> object (from <code><a href='pf.html'>pf</a></code> plus <code><a href='pf_simplify.html'>pf_simplify</a></code> with <code>return = "path"</code>). For particle-based implementations, for <code>pf_kud_1</code>, <code><a href='pf_simplify.html'>pf_simplify</a></code> should be implemented with <code>summarise_pr = FALSE</code>; for <code>pf_kud_2</code>, <code><a href='pf_simplify.html'>pf_simplify</a></code> should be implemented with <code>summarise_pr = TRUE</code> (see Details).</p></td>
    </tr>
    <tr>
      <th>bathy</th>
      <td><p>A <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> that defines the grid across which <code><a href='pf.html'>pf</a></code> was applied. This used to extract cell coordinates and to express KUD(s).</p></td>
    </tr>
    <tr>
      <th>sample_size</th>
      <td><p>(optional) An integer that defines the number of particles to sample from (a) particle histories or (b) each path in <code>xpf</code> for KUD estimation. For <code>pf_kud_1</code>, sampling is used to account for particle uncertainty so <code>sample_size</code> should be greater than the number of particle samples at each time step (see Details). If specified, for each time step, <code>sample_size</code> particles are sampled from (a) particle histories or (b) reconstructed paths with replacement in line with their probability. For <code>pf_kud_2</code>, sampling is used to reduce memory requirements and computation time, so <code>sample_size</code> should be lower than the total number of particle samples (per path, if applicable). If specified, <code>sample_size</code> particles are sampled from (a) particle histories or (b) each path with replacement in line with their probability. If <code>sample_size = NULL</code>, all particles are used.</p></td>
    </tr>
    <tr>
      <th>estimate_ud</th>
      <td><p>A function (either <code><a href='https://rdrr.io/pkg/adehabitatHR/man/kernelUD.html'>kernelUD</a></code> or <code><a href='kud_around_coastline.html'>kud_around_coastline</a></code>) that estimates kernel utilisation distributions. For <code>pf_kud_1</code>, <code><a href='kud_around_coastline.html'>kud_around_coastline_fast</a></code> can also be used for faster estimation.</p></td>
    </tr>
    <tr>
      <th>grid, ...</th>
      <td><p>Arguments passed to <code>estimate_ud</code> (and ultimately <code><a href='https://rdrr.io/pkg/adehabitatHR/man/kernelUD.html'>kernelUD</a></code>, where they are defined) to estimate the kernel utilisation distribution. If <code><a href='kud_around_coastline.html'>kud_around_coastline</a></code> or <code><a href='kud_around_coastline.html'>kud_around_coastline_fast</a></code> is supplied to <code>estimate_ud</code>, then <code>grid</code> must be a <code><a href='https://rdrr.io/pkg/sp/man/SpatialGridDataFrame.html'>SpatialPixelsDataFrame</a></code>. However, note that in all cases, KUD(s) are resampled onto <code>bathy</code>.</p></td>
    </tr>
    <tr>
      <th>scale</th>
      <td><p>For <code>pf_kud_1</code>, <code>scale</code> is a logical input that defines whether or not to scale the KUD for each time step such that the most probable locations are assigned a score of one.</p></td>
    </tr>
    <tr>
      <th>plot_by_time, prompt</th>
      <td><p>For <code>pf_kud_1</code>, <code>plot_by_time</code> is a logical variable that defines whether or not to plot the cumulative (un-normalised) KUD for each time step. If supplied, <code>prompt</code> is a logical variable that defines whether or not to pause function execution between sequential plots. These arguments are not implemented in parallel (see <code>cl</code>, below).</p></td>
    </tr>
    <tr>
      <th>chunks, cl, varlist</th>
      <td><p>For <code>pf_kud_1</code>, <code>chunks</code>, <code>cl</code> and <code>varlist</code> are chunk-wise implementation controls. <code>chunks</code> is an integer that defines the number of chunks into which to split particle/path time series. To minimise memory requirements, within each chunk, a blank map is sequentially updated with the KUD for each time step; the cumulative KUD for each chunk is then summed across chunks to create a single KUD. This approach minimises memory use while facilitating improvements in computation time through the parallel processing of each chunk via <code>cl</code> and <code>varlist</code>. <code>cl</code> is (a) a cluster object from <code><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></code> or (b) an integer that defines the number of child processes. <code>varlist</code> is a character vector of variables for export (see <code><a href='cl.html'>cl_export</a></code>). Exported variables must be located in the global environment. If a cluster is supplied, the connection to the cluster is closed within the function (see <code><a href='cl.html'>cl_stop</a></code>). For further information, see <code><a href='cl.html'>cl_lapply</a></code> and <code><a href='flapper-tips-parallel.html'>flapper-tips-parallel</a></code>.</p></td>
    </tr>
    <tr>
      <th>mask</th>
      <td><p>(optional) A spatial mask (see <code><a href='https://rdrr.io/pkg/raster/man/mask.html'>mask</a></code>).</p></td>
    </tr>
    <tr>
      <th>plot</th>
      <td><p>A logical input that defines whether or not to plot the KUD.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>A logical input that defines whether or not to print messages to the console to monitor function progress.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The functions return a <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> of the KUD.</p>
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    
<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Methods</h3>
<p>These function create smooth KUD representations of particle or path samples from a PF algorithm (see <code><a href='pf_plot_map.html'>pf_plot_map</a></code>). Two different methods are implemented.</p>

<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method (1)</h3>
<p><code>pf_kud_1</code> implements KUD estimation by fitting a single kernel to sampled locations at each time step; time step-specific kernels are then summed and re-normalised. This method can be implemented for (a) the sampled particles that formed continuous paths from the start to the end of the time series (see <code><a href='pf_simplify.html'>pf_simplify</a></code>) or (b) reconstructed paths. The method has two main advantages. First, the kernel bandwidth is allowed to vary through time. Second, this implementation permits a Bayesian-style resampling process that can be used to account for particle uncertainty. Specifically, at each time step, large numbers of particles can be re-sampled, in line with their probability and with replacement, from the initial list of sampled particles; more probable locations are sampled more often and consequently have more influence on the KUD for each time step, thus accounting for particle probability.</p>
<p>A limitation with this method is that the fitting a KUD to each time step can be memory intensive and computationally intensive. To minimise memory requirements, by default (<code>chunks = 1L</code>), the function starts with a blank map and iterates over each time step, sequentially adding KUDs to the map at each step. By continuously updating a single map, this option minimises memory requirements but is slow. A faster option is to split the time series into chunks, implement an iterative option within each chunk, and then join maps for each chunk. The advantage of this option is that memory use remains limited while computation time can be improved by the parallel processing of each chunk. This is implemented via <code>chunks</code>, <code>cl</code> and <code>varlist</code>.</p>

<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method (2)</h3>
<p><code>pf_kud_2</code> implements KUD estimation by fitting a single kernel to all sampled locations or to each path (and then aggregating KUDs across paths). The main advantage of this method is speed: unlike <code>pf_kud_1</code>, KUDs are not fitted to the locations for each time step. The limitations are that kernel bandwidth is constant for all time steps and in most situations re-sampling cannot be used in the same way to account for particle uncertainty (due to memory limitations).</p>
<p>For particle-based implementations, this method is designed to be implemented for the subset of unique, sampled particles that formed continuous paths from the start to the end of the time series (see <code><a href='pf_simplify.html'>pf_simplify</a></code> and <code><a href='pf_plot_map.html'>pf_plot_map</a></code>). These particles are used for KUD estimation. By default, all particles are used, but \(n =\) <code>sample_size</code> particles can be sampled at random, in line with their probability, if specified, for faster KUD estimation. Selected particles are then used to estimate a KUD by effectively treating samples as `relocations', ultimately via <code><a href='https://rdrr.io/pkg/adehabitatHR/man/kernelUD.html'>kernelUD</a></code>. This distribution is then processed, plotted and returned.</p>
<p>For path-based implementations, this function is designed to be implemented for paths reconstructed by <code><a href='pf_simplify.html'>pf_simplify</a></code>. As for the particle-based implementation, for each path, all locations, or random sample of <code>sample_size</code> locations are used to estimate a KUD by treating sampled locations as `relocations'. KUDs are processed and combined across paths into a single, average KUD. The advantage of this approach is that the overall probability of the paths can be incorporated in the estimation procedure via sampling or weights when path-specific KUDs are averaged (although that is not yet implemented).</p>

    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p><code><a href='pf.html'>pf</a></code>, <code><a href='pf_simplify.html'>pf_simplify</a></code>, <code><a href='pf_plot_map.html'>pf_plot_map</a></code>, <code><a href='https://rdrr.io/pkg/adehabitatHR/man/kernelUD.html'>kernelUD</a></code>, <code><a href='kud_around_coastline.html'>kud_around_coastline</a></code>, <code><a href='kud_around_coastline.html'>kud_around_coastline_fast</a></code>, <code><a href='eval_by_kud.html'>eval_by_kud</a></code></p></div>
    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Edward Lavender</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'>#### Define particle samples for smoothing</span>
<span class='co'># To do this, we will re-implement the pf() for the example dat_dcpf_histories</span>
<span class='co'># ... dataset, but with a larger number of particles. This is necessary</span>
<span class='co'># ... because kernel smoothing is only appropriate if there are</span>
<span class='co'># ... enough locations to permit smoothing.</span>
<span class='fu'><a href='https://rdrr.io/r/base/Random.html'>set.seed</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>)</span>
<span class='va'>dcpf_args</span> <span class='op'>&lt;-</span> <span class='va'>dat_dcpf_histories</span><span class='op'>$</span><span class='va'>args</span>
<span class='va'>dcpf_args</span><span class='op'>$</span><span class='va'>calc_distance_euclid_fast</span> <span class='op'>&lt;-</span> <span class='cn'>TRUE</span>
<span class='va'>dcpf_args</span><span class='op'>$</span><span class='va'>n</span> <span class='op'>&lt;-</span> <span class='fl'>250L</span>
<span class='va'>out_dcpf_particles</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/do.call.html'>do.call</a></span><span class='op'>(</span><span class='va'>pf</span>, <span class='va'>dcpf_args</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf() called (@ 2022-06-17 10:06:53)... 
#&gt; ... Setting up function... 
#&gt; ... Determining the set of possible starting locations (t = 1)... 
#&gt; ... Implementing algorithm iteratively over time steps... 
#&gt; ... ... Time = 1... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 2... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 3... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 4... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 5... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 6... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 7... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 8... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 9... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 10... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 11... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 12... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 13... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 14... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 15... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 16... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 17... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 18... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... flapper::pf() call completed (@ 2022-06-17 10:07:02) after ~0.16 minutes. </div><div class='input'>
<span class='co'>#### Process particles and paths</span>
<span class='va'>out_dcpf_particles_1</span> <span class='op'>&lt;-</span>
  <span class='fu'><a href='pf_simplify.html'>pf_simplify</a></span><span class='op'>(</span><span class='va'>out_dcpf_particles</span>, return <span class='op'>=</span> <span class='st'>"archive"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_simplify() called (@ 2022-06-17 10:07:02)... 
#&gt; ... Getting pairwise cell movements based on calc_distance = 'euclid'... 
#&gt; ... ... Stepping through time steps to join coordinate pairs... 
#&gt; ... ... Identifying connected cells... 
#&gt; ... ... Processing connected cells for return = 'archive'... 
#&gt; ... flapper::pf_simplify() call completed (@ 2022-06-17 10:07:02) after ~0 minutes. </div><div class='input'><span class='va'>out_dcpf_particles_2</span> <span class='op'>&lt;-</span>
  <span class='fu'><a href='pf_simplify.html'>pf_simplify</a></span><span class='op'>(</span><span class='va'>out_dcpf_particles</span>, summarise_pr <span class='op'>=</span> <span class='cn'>TRUE</span>, return <span class='op'>=</span> <span class='st'>"archive"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_simplify() called (@ 2022-06-17 10:07:02)... 
#&gt; ... Getting pairwise cell movements based on calc_distance = 'euclid'... 
#&gt; ... ... Stepping through time steps to join coordinate pairs... 
#&gt; ... ... Identifying connected cells... 
#&gt; ... ... Processing connected cells for return = 'archive'... 
#&gt; ... flapper::pf_simplify() call completed (@ 2022-06-17 10:07:03) after ~0.01 minutes. </div><div class='input'><span class='va'>out_dcpf_paths</span> <span class='op'>&lt;-</span>
  <span class='fu'><a href='pf_simplify.html'>pf_simplify</a></span><span class='op'>(</span><span class='va'>out_dcpf_particles</span>, max_n_paths <span class='op'>=</span> <span class='fl'>100L</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_simplify() called (@ 2022-06-17 10:07:03)... 
#&gt; ... Getting pairwise cell movements based on calc_distance = 'euclid'... 
#&gt; ... ... Stepping through time steps to join coordinate pairs... 
#&gt; ... ... Identifying connected cells... 
#&gt; ... Assembling paths... 
#&gt; ... Formatting paths... 
#&gt; ... Adding cell coordinates and depths... 
#&gt; ... flapper::pf_simplify() call completed (@ 2022-06-17 10:07:03) after ~0 minutes. </div><div class='input'>
<span class='co'>#### Define a grid across which to implement estimation</span>
<span class='co'># This grid takes values of 0 on land and values of 1 in the sea</span>
<span class='va'>bathy</span> <span class='op'>&lt;-</span> <span class='va'>out_dcpf_particles</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='va'>bathy</span>
<span class='va'>grid</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></span><span class='op'>(</span><span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>bathy</span><span class='op'>)</span>, nrows <span class='op'>=</span> <span class='fl'>100</span>, ncols <span class='op'>=</span> <span class='fl'>100</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/getValues.html'>values</a></span><span class='op'>(</span><span class='va'>grid</span><span class='op'>)</span> <span class='op'>&lt;-</span> <span class='fl'>0</span>
<span class='va'>grid</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/mask.html'>mask</a></span><span class='op'>(</span><span class='va'>grid</span>, <span class='va'>dat_coast</span>, updatevalue <span class='op'>=</span> <span class='fl'>1</span><span class='op'>)</span>
<span class='va'>grid</span> <span class='op'>&lt;-</span> <span class='fu'>methods</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/methods/as.html'>as</a></span><span class='op'>(</span><span class='va'>grid</span>, <span class='st'>"SpatialPixelsDataFrame"</span><span class='op'>)</span>

<span class='co'>#### Example (1): Implement pf_kud_1() using default options</span>
<span class='co'>## Implementation based on particles</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>pf_kud_1</span><span class='op'>(</span><span class='va'>out_dcpf_particles_1</span>,
         bathy <span class='op'>=</span> <span class='va'>bathy</span>,
         sample_size <span class='op'>=</span> <span class='fl'>500</span>,
         estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline_fast</span>, grid <span class='op'>=</span> <span class='va'>grid</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_1() called (@ 2022-06-17 10:07:03)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Defining chunk(s)... 
#&gt; ... Implementing KUD estimation over chunk(s)... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_1() call completed (@ 2022-06-17 10:07:05) after ~0.03 minutes. </div><div class='output co'>#&gt; class      : RasterLayer 
#&gt; dimensions : 80, 80, 6400  (nrow, ncol, ncell)
#&gt; resolution : 25, 25  (x, y)
#&gt; extent     : 707884.6, 709884.6, 6253404, 6255404  (xmin, xmax, ymin, ymax)
#&gt; crs        : NA 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 0.004891361  (min, max)
#&gt; </div><div class='input'><span class='co'>## Implementation based on paths</span>
<span class='kw'>if</span><span class='op'>(</span><span class='va'>flapper_run_parallel</span><span class='op'>)</span><span class='op'>{</span>
  <span class='fu'>pf_kud_1</span><span class='op'>(</span><span class='va'>out_dcpf_paths</span>,
           bathy <span class='op'>=</span> <span class='va'>bathy</span>,
           sample_size <span class='op'>=</span> <span class='fl'>500</span>,
           estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline_fast</span>, grid <span class='op'>=</span> <span class='va'>grid</span><span class='op'>)</span>
  <span class='fu'>prettyGraphics</span><span class='fu'>::</span><span class='fu'><a href='https://edwardlavender.github.io/prettyGraphics/reference/add_sp.html'>add_sp_path</a></span><span class='op'>(</span>x <span class='op'>=</span> <span class='va'>out_dcpf_paths</span><span class='op'>$</span><span class='va'>cell_x</span>,
                              y <span class='op'>=</span> <span class='va'>out_dcpf_paths</span><span class='op'>$</span><span class='va'>cell_y</span>,
                              length <span class='op'>=</span> <span class='fl'>0.01</span><span class='op'>)</span>
<span class='op'>}</span>
</div><div class='output co'>#&gt; flapper::pf_kud_1() called (@ 2022-06-17 10:07:05)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Defining chunk(s)... 
#&gt; ... Implementing KUD estimation over chunk(s)... </div><div class='output co'>#&gt; <span class='message'>Fewer than five unique cells for kernel estimation at time 1.</span></div><div class='output co'>#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_1() call completed (@ 2022-06-17 10:07:06) after ~0.03 minutes. </div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='img'><img src='pf_kud_-1.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

<span class='co'>#### Example (2): Implement pf_kud_2() using default options</span>
<span class='co'>## Implementation based on particles</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>pf_kud_2</span><span class='op'>(</span><span class='va'>out_dcpf_particles_2</span>,
         bathy <span class='op'>=</span> <span class='va'>bathy</span>,
         estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline</span>, grid <span class='op'>=</span> <span class='va'>grid</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_2() called (@ 2022-06-17 10:07:06)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Implementing KUD estimation... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_2() call completed (@ 2022-06-17 10:07:07) after ~0 minutes. </div><div class='output co'>#&gt; class      : RasterLayer 
#&gt; dimensions : 80, 80, 6400  (nrow, ncol, ncell)
#&gt; resolution : 25, 25  (x, y)
#&gt; extent     : 707884.6, 709884.6, 6253404, 6255404  (xmin, xmax, ymin, ymax)
#&gt; crs        : NA 
#&gt; source     : memory
#&gt; names      : ud 
#&gt; values     : 0, 0.00101676  (min, max)
#&gt; </div><div class='input'><span class='co'>## Implementation based on paths</span>
<span class='fu'>pf_kud_2</span><span class='op'>(</span><span class='va'>out_dcpf_paths</span>,
         bathy <span class='op'>=</span> <span class='va'>bathy</span>,
         estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline</span>, grid <span class='op'>=</span> <span class='va'>grid</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_2() called (@ 2022-06-17 10:07:07)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Implementing KUD estimation... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_2() call completed (@ 2022-06-17 10:07:14) after ~0.12 minutes. </div><div class='output co'>#&gt; class      : RasterLayer 
#&gt; dimensions : 80, 80, 6400  (nrow, ncol, ncell)
#&gt; resolution : 25, 25  (x, y)
#&gt; extent     : 707884.6, 709884.6, 6253404, 6255404  (xmin, xmax, ymin, ymax)
#&gt; crs        : NA 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 0.0009396509  (min, max)
#&gt; </div><div class='input'><span class='fu'>prettyGraphics</span><span class='fu'>::</span><span class='fu'><a href='https://edwardlavender.github.io/prettyGraphics/reference/add_sp.html'>add_sp_path</a></span><span class='op'>(</span>x <span class='op'>=</span> <span class='va'>out_dcpf_paths</span><span class='op'>$</span><span class='va'>cell_x</span>, y <span class='op'>=</span> <span class='va'>out_dcpf_paths</span><span class='op'>$</span><span class='va'>cell_y</span>,
                            length <span class='op'>=</span> <span class='fl'>0.01</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='output co'>#&gt; <span class='warning'>Warning: zero-length arrow is of indeterminate angle and so skipped</span></div><div class='img'><img src='pf_kud_-2.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

<span class='co'>#### Example (3): For improved speed with pf_kud_1(), use parallelisation</span>
<span class='co'>## Implementation based on particles</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>pf_kud_1</span><span class='op'>(</span><span class='va'>out_dcpf_particles_1</span>,
         bathy <span class='op'>=</span> <span class='va'>bathy</span>,
         sample_size <span class='op'>=</span> <span class='fl'>500</span>,
         estimate_ud <span class='op'>=</span> <span class='fu'>flapper</span><span class='fu'>::</span><span class='va'><a href='kud_around_coastline.html'>kud_around_coastline_fast</a></span>, grid <span class='op'>=</span> <span class='va'>grid</span>,
         chunks <span class='op'>=</span> <span class='fl'>2L</span>,
         cl <span class='op'>=</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_1() called (@ 2022-06-17 10:07:14)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Defining chunk(s)... 
#&gt; ... Implementing KUD estimation over chunk(s)... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_1() call completed (@ 2022-06-17 10:07:20) after ~0.1 minutes. </div><div class='output co'>#&gt; class      : RasterLayer 
#&gt; dimensions : 80, 80, 6400  (nrow, ncol, ncell)
#&gt; resolution : 25, 25  (x, y)
#&gt; extent     : 707884.6, 709884.6, 6253404, 6255404  (xmin, xmax, ymin, ymax)
#&gt; crs        : NA 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 0.004982855  (min, max)
#&gt; </div><div class='input'><span class='co'>## Implementation based on paths</span>
<span class='kw'>if</span><span class='op'>(</span><span class='va'>flapper_run_parallel</span><span class='op'>)</span><span class='op'>{</span>
  <span class='va'>cl</span> <span class='op'>&lt;-</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span>
  <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/clusterApply.html'>clusterEvalQ</a></span><span class='op'>(</span>cl <span class='op'>=</span> <span class='va'>cl</span>, <span class='kw'><a href='https://rdrr.io/r/base/library.html'>library</a></span><span class='op'>(</span><span class='va'><a href='https://rspatial.org/raster'>raster</a></span><span class='op'>)</span><span class='op'>)</span>
  <span class='fu'>pf_kud_1</span><span class='op'>(</span><span class='va'>out_dcpf_paths</span>,
           bathy <span class='op'>=</span> <span class='va'>bathy</span>,
           sample_size <span class='op'>=</span> <span class='fl'>500</span>,
           estimate_ud <span class='op'>=</span> <span class='fu'>flapper</span><span class='fu'>::</span><span class='va'><a href='kud_around_coastline.html'>kud_around_coastline_fast</a></span>, grid <span class='op'>=</span> <span class='va'>grid</span>,
           chunks <span class='op'>=</span> <span class='fl'>2L</span>,
           cl <span class='op'>=</span> <span class='va'>cl</span><span class='op'>)</span>
<span class='op'>}</span>
</div><div class='output co'>#&gt; flapper::pf_kud_1() called (@ 2022-06-17 10:07:23)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Defining chunk(s)... 
#&gt; ... Implementing KUD estimation over chunk(s)... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='img'><img src='pf_kud_-3.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::pf_kud_1() call completed (@ 2022-06-17 10:07:25) after ~0.04 minutes. </div><div class='output co'>#&gt; class      : RasterLayer 
#&gt; dimensions : 80, 80, 6400  (nrow, ncol, ncell)
#&gt; resolution : 25, 25  (x, y)
#&gt; extent     : 707884.6, 709884.6, 6253404, 6255404  (xmin, xmax, ymin, ymax)
#&gt; crs        : NA 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 0.08056145  (min, max)
#&gt; </div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

<span class='co'>#### Example (4): For improved speed with pf_kud_2(), use sample_size</span>
<span class='co'>## Implementation based on particles</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>pf_kud_2</span><span class='op'>(</span><span class='va'>out_dcpf_particles_2</span>,
         bathy <span class='op'>=</span> <span class='va'>bathy</span>,
         sample_size <span class='op'>=</span> <span class='fl'>50</span>, <span class='co'># sample 50 particles overall</span>
         estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline</span>, grid <span class='op'>=</span> <span class='va'>grid</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_2() called (@ 2022-06-17 10:07:25)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Implementing KUD estimation... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_2() call completed (@ 2022-06-17 10:07:26) after ~0 minutes. </div><div class='output co'>#&gt; class      : RasterLayer 
#&gt; dimensions : 80, 80, 6400  (nrow, ncol, ncell)
#&gt; resolution : 25, 25  (x, y)
#&gt; extent     : 707884.6, 709884.6, 6253404, 6255404  (xmin, xmax, ymin, ymax)
#&gt; crs        : NA 
#&gt; source     : memory
#&gt; names      : ud 
#&gt; values     : 0, 0.000742768  (min, max)
#&gt; </div><div class='input'><span class='co'>## Implementation based on paths</span>
<span class='fu'>pf_kud_2</span><span class='op'>(</span><span class='va'>out_dcpf_paths</span>,
         bathy <span class='op'>=</span> <span class='va'>bathy</span>,
         sample_size <span class='op'>=</span> <span class='fl'>50</span>, <span class='co'># sample 50 particles per path</span>
         estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline</span>, grid <span class='op'>=</span> <span class='va'>grid</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_2() called (@ 2022-06-17 10:07:26)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; <span class='warning'>Warning: 'sample_size' is greater than the number of particles.</span></div><div class='output co'>#&gt; ... Implementing KUD estimation... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='img'><img src='pf_kud_-4.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::pf_kud_2() call completed (@ 2022-06-17 10:07:33) after ~0.13 minutes. </div><div class='output co'>#&gt; class      : RasterLayer 
#&gt; dimensions : 80, 80, 6400  (nrow, ncol, ncell)
#&gt; resolution : 25, 25  (x, y)
#&gt; extent     : 707884.6, 709884.6, 6253404, 6255404  (xmin, xmax, ymin, ymax)
#&gt; crs        : NA 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 0.02832776  (min, max)
#&gt; </div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

<span class='co'>#### Example (5): Compare pf_kud_1() and pf_kud_2()</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>2</span>, <span class='fl'>2</span><span class='op'>)</span>, mar <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span>, <span class='fl'>3</span><span class='op'>)</span><span class='op'>)</span>
<span class='va'>kud_1a</span> <span class='op'>&lt;-</span> <span class='fu'>pf_kud_1</span><span class='op'>(</span>xpf <span class='op'>=</span> <span class='va'>out_dcpf_particles_1</span>,
                   bathy <span class='op'>=</span> <span class='va'>out_dcpf_particles</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='va'>bathy</span>,
                   sample_size <span class='op'>=</span> <span class='va'>out_dcpf_particles</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='va'>n</span>,
                   estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline_fast</span>, grid <span class='op'>=</span> <span class='va'>grid</span>,
                   plot <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_1() called (@ 2022-06-17 10:07:33)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Defining chunk(s)... 
#&gt; ... Implementing KUD estimation over chunk(s)... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_1() call completed (@ 2022-06-17 10:07:35) after ~0.03 minutes. </div><div class='input'>
<span class='va'>kud_1b</span> <span class='op'>&lt;-</span> <span class='fu'>pf_kud_1</span><span class='op'>(</span>xpf <span class='op'>=</span> <span class='va'>out_dcpf_particles_1</span>,
                   bathy <span class='op'>=</span> <span class='va'>out_dcpf_particles</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='va'>bathy</span>,
                   sample_size <span class='op'>=</span> <span class='fl'>500</span>,
                   estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline_fast</span>, grid <span class='op'>=</span> <span class='va'>grid</span>,
                   plot <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_1() called (@ 2022-06-17 10:07:35)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Defining chunk(s)... 
#&gt; ... Implementing KUD estimation over chunk(s)... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_1() call completed (@ 2022-06-17 10:07:36) after ~0.03 minutes. </div><div class='input'>
<span class='va'>kud_1c</span> <span class='op'>&lt;-</span> <span class='fu'>pf_kud_1</span><span class='op'>(</span>xpf <span class='op'>=</span> <span class='va'>out_dcpf_particles_1</span>,
                   bathy <span class='op'>=</span> <span class='va'>out_dcpf_particles</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='va'>bathy</span>,
                   sample_size <span class='op'>=</span> <span class='fl'>5000</span>,
                   estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline_fast</span>, grid <span class='op'>=</span> <span class='va'>grid</span>,
                   plot <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_1() called (@ 2022-06-17 10:07:36)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Defining chunk(s)... 
#&gt; ... Implementing KUD estimation over chunk(s)... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... flapper::pf_kud_1() call completed (@ 2022-06-17 10:07:40) after ~0.06 minutes. </div><div class='input'>
<span class='va'>kud_1d</span> <span class='op'>&lt;-</span> <span class='fu'>pf_kud_2</span><span class='op'>(</span>xpf <span class='op'>=</span> <span class='va'>out_dcpf_particles_2</span>,
                 bathy <span class='op'>=</span> <span class='va'>out_dcpf_particles</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='va'>bathy</span>,
                 estimate_ud <span class='op'>=</span> <span class='va'>kud_around_coastline</span>, grid <span class='op'>=</span> <span class='va'>grid</span>,
                 plot <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_kud_2() called (@ 2022-06-17 10:07:40)... 
#&gt; ... Setting up function... </div><div class='output co'>#&gt; <span class='message'>CRS taken as: 'NA'.</span></div><div class='output co'>#&gt; ... Processing sampled locations... 
#&gt; ... Implementing KUD estimation... 
#&gt; ... Processing KUD(s)... 
#&gt; ... Plotting KUD... </div><div class='output co'>#&gt; <span class='message'>prettyGraphics::pretty_map() CRS taken as: 'NA'.</span></div><div class='img'><img src='pf_kud_-5.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::pf_kud_2() call completed (@ 2022-06-17 10:07:40) after ~0 minutes. </div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>

</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Edward Lavender.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


