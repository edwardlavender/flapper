<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The acoustic-container (AC) algorithm — ac • flapper</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="The acoustic-container (AC) algorithm — ac" />
<meta property="og:description" content="This function implements the acoustic-container (AC) algorithm. To implement the function, a dataframe (or list) of passive acoustic telemetry detections is required (acoustics). At each time step, the algorithm integrates information from past and future acoustic detections in the form of acoustic containers to determine the possible locations of an individual in an area (see Details).
Under the default options, the approach is implemented step-wise (i.e., step-by-step across the whole time series). The result is a named list of outputs, including a record of the results for each time step, as well as a cumulative map of the expected proportion of time spent in each part of the study area across the whole time series. Alternatively, the approach can be implemented chunk-wise, in which case the acoustic time series is split into chunks (e.g., hourly, daily, monthly segments) and the algorithm is implemented within each chunk step-by-step. The main benefits of this approach are that it can be used to reconstruct putative patterns in space use over biologically meaningful periods separately and/or the chunk-wise implementation can be parallelised, improving computation time. (Chunk-wise results results are easily combined across the duration of the original time series without the loss of information via acdc_simplify.). This option is implemented if (a) a list, rather than a dataframe, of acoustic detections is provided (via acoustics); (b) the user specifies that the time series should be split into chunks of a particular duration before the algorithm is initiated (via the split argument); and/or (c) the algorithm is implemented in parallel via cl, in which case the acoustic time series is split (if necessary) into user-defined or automatically defined chunks prior to computation. In this case, the result is a named list of outputs, as described above, but in which the results for each chunk are returned separately. If the chunks have been implemented simply to improve computation time via parallelisation, then the maps of space use for each chunk can be combined easily to generate a single, overall map of space use via acdc_simplify." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flapper</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/flapper.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/edwardlavender/flapper/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>The acoustic-container (AC) algorithm</h1>
    <small class="dont-index">Source: <a href='https://github.com/edwardlavender/flapper/blob/master/R/ac.R'><code>R/ac.R</code></a></small>
    <div class="hidden name"><code>ac.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function implements the acoustic-container (AC) algorithm. To implement the function, a dataframe (or list) of passive acoustic telemetry detections is required (<code>acoustics</code>). At each time step, the algorithm integrates information from past and future acoustic detections in the form of acoustic containers to determine the possible locations of an individual in an area (see Details).</p>
<p>Under the default options, the approach is implemented step-wise (i.e., step-by-step across the whole time series). The result is a named list of outputs, including a record of the results for each time step, as well as a cumulative map of the expected proportion of time spent in each part of the study area across the whole time series. Alternatively, the approach can be implemented chunk-wise, in which case the acoustic time series is split into chunks (e.g., hourly, daily, monthly segments) and the algorithm is implemented within each chunk step-by-step. The main benefits of this approach are that it can be used to reconstruct putative patterns in space use over biologically meaningful periods separately and/or the chunk-wise implementation can be parallelised, improving computation time. (Chunk-wise results results are easily combined across the duration of the original time series without the loss of information via <code><a href='acdc_simplify.html'>acdc_simplify</a></code>.). This option is implemented if (a) a list, rather than a dataframe, of acoustic detections is provided (via <code>acoustics</code>); (b) the user specifies that the time series should be split into chunks of a particular duration before the algorithm is initiated (via the <code>split</code> argument); and/or (c) the algorithm is implemented in parallel via <code>cl</code>, in which case the acoustic time series is split (if necessary) into user-defined or automatically defined chunks prior to computation. In this case, the result is a named list of outputs, as described above, but in which the results for each chunk are returned separately. If the chunks have been implemented simply to improve computation time via parallelisation, then the maps of space use for each chunk can be combined easily to generate a single, overall map of space use via <code><a href='acdc_simplify.html'>acdc_simplify</a></code>.</p>
    </div>

    <pre class="usage"><span class='fu'>ac</span><span class='op'>(</span>
  <span class='va'>acoustics</span>,
  <span class='va'>step</span>,
  <span class='va'>bathy</span>,
  plot_ts <span class='op'>=</span> <span class='cn'>TRUE</span>,
  <span class='va'>detection_containers</span>,
  detection_kernels <span class='op'>=</span> <span class='cn'>NULL</span>,
  detection_kernels_overlap <span class='op'>=</span> <span class='cn'>NULL</span>,
  detection_time_window <span class='op'>=</span> <span class='fl'>5</span>,
  <span class='va'>mobility</span>,
  normalise <span class='op'>=</span> <span class='cn'>TRUE</span>,
  save_record_spatial <span class='op'>=</span> <span class='fl'>1L</span>,
  write_record_spatial_for_pf <span class='op'>=</span> <span class='cn'>NULL</span>,
  save_args <span class='op'>=</span> <span class='cn'>TRUE</span>,
  verbose <span class='op'>=</span> <span class='cn'>TRUE</span>,
  con <span class='op'>=</span> <span class='st'>""</span>,
  progress <span class='op'>=</span> <span class='fl'>1L</span>,
  split <span class='op'>=</span> <span class='cn'>NULL</span>,
  cl <span class='op'>=</span> <span class='cn'>NULL</span>,
  varlist <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>acoustics</th>
      <td><p>A dataframe, or a list of dataframes, that contains passive acoustic telemetry detection time series (see <code><a href='dat_acoustics.html'>dat_acoustics</a></code> for an example) for a single individual. Each dataframe should contain the following columns: an integer vector of receiver IDs, named `receiver_id'; an integer vector of detection indices, named `index'; and a POSIXct vector of time stamps when detections were made, named `timestamp'. If a list of dataframes is supplied, dataframes must be refer to the detections of a single individual and be ordered by time (e.g., in hourly chunks). In addition, sequential list elements must be linked by identical receiver pairs (i.e., the final receiver at which the individual was detected for any given chunk must be the same as the receiver at which the individual was next detected at the start of the next chunk) because it is only in this specific scenario that information does not need to be shared across time steps (see <code>split</code>). The algorithm will be implemented on each dataframe, termed `chunk', either in sequence or parallel. Any empty or <code>NULL</code> elements will be removed automatically.</p></td>
    </tr>
    <tr>
      <th>step</th>
      <td><p>A number that defines the time step length (s). The time series is rounded to the nearest <code>step</code> to ensure alignment (see Details). `Duplicate' detections (of the same individual at the same receiver in the same step) are dropped.</p></td>
    </tr>
    <tr>
      <th>bathy</th>
      <td><p>A <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> that defines a grid across the area within which the individual could have moved. The coordinate reference system should be the Universal Transverse Mercator system, with distances in metres (see also <code><a href='acs_setup_containers.html'>acs_setup_containers</a></code>).</p></td>
    </tr>
    <tr>
      <th>plot_ts</th>
      <td><p>A logical input that defines whether or not to the plot detection  time series before the algorithm is initiated.</p></td>
    </tr>
    <tr>
      <th>detection_containers</th>
      <td><p>A list of detection containers, with one element for each number from <code>1:max(acoustics$receiver_id)</code>, from <code><a href='acs_setup_containers.html'>acs_setup_containers</a></code>.</p></td>
    </tr>
    <tr>
      <th>detection_kernels</th>
      <td><p>A named list of detection probability kernels, from <code><a href='acs_setup_detection_kernels.html'>acs_setup_detection_kernels</a></code> and created using consistent parameters as specified for other <code>acs_setup_*</code> functions and here (i.e., see the <code>overlaps</code>, <code>calc_detection_pr</code> and <code>map</code> arguments in <code><a href='acs_setup_detection_kernels.html'>acs_setup_detection_kernels</a></code>).</p></td>
    </tr>
    <tr>
      <th>detection_kernels_overlap</th>
      <td><p>(optional) A named list, from <code><a href='get_detection_containers_overlap.html'>get_detection_containers_overlap</a></code>, that defines, for each receiver, for each day over its deployment period, whether or not its detection container overlapped with those of other receivers. If <code>detection_kernels_overlap</code> and <code>detection_time_window</code> (below) are supplied, the implementation of detection probability kernels when a detection is made accounts for overlaps in receivers' detection containers; if unsupplied, receiver detection probability kernels are assumed not to overlap.</p></td>
    </tr>
    <tr>
      <th>detection_time_window</th>
      <td><p>(optional) A number that defines the maximum duration (s) between consecutive detections at different receivers such that they can be said to have occurred at `effectively the same time'. This indicates that the same transmission was detected by multiple receivers. If <code>detection_kernels_overlap</code> (above) and <code>detection_time_window</code> are supplied, the implementation of detection probability kernels when a detection is made accounts for overlaps in receivers' detection containers, by up-weighting overlapping areas between receivers that detected the transmission and down-weighting overlapping areas between receivers that did not detect the transmission (see Details in <code><a href='acs_setup_detection_kernels.html'>acs_setup_detection_kernels</a></code>). Note that the timing of detections is affected by <code>step</code> (see Details).</p></td>
    </tr>
    <tr>
      <th>mobility</th>
      <td><p>A number that defines the (Euclidean) distance (m) that an individual could move in the time steps between sequential detections (see also <code><a href='acs_setup_containers.html'>acs_setup_containers</a></code>).</p></td>
    </tr>
    <tr>
      <th>normalise</th>
      <td><p>A logical variable that defines whether or not to normalise the map of possible locations at each time step. (The cumulative surface can be normalised via <code><a href='acdc_simplify.html'>acdc_simplify</a></code>).</p></td>
    </tr>
    <tr>
      <th>save_record_spatial</th>
      <td><p>An integer vector that defines the time steps for which to save a record of the spatial information from each time step. <code>save_record_spatial = 0L</code> suppresses the return of this information and <code>save_record_spatial = NULL</code> returns this information for all time steps. If the algorithm is applied chunk-wise, this spatial information must be returned for at least the first time step (the default) to aggregate maps across chunks (see <code><a href='acdc_simplify.html'>acdc_simplify</a></code>). This information can also be used to plot time-specific results of the algorithm using <code><a href='acdc_plot_trace.html'>acdc_plot_trace</a></code>, <code><a href='acdc_plot_record.html'>acdc_plot_record</a></code> and <code><a href='acdc_animate_record.html'>acdc_animate_record</a></code>.</p></td>
    </tr>
    <tr>
      <th>write_record_spatial_for_pf</th>
      <td><p>(optional) A named list, passed to <code><a href='https://rdrr.io/pkg/raster/man/writeRaster.html'>writeRaster</a></code>, to save the <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> of the individual's possible positions at each time step to file. The `filename' argument should be the directory in which to save files. Files are named by acoustic and intermediate (archival) time steps. For example, the file for the first acoustic time step and the first archival time step is named acc_1_arc_1.</p></td>
    </tr>
    <tr>
      <th>save_args</th>
      <td><p>A logical input that defines whether or not to save the list of function inputs in the returned object.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>A logical variable that defines whether or not to print messages to the console or to file to relay function progress. If <code>con = ""</code>, messages are printed to the console (which is only supported if the algorithm is not implemented in parallel: see below); otherwise, they are written to file (see below).</p></td>
    </tr>
    <tr>
      <th>con</th>
      <td><p>If <code>verbose = TRUE</code>, <code>con</code> is character string that defines how messages relaying function progress are returned. If <code>con = ""</code>, messages are printed to the console (unless redirected by <code><a href='https://rdrr.io/r/base/sink.html'>sink</a></code>), an approach that is only implemented if the function is not implemented in parallel. Otherwise, <code>con</code> defines the directory into which to write .txt files, into which messages are written to relay function progress. This approach, rather than printing to the console, is recommended for clarity, speed and debugging. If the algorithm is implemented step-wise, then a single file is written to the specified directory named acdc_log.txt. If the algorithm is implemented chunk-wise, then an additional file is written for each chunk (named dot_acdc_log_1.txt, dot_acdc_log_2.txt and so on), with the details for each chunk.</p></td>
    </tr>
    <tr>
      <th>progress</th>
      <td><p>(optional) If the algorithm is implemented step-wise, <code>progress</code> is an integer (<code>1</code>, <code>2</code> or <code>3</code>) that defines whether or not to display a progress bar in the console as the algorithm moves over acoustic time steps (<code>1</code>), the archival time steps between each pair of acoustic detections (<code>2</code>) or both acoustic and archival time steps (<code>3</code>), in which case the overall acoustic progress bar is punctuated by an archival progress bar for each pair of acoustic detections. This option is useful if there is a large number of archival observations between acoustic detections. Any other input will suppress the progress bar. If the algorithm is implemented for chunks, inputs to <code>progress</code> are ignored and a single progress bar is shown of the progress across acoustic chunks.</p></td>
    </tr>
    <tr>
      <th>split</th>
      <td><p>A character string that defines the (approximate) time unit used to split acoustic time series into chunks (e.g., <code>"12 hours"</code>). If provided, this must be supported by <code><a href='https://rdrr.io/r/base/cut.POSIXt.html'>cut.POSIXt</a></code> (otherwise, a pre-defined list of acoustic time series can be passed to <code>acoustics</code>, e.g., specifying seasonal chunks). If <code>split = NULL</code> and a cluster has been specified (see <code>cl</code>) (and <code>acoustics</code> is a dataframe), then the acoustic time series is automatically split into chunks and the algorithm implemented for each chunk in parallel. In all cases, splitting is subject to the constraint that  chunks must join at identical receiver pairs (i.e., the last receiver at which the individual was detected on one chunk must match the first receiver at which the individual was next detected at the start of the next chunk): in these specific scenarios, information does not need to transfer from one time step to the next.</p></td>
    </tr>
    <tr>
      <th>cl, varlist</th>
      <td><p>(optional) Parallelisation options. <code>cl</code> is (a) a cluster object from <code><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></code> or (b) an integer that defines the number of child processes to implement the algorithm in parallel. If supplied, the algorithm is implemented for each chunk in a list of acoustic time series, either (a) as supplied by the user (if <code>acoustics</code> is a list), (b) as defined by the input to <code>split</code>, or (c) as defined automatically from the number of nodes in the cluster if <code>split = NULL</code>. If <code>cl</code> is supplied, <code>varlist</code> may also be required. This is a character vector of objects to export (see <code><a href='cl.html'>cl_export</a></code>). Exported variables must be located in the global environment. If a cluster is supplied, the connection to the cluster is closed within the function (see <code><a href='cl.html'>cl_stop</a></code>). For further information, see <code><a href='cl.html'>cl_lapply</a></code> and <code><a href='flapper-tips-parallel.html'>flapper-tips-parallel</a></code>.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The function returns an <code><a href='acdc_archive-class.html'>acdc_archive-class</a></code> object. If a connection to write files has also been specified, an overall log (acdc_log.txt) as well as chunk-specific logs from calls to <code><a href='.acs.html'>.acs</a></code>, if applicable, are written to file.</p>
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>The acoustic-container (AC) algorithm is an approach which uses acoustic detections to infer the possible locations of tagged animals within an area over some time interval. The locational information provided by acoustic detections is represented by acoustic containers, which are areas around receivers that define where an individual could have been at each time point given the spatiotemporal pattern of detections at receivers, a model of detection probability and a movement parameter.</p>
<p>In outline, the crux of the approach is the recognition that acoustic detections typically occur irregularly, but we can consider a sequence of regular time steps between any pair of detections. Each detection anchors our knowledge of the location of an individual around a particular receiver (assuming that all detections are true detections). As time passes between pairs of detections, our uncertainty in the geographical location of an individual expands around the receiver at which the individual was detected before shrinking towards the receiver at which it was next detected. The dynamics of this process are captured by the expansion, contraction and intersection of pairs of acoustic containers.</p>
<p>More specifically, at each time step, we can consider the set of possible locations for the individual from perspective of (a) the receiver at which the individual was detected and (b) the receiver at which the individual is next detected. When an individual is detected, it must be within some radius---say 800 m---of that receiver termed the `detection container'. From the perspective of the receiver at which the individual is next detected, the set of possible locations of the individual is wider in line with the time between detections and the movement speed of the animal. The intersection of these two areas defines the set of possible locations for the individual. (In most cases, this is simply that defined by the detection container around the first receiver.) With a more-refined model of detection probability, it may be possible to predict more precisely where the individual is likely to have been within this area. (In situations with depth data, the ACDC algorithm further restricts the set of locations by incorporating information on the animal's depth via depth contours.) Moving forward in time, we can consider a number of regular time steps before the next detection. During this time, from the perspective of the receiver at which the individual was detected, the set of possible locations of the individual expands, because it could have moved further away from the receiver; meanwhile, from the perspective of the receiver at which the individual was next detected, the set of possible locations of the individual shrinks, as the individual must have been located within the detection container of that receiver by the time of the detection. This process is described by the expansion and contraction of `acoustic containers'. At each time step, the intersection of the two containers defines the set of possible locations of the individual, possibly weighted by a detection probability (given the lack of detections during this time). These dynamics recognise that as time passes between detections the individual could have moved away from the receiver at which it was last detected but only at a rate and in a direction that fits with the receiver at which the individual was next detected. Thus, when the individual is detected again, our uncertainty about where it could have been collapses to the detection container around the next receiver (and its intersection with the individual's previous (expanded) location and the acoustic container around the following receiver), possibly weighted by a model of detection probability. Throughout this process, the rate of change in container size depends a movement parameter that describes the maximum swimming speed.</p>
<p>This discussion assumes that the timing of detections and intermediate time steps between detections are perfectly aligned. In reality, there is likely to be a mismatch between the timing of detections and the intermediate time steps between detections, which may be poorly approximated the constant expansion and contraction of acoustic containers. The simplest solution to this issue is to round the acoustic time steps to the resolution of the intermediate time steps (specified by <code>step</code>). This results in a small loss of precision, but assuming that <code>step</code> is relatively small, the effect should be negligible. In any case, clocks on different receivers are unlikely to be perfectly synced throughout a study. This solution is also computationally preferable to an alternative approach in which the expansion and contraction of containers varies through time, depending on the gaps between observations and other time-specific variables such as behavioural state. However, the latter approach may be implemented in due course.</p>
<p>The end result is a map that shows the expected time spent in different parts of a study area. The main limitation of this approach is the simple treatment of movement, but particle filtering can be used to extent this approach via the incorporate a movement model (see <code><a href='pf.html'>pf</a></code>).</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p>This function calls <code><a href='.acs_pl.html'>.acs_pl</a></code> and <code><a href='.acs.html'>.acs</a></code> to implement the AC algorithm. <code><a href='acs_setup_containers.html'>acs_setup_containers</a></code> defines the detection containers required by this function. <code><a href='acs_setup_mobility.html'>acs_setup_mobility</a></code> is used to examine the assumption of the constant `mobility' parameter. <code><a href='acs_setup_detection_kernels.html'>acs_setup_detection_kernels</a></code> produces detection probability kernels for incorporation into the function. <code><a href='acdc_simplify.html'>acdc_simplify</a></code> simplifies the outputs and <code><a href='acdc_plot_trace.html'>acdc_plot_trace</a></code>, <code><a href='acdc_plot_record.html'>acdc_plot_record</a></code> and <code><a href='acdc_animate_record.html'>acdc_animate_record</a></code> visualise the results. The AC algorithm can be extended to incorporate depth contours via <code><a href='acdc.html'>acdc</a></code>. Particle filtering can be used to reconstruct movement path via <code><a href='pf.html'>pf</a></code>.</p></div>
    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Edward Lavender</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'>#### Step (1) Implement setup_acdc_*() steps</span>
<span class='co'># ... Define detection containers required for AC algorithm (see setup_acdc_containers())</span>

<span class='co'>#### Step (2) Prepare movement time series for algorithm</span>
<span class='co'># Focus on an example individual for speed</span>
<span class='va'>id</span> <span class='op'>&lt;-</span> <span class='fl'>25</span>
<span class='va'>acc</span> <span class='op'>&lt;-</span> <span class='va'>dat_acoustics</span><span class='op'>[</span><span class='va'>dat_acoustics</span><span class='op'>$</span><span class='va'>individual_id</span> <span class='op'>==</span> <span class='va'>id</span>, <span class='op'>]</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>25</span>, <span class='op'>]</span>
<span class='co'># Process time series (if necessary)</span>
<span class='co'># ... Observations should be processed to the nearest time step</span>
<span class='co'># ... Duplicate detections should be dropped</span>

<span class='co'>#### Example (1) Implement AC algorithm with default arguments</span>
<span class='co'># This implements the algorithm on a single core, printing messages</span>
<span class='co'># ... to the console to monitor function progress.</span>
<span class='va'>out_ac</span> <span class='op'>&lt;-</span> <span class='fu'>ac</span><span class='op'>(</span>acoustics <span class='op'>=</span> <span class='va'>acc</span>,
             step <span class='op'>=</span> <span class='fl'>120</span>,
             bathy <span class='op'>=</span> <span class='va'>dat_gebco</span>,
             detection_containers <span class='op'>=</span> <span class='va'>dat_containers</span>,
             mobility <span class='op'>=</span> <span class='fl'>200</span>
             <span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>flapper::ac() called (@ 2022-06-17 09:52:33)...</span></div><div class='output co'>#&gt; flapper::.acs_pl() called (@ 2022-06-17 09:52:33)... 
#&gt; ... Checking user inputs... 
#&gt; ... Processing movement time series... 
#&gt; ... Plotting movement time series (for each chunk)... </div><div class='output co'>#&gt; ... Calling .acs() to implement ACDC algorithm on one chunk... 
#&gt; flapper::.acs() called (@ 2022-06-17 09:52:36)... 
#&gt;   |                                                                              |                                                                      |   0%... Initiating algorithm: moving over acoustic and internal ('archival') time steps... 
#&gt; ... On acoustic time step ('timestep_detection') 1. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |===                                                                   |   4%... On acoustic time step ('timestep_detection') 2. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |======                                                                |   8%... On acoustic time step ('timestep_detection') 3. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt; ... ... On internal time step ('timestep_archival') 2. 
#&gt; ... ... ... Acoustic container is expanding... 
#&gt;   |                                                                              |=========                                                             |  12%... On acoustic time step ('timestep_detection') 4. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |============                                                          |  17%... On acoustic time step ('timestep_detection') 5. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt; ... ... On internal time step ('timestep_archival') 2. 
#&gt; ... ... ... Acoustic container is expanding... 
#&gt;   |                                                                              |===============                                                       |  21%... On acoustic time step ('timestep_detection') 6. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |==================                                                    |  25%... On acoustic time step ('timestep_detection') 7. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |====================                                                  |  29%... On acoustic time step ('timestep_detection') 8. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |=======================                                               |  33%... On acoustic time step ('timestep_detection') 9. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |==========================                                            |  38%... On acoustic time step ('timestep_detection') 10. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |=============================                                         |  42%... On acoustic time step ('timestep_detection') 11. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |================================                                      |  46%... On acoustic time step ('timestep_detection') 12. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |===================================                                   |  50%... On acoustic time step ('timestep_detection') 13. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |======================================                                |  54%... On acoustic time step ('timestep_detection') 14. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |=========================================                             |  58%... On acoustic time step ('timestep_detection') 15. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |============================================                          |  62%... On acoustic time step ('timestep_detection') 16. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt; ... ... On internal time step ('timestep_archival') 2. 
#&gt; ... ... ... Acoustic container is expanding... 
#&gt; ... ... On internal time step ('timestep_archival') 3. 
#&gt; ... ... ... Acoustic container is constant ... 
#&gt;   |                                                                              |===============================================                       |  67%... On acoustic time step ('timestep_detection') 17. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |==================================================                    |  71%... On acoustic time step ('timestep_detection') 18. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt; ... ... On internal time step ('timestep_archival') 2. 
#&gt; ... ... On internal time step ('timestep_archival') 3. 
#&gt; ... ... On internal time step ('timestep_archival') 4. 
#&gt; ... ... On internal time step ('timestep_archival') 5. 
#&gt; ... ... On internal time step ('timestep_archival') 6. 
#&gt; ... ... On internal time step ('timestep_archival') 7. 
#&gt; ... ... On internal time step ('timestep_archival') 8. 
#&gt; ... ... On internal time step ('timestep_archival') 9. 
#&gt; ... ... On internal time step ('timestep_archival') 10. 
#&gt;   |                                                                              |====================================================                  |  75%... On acoustic time step ('timestep_detection') 19. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |=======================================================               |  79%... On acoustic time step ('timestep_detection') 20. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |==========================================================            |  83%... On acoustic time step ('timestep_detection') 21. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |=============================================================         |  88%... On acoustic time step ('timestep_detection') 22. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |================================================================      |  92%... On acoustic time step ('timestep_detection') 23. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |===================================================================   |  96%... On acoustic time step ('timestep_detection') 24. 
#&gt; ... ... On internal time step ('timestep_archival') 1. 
#&gt;   |                                                                              |======================================================================| 100%
#&gt; ... Movement over acoustic and internal ('archival') time steps has been completed. 
#&gt; ... flapper::.acs() call completed (@ 2022-06-17 09:52:38) after ~0.02 minutes. 
#&gt; ... flapper::.acs_pl() call completed (@ 2022-06-17 09:52:39) after ~0.09 minutes. </div><div class='output co'>#&gt; <span class='message'>flapper::ac() finished (@ 2022-06-17 09:52:39)...</span></div><div class='img'><img src='ac-1.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'>#### Subsequent examples follow the implementation given in acdc().</span>

</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Edward Lavender.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


