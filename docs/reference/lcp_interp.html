<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Interpolate shortest (least-cost) paths between locations along a movement path — lcp_interp • flapper</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Interpolate shortest (least-cost) paths between locations along a movement path — lcp_interp" />
<meta property="og:description" content="This function is a wrapper for lcp_over_surface designed to interpolate shortest (least-cost) paths between sequential locations along an animal movement path. The function is specifically motivated for the interpolation of paths between locations for benthic animals, whose movement is restricted by the seabed (see lcp_over_surface)." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flapper</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/flapper.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/edwardlavender/flapper/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Interpolate shortest (least-cost) paths between locations along a movement path</h1>
    <small class="dont-index">Source: <a href='https://github.com/edwardlavender/flapper/blob/master/R/lcps.R'><code>R/lcps.R</code></a></small>
    <div class="hidden name"><code>lcp_interp.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function is a wrapper for <code><a href='lcp_over_surface.html'>lcp_over_surface</a></code> designed to interpolate shortest (least-cost) paths between sequential locations along an animal movement path. The function is specifically motivated for the interpolation of paths between locations for benthic animals, whose movement is restricted by the seabed (see <code><a href='lcp_over_surface.html'>lcp_over_surface</a></code>).</p>
    </div>

    <pre class="usage"><span class='fu'>lcp_interp</span><span class='op'>(</span>
  <span class='va'>paths</span>,
  <span class='va'>surface</span>,
  <span class='va'>...</span>,
  keep_cols <span class='op'>=</span> <span class='cn'>FALSE</span>,
  calc_distance <span class='op'>=</span> <span class='cn'>TRUE</span>,
  verbose <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>paths</th>
      <td><p>A dataframe that defines movement paths. This must contain a unique, integer identifier for each path from 1 to the number of paths (`path_id'); an integer time step index (`timestep') and the coordinates of sequential locations (`cell_x' and `cell_y'). The example dataset comprising movement paths reconstructed over the seabed by the depth-contour particle filtering algorithm (<code><a href='dat_dcpf_paths.html'>dat_dcpf_paths</a></code>) exemplifies of the appropriate format.</p></td>
    </tr>
    <tr>
      <th>surface</th>
      <td><p>A <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> of the surface over which the object (i.e., individual) moved between sequential locations. <code><a href='lcp_over_surface.html'>lcp_over_surface</a></code> forces some restrictions on the form of this raster. The <code>surface</code> must be planar (i.e., Universal Transverse Mercator projection) with units of metres and equal resolution in the x, y and z directions (see <code><a href='lcp_over_surface.html'>lcp_over_surface</a></code>).</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Additional arguments, passed to <code><a href='lcp_over_surface.html'>lcp_over_surface</a></code>, to control the interpolation (excluding <code>origin</code>, <code>destination</code>, <code>combination</code> and <code>goal</code>).</p></td>
    </tr>
    <tr>
      <th>keep_cols</th>
      <td><p>A logical input that defines whether or not to retain all columns in <code>paths</code> in the returned dataframe (see Value).</p></td>
    </tr>
    <tr>
      <th>calc_distance</th>
      <td><p>A logical input that defines whether or not to calculate distances between sequential positions along the shortest paths (see Value).</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>A logical input that defines whether or not to print messages to the console to monitor function progress.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The function returns a dataframe or a list depending on the input to <code>calc_distance</code>. If <code>calc_distance = FALSE</code>, the function returns a dataframe that defines, for each path (`path_id'), for each time step (`timestep'), a vector of the cell coordinates (`cell_x', `cell_y', `cell_z') on the <code>surface</code> that define the shortest path from the location at the previous time step to the location at the current time step. Thus, the first row contains the individual's initial location and subsequent rows for that time step (<code>timestep = 2</code> if the first time step is defined as <code>timestep =  1</code>, since movement is considered from the location at the `previous' time step to the location at the `current' time step) include the sequential locations of an individual, were it to have moved along the shortest path, to the location at the next time step.  If <code>keep_cols = TRUE</code>, coordinate columns are suffixed by `.x' and the coordinates for each time step (as inputted) are included (with the `.y' suffix) along with any other columns in the inputted dataframe (<code>paths</code>).</p>
<p>If <code>calc_distance = TRUE</code>, a named list is returned with two elements. The `path_lcp' element contains the dataframe of interpolated path coordinates, as described above, with an extra `dist' column that defines the distance over the surface between sequential positions along the path. The `dist_lcp' element contains a dataframe, exactly as inputted via <code>paths</code>, but with the total distance along each shortest path (from the `previous' location to the `current' location) included as a `dist' column (this is simply the sum of the distances provided in <code>path_lcp$dist</code>) for all movements within each timestep for each path.</p>
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>If <code>calc_distances = TRUE</code>, distances are calculated with movement from the previous location to the `current' location (see Value).</p>
<p>A useful application of this function in <code><a href='flapper.html'>flapper</a></code> is the post-hoc evaluation of particle filtering movement algorithms (see <code><a href='pf.html'>pf</a></code>). These can be implemented using movement models based on Euclidean or shortest distances. Since the former is typically much faster, a useful starting point is to implement the chosen algorithm using Euclidean distances and then, for the sample of paths reconstructed by the algorithm, use <code>lcp_interp</code> to examine the similarity between Euclidean and shortest distances and the effects of updated distance values on movement probabilities. If a Euclidean distances implementation of an algorithm is acceptable (i.e., minimum swimming distances are not too large under the movement model), shortest distances from <code>lcp_interp</code> can be used to adjust the movement probabilities to more realistic values. Alternatively,a shortest distances implementation of the movement path algorithm may be necessary.</p>
<p>This function can also be useful for visualising movement paths (e.g., via <code><a href='pf_plot_3d.html'>pf_plot_3d</a></code>).</p>
    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Edward Lavender</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'>#### Define movement paths</span>
<span class='co'># We will interpolate LCPs between sequential locations</span>
<span class='co'># ... of a skate on the seabed</span>
<span class='co'># ... reconstructed by the DCPF algorithm (dc() &amp; pf()), using the</span>
<span class='co'># ... example dat_dcpf_* datasets. We extract the paths</span>
<span class='co'># ... and the surface over which movement occurred from this object:</span>
<span class='va'>paths</span>   <span class='op'>&lt;-</span> <span class='va'>dat_dcpf_paths</span>
<span class='va'>surface</span> <span class='op'>&lt;-</span> <span class='va'>dat_dcpf_histories</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='va'>bathy</span>

<span class='co'>#### Example (1): Implement lcp_interp() for an example path</span>
<span class='co'># ... with calc_distance = FALSE</span>
<span class='co'># Implement approach</span>
<span class='va'>paths_1</span> <span class='op'>&lt;-</span> <span class='va'>paths</span><span class='op'>[</span><span class='va'>paths</span><span class='op'>$</span><span class='va'>path_id</span> <span class='op'>==</span> <span class='fl'>1</span>, <span class='op'>]</span>
<span class='va'>paths_interp_1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_interp</span><span class='op'>(</span>paths <span class='op'>=</span> <span class='va'>paths_1</span>,
                             surface <span class='op'>=</span> <span class='va'>surface</span>,
                             calc_distance <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_interp() called (@ 2021-12-02 11:55:33)... 
#&gt; ... Setting up function... 
#&gt; ... Processing paths... 
#&gt; ... Calculating least-cost paths via flapper::lcp_over_surface()... 
#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 11:55:33)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 11:55:33) after ~0 minutes. 
#&gt; ... flapper::lcp_interp() call completed (@ 2021-12-02 11:55:33) after ~0 minutes. </div><div class='input'><span class='co'># With calc_distance = FALSE, we get a dataframe with sequential locations</span>
<span class='fu'>utils</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>paths_interp_1</span><span class='op'>)</span>
</div><div class='output co'>#&gt;   path_id timestep   cell_x  cell_y   cell_z
#&gt; 1       1        1 708897.1 6254392 135.0958
#&gt; 2       1        1 708897.1 6254366 134.6248
#&gt; 3       1        1 708897.1 6254342 134.1539
#&gt; 4       1        1 708897.1 6254316 133.6829
#&gt; 5       1        1 708897.1 6254292 133.4160
#&gt; 6       1        1 708922.1 6254266 133.4513</div><div class='input'>
<span class='co'>#### Example (2): Keep the original columns in 'paths'</span>
<span class='co'># ... via keep_cols = TRUE</span>
<span class='va'>paths_interp_2</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_interp</span><span class='op'>(</span>paths <span class='op'>=</span> <span class='va'>paths_1</span>,
                             surface <span class='op'>=</span> <span class='va'>surface</span>,
                             calc_distance <span class='op'>=</span> <span class='cn'>FALSE</span>,
                             keep_cols <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_interp() called (@ 2021-12-02 11:55:33)... 
#&gt; ... Setting up function... 
#&gt; ... Processing paths... 
#&gt; ... Calculating least-cost paths via flapper::lcp_over_surface()... 
#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 11:55:33)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='img'><img src='lcp_interp-1.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 11:55:33) after ~0 minutes. 
#&gt; ... flapper::lcp_interp() call completed (@ 2021-12-02 11:55:33) after ~0 minutes. </div><div class='input'><span class='fu'>utils</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>paths_interp_2</span><span class='op'>)</span>
</div><div class='output co'>#&gt;   path_id timestep cell_x.x cell_y.x cell_z.x cell_id cell_x.y cell_y.y
#&gt; 1       1        1 708897.1  6254392 135.0958    3722 708922.1  6254242
#&gt; 2       1        1 708897.1  6254366 134.6248    3722 708922.1  6254242
#&gt; 3       1        1 708897.1  6254342 134.1539    3722 708922.1  6254242
#&gt; 4       1        1 708897.1  6254316 133.6829    3722 708922.1  6254242
#&gt; 5       1        1 708897.1  6254292 133.4160    3722 708922.1  6254242
#&gt; 6       1        1 708922.1  6254266 133.4513    3722 708922.1  6254242
#&gt;   cell_z.y    cell_pr     dist
#&gt; 1 134.0199 0.06891651 152.0691
#&gt; 2 134.0199 0.06891651 152.0691
#&gt; 3 134.0199 0.06891651 152.0691
#&gt; 4 134.0199 0.06891651 152.0691
#&gt; 5 134.0199 0.06891651 152.0691
#&gt; 6 134.0199 0.06891651 152.0691</div><div class='input'>
<span class='co'>#### Example (3): Calculate shortest distances along each path</span>
<span class='co'># ... via calc_distance = TRUE (the default)</span>
<span class='va'>paths_interp_3</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_interp</span><span class='op'>(</span>paths <span class='op'>=</span> <span class='va'>paths_1</span>,
                             surface <span class='op'>=</span> <span class='va'>surface</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_interp() called (@ 2021-12-02 11:55:33)... 
#&gt; ... Setting up function... 
#&gt; ... Processing paths... 
#&gt; ... Calculating least-cost paths via flapper::lcp_over_surface()... 
#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 11:55:33)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 11:55:33) after ~0.01 minutes. 
#&gt; ... Summarising distances for each least-cost path... 
#&gt; ... flapper::lcp_interp() call completed (@ 2021-12-02 11:55:34) after ~0.01 minutes. </div><div class='input'><span class='co'># A named list is returned</span>
<span class='fu'><a href='https://rdrr.io/pkg/raster/man/names.html'>names</a></span><span class='op'>(</span><span class='va'>paths_interp_3</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "path_lcp" "dist_lcp"</div><div class='input'><span class='co'># The 'dist_lcp' element is as inputted but with a 'dist' column that defines</span>
<span class='co'># ... the total distance along the shortest path between sequential locations</span>
<span class='fu'>utils</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>paths_interp_3</span><span class='op'>$</span><span class='va'>dist_lcp</span><span class='op'>)</span>
</div><div class='output co'>#&gt;   path_id timestep cell_id   cell_x  cell_y   cell_z    cell_pr      dist
#&gt; 1       1        0    3241 708897.1 6254392 135.0958 1.00000000        NA
#&gt; 2       1        1    3722 708922.1 6254242 134.0199 0.06891651 160.37655
#&gt; 3       1        2    3243 708947.1 6254392 133.6996 0.06891651 160.37573
#&gt; 4       1        3    3166 709022.1 6254416 133.6938 0.74022781  85.36217
#&gt; 5       1        4    3006 709022.1 6254466 134.0630 0.92414182  50.00136
#&gt; 6       1        5    3009 709097.1 6254466 134.9762 0.77729986  75.00556</div><div class='input'><span class='co'># The 'path_lcp' element contains the paths, as described above, with an</span>
<span class='co'># ... additional 'dist' column for the distances between sequential locations</span>
<span class='co'># ... along each shortest path (i.e., time step)</span>
<span class='fu'>utils</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>paths_interp_3</span><span class='op'>$</span><span class='va'>path_lcp</span><span class='op'>)</span>
</div><div class='output co'>#&gt;   path_id timestep   cell_x  cell_y   cell_z     dist
#&gt; 1       1        1 708897.1 6254392 135.0958       NA
#&gt; 2       1        1 708897.1 6254366 134.6248 25.00444
#&gt; 3       1        1 708897.1 6254342 134.1539 25.00444
#&gt; 4       1        1 708897.1 6254316 133.6829 25.00444
#&gt; 5       1        1 708897.1 6254292 133.4160 25.00142
#&gt; 6       1        1 708922.1 6254266 133.4513 35.35536</div><div class='input'>
<span class='co'>#### Example (4): Using lcp_interp() for post-hoc evaluation and adjustment</span>
<span class='co'># ... of movement model outputs for the DCPF algorithm</span>

<span class='co'>## Examine whether shortest distances for path derived using</span>
<span class='co'># ... planar Euclidean distances are within reasonable limits given the</span>
<span class='co'># ... movement model:</span>
<span class='co'># First, add shortest distances to the dataframe</span>
<span class='va'>paths_1</span><span class='op'>$</span><span class='va'>key</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/paste.html'>paste0</a></span><span class='op'>(</span><span class='va'>paths_1</span><span class='op'>$</span><span class='va'>path_id</span>, <span class='st'>"-"</span>, <span class='fu'><a href='https://rdrr.io/r/base/paste.html'>paste0</a></span><span class='op'>(</span><span class='va'>paths_1</span><span class='op'>$</span><span class='va'>timestep</span><span class='op'>)</span><span class='op'>)</span>
<span class='va'>paths_interp_3</span><span class='op'>$</span><span class='va'>dist_lcp</span><span class='op'>$</span><span class='va'>key</span> <span class='op'>&lt;-</span>
  <span class='fu'><a href='https://rdrr.io/r/base/paste.html'>paste0</a></span><span class='op'>(</span><span class='va'>paths_interp_3</span><span class='op'>$</span><span class='va'>dist_lcp</span><span class='op'>$</span><span class='va'>path_id</span>, <span class='st'>"-"</span>,
         <span class='va'>paths_interp_3</span><span class='op'>$</span><span class='va'>dist_lcp</span><span class='op'>$</span><span class='va'>timestep</span><span class='op'>)</span>
<span class='va'>paths_1</span><span class='op'>$</span><span class='va'>dist</span> <span class='op'>&lt;-</span>
  <span class='va'>paths_interp_3</span><span class='op'>$</span><span class='va'>dist_lcp</span><span class='op'>$</span><span class='va'>dist</span><span class='op'>[</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/match.html'>match</a></span><span class='op'>(</span><span class='va'>paths_1</span><span class='op'>$</span><span class='va'>key</span>, <span class='va'>paths_interp_3</span><span class='op'>$</span><span class='va'>dist_lcp</span><span class='op'>$</span><span class='va'>key</span><span class='op'>)</span><span class='op'>]</span>
<span class='co'># Examine shortest distances with respect to movement model used to implement DCPF</span>
<span class='fu'>prettyGraphics</span><span class='fu'>::</span><span class='fu'><a href='https://edwardlavender.github.io/prettyGraphics/reference/pretty_plot.html'>pretty_plot</a></span><span class='op'>(</span><span class='va'>dat_dcpf_histories</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='fu'>calc_movement_pr</span><span class='op'>(</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>1000</span><span class='op'>)</span>, type <span class='op'>=</span> <span class='st'>"l"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>'y' argument not supplied; 'x' is plotted against an index.</span></div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/rug.html'>rug</a></span><span class='op'>(</span><span class='va'>paths_1</span><span class='op'>$</span><span class='va'>dist</span>, col <span class='op'>=</span> <span class='st'>"red"</span>, pos <span class='op'>=</span> <span class='fl'>0</span>, lwd <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
</div><div class='img'><img src='lcp_interp-2.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'># In this case, every step in this path has non zero probability, suggesting</span>
<span class='co'># ... the Euclidean approach worked reasonably well (there aren't 'impossible'</span>
<span class='co'># ... movements when we account for the bathymetry).</span>

<span class='co'>## Post-hoc adjustment of movement probabilities based on shortest distances</span>
<span class='co'># Given the Euclidean approach has generated a reasonable path, we can adjust</span>
<span class='co'># ... the probabilities associated with sequential steps so that they are based,</span>
<span class='co'># ... more realistically, on shortest distances:</span>
<span class='va'>paths_1</span><span class='op'>$</span><span class='va'>cell_pr_2</span> <span class='op'>&lt;-</span> <span class='va'>dat_dcpf_histories</span><span class='op'>$</span><span class='va'>args</span><span class='op'>$</span><span class='fu'>calc_movement_pr</span><span class='op'>(</span><span class='va'>paths_1</span><span class='op'>$</span><span class='va'>dist</span><span class='op'>)</span>
<span class='fu'>prettyGraphics</span><span class='fu'>::</span><span class='fu'><a href='https://edwardlavender.github.io/prettyGraphics/reference/pretty_plot.html'>pretty_plot</a></span><span class='op'>(</span><span class='va'>paths_1</span><span class='op'>$</span><span class='va'>cell_pr</span>, <span class='va'>paths_1</span><span class='op'>$</span><span class='va'>cell_pr_2</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>1 observation pair(s) in x are NA; these are removed.</span></div><div class='input'><span class='fu'>graphics</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/graphics/abline.html'>abline</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>1</span>, lty <span class='op'>=</span> <span class='fl'>3</span><span class='op'>)</span>
</div><div class='img'><img src='lcp_interp-3.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'># In this case, probabilities are mostly similar</span>

<span class='co'>## Alternatively, we could re-implement the algorithm using shortest distances</span>
<span class='co'># Re-implement algorithm</span>
<span class='va'>dcpf_args</span>               <span class='op'>&lt;-</span> <span class='va'>dat_dcpf_histories</span><span class='op'>$</span><span class='va'>args</span>
<span class='va'>dcpf_args</span><span class='op'>$</span><span class='va'>calc_distance</span> <span class='op'>&lt;-</span> <span class='st'>"lcp"</span>
<span class='va'>dcpf_args</span><span class='op'>$</span><span class='va'>n</span>             <span class='op'>&lt;-</span> <span class='fl'>100</span>
<span class='va'>dcpf_history</span>            <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/do.call.html'>do.call</a></span><span class='op'>(</span><span class='va'>pf</span>, <span class='va'>dcpf_args</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf() called (@ 2021-12-02 11:55:34)... 
#&gt; ... Setting up function... 
#&gt; ... Setting up cost-surface for calc_distance = 'lcp'... 
#&gt; flapper::lcp_costs() called (@ 2021-12-02 11:55:34)... 
#&gt; ... Defining transition matrices... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating distance matrices... 
#&gt; ... Assembling LCP costs... 
#&gt; ... flapper::lcp_costs() call completed (@ 2021-12-02 11:55:34) after ~0 minutes. 
#&gt; flapper::lcp_graph_surface() called (@ 2021-12-02 11:55:34)... 
#&gt; ... Defining nodes, edges and costs to make graph... 
#&gt; ... Constructing graph object... 
#&gt; ... flapper::lcp_graph_surface() call completed (@ 2021-12-02 11:55:34) after ~0 minutes. 
#&gt; ... Determining the set of possible starting locations (t = 1)... 
#&gt; flapper::lcp_from_point() called (@ 2021-12-02 11:55:34)... 
#&gt; ... Calling cppRouting::get_distance_matrix() to get least-cost distances... 
#&gt; ... Making raster of least-cost distances from origin ... 
#&gt; ... flapper::lcp_from_point() call completed (@ 2021-12-02 11:55:34) after ~0 minutes. 
#&gt; ... Implementing algorithm iteratively over time steps... 
#&gt; ... ... Time = 1... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 2... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 3... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 4... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 5... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 6... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 7... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 8... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 9... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 10... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 11... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 12... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 13... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 14... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 15... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 16... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 17... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... ... ... For each particle, getting the possible positions for the next time step... 
#&gt; ... ... Time = 18... 
#&gt; ... ... ... Selecting candidate starting positions for the current time step... 
#&gt; ... flapper::pf() call completed (@ 2021-12-02 11:56:09) after ~0.59 minutes. </div><div class='input'><span class='va'>paths</span>                   <span class='op'>&lt;-</span> <span class='fu'><a href='pf_simplify.html'>pf_simplify</a></span><span class='op'>(</span><span class='va'>dcpf_history</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::pf_simplify() called (@ 2021-12-02 11:56:09)... 
#&gt; ... Getting pairwise cell movements based on calc_distance = 'lcp'... 
#&gt; ... Setting up LCP calculations... 
#&gt; ... ... Stepping through time steps to join coordinate pairs... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... ... Identifying connected cells... 
#&gt; ... Assembling paths... 
#&gt; ... Formatting paths... 
#&gt; ... Adding cell coordinates and depths... 
#&gt; ... flapper::pf_simplify() call completed (@ 2021-12-02 11:56:09) after ~0.01 minutes. </div><div class='input'><span class='co'># Interpolate paths</span>
<span class='va'>paths_interp_4</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_interp</span><span class='op'>(</span><span class='va'>paths</span>, <span class='va'>surface</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_interp() called (@ 2021-12-02 11:56:09)... 
#&gt; ... Setting up function... 
#&gt; ... Processing paths... 
#&gt; ... Calculating least-cost paths via flapper::lcp_over_surface()... 
#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 11:56:09)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='img'><img src='lcp_interp-4.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 11:56:10) after ~0.01 minutes. 
#&gt; ... Summarising distances for each least-cost path... 
#&gt; ... flapper::lcp_interp() call completed (@ 2021-12-02 11:56:10) after ~0.02 minutes. </div><div class='input'><span class='co'># Show the probabilities reported by the DCPF algorithm are the same as those</span>
<span class='co'># ... derived by post-hoc calculation of probabilities from shortest paths</span>
<span class='co'># ... interpolated from reported results, although the origin is not included:</span>
<span class='fu'>utils</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span>
  <span class='fu'><a href='https://rdrr.io/r/base/cbind.html'>cbind</a></span><span class='op'>(</span><span class='va'>dcpf_args</span><span class='op'>$</span><span class='fu'>calc_movement_pr</span><span class='op'>(</span><span class='va'>paths_interp_4</span><span class='op'>$</span><span class='va'>dist_lcp</span><span class='op'>$</span><span class='va'>dist</span><span class='op'>)</span>,
        <span class='va'>paths</span><span class='op'>$</span><span class='va'>cell_pr</span><span class='op'>)</span>
<span class='op'>)</span>
</div><div class='output co'>#&gt;           [,1]      [,2]
#&gt; [1,]        NA 1.0000000
#&gt; [2,] 0.9770117 0.9770117
#&gt; [3,] 0.4995128 0.4995128
#&gt; [4,] 0.8789024 0.8789024
#&gt; [5,] 0.7770063 0.7770063
#&gt; [6,] 0.9620114 0.9620114</div><div class='input'>

</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Edward Lavender.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


