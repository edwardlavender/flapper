<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The `quick' depth-contour (DCQ) algorithm — dcq • flapper</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="The `quick' depth-contour (DCQ) algorithm — dcq" />
<meta property="og:description" content="This function implements the `quick' depth-contour (DCQ) algorithm. As for the DC algorithm (dc), the DCQ algorithm relates one-dimensional depth time series to a two-dimensional bathymetry surface to determine the extent to which different parts of an area might have (or have not) been used, or effectively represent occupied depths, over time. However, a modified (binning) approach is used that is much faster. To implement the function, a list of depth time series, one for each time unit (e.g. month/season) need to be supplied, along with a bathymetry raster. For each time unit, the function counts the number of depth observations in each user-defined depth bin (e.g., 10 m depth bins) and then relates these counts to the local bathymetry to produce a raster in which the value of each cell is given by the number of times in which the depth bin for that cell was used. The function returns a list of rasters, one for each time unit, and a plot of these rasters, if requested." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flapper</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/flapper.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/edwardlavender/flapper/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>The `quick' depth-contour (DCQ) algorithm</h1>
    <small class="dont-index">Source: <a href='https://github.com/edwardlavender/flapper/blob/master/R/dcq.R'><code>R/dcq.R</code></a></small>
    <div class="hidden name"><code>dcq.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function implements the `quick' depth-contour (DCQ) algorithm. As for the DC algorithm (<code><a href='dc.html'>dc</a></code>), the DCQ algorithm relates one-dimensional depth time series to a two-dimensional bathymetry surface to determine the extent to which different parts of an area might have (or have not) been used, or effectively represent occupied depths, over time. However, a modified (binning) approach is used that is much faster. To implement the function, a list of depth time series, one for each time unit (e.g. month/season) need to be supplied, along with a bathymetry <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>. For each time unit, the function counts the number of depth observations in each user-defined depth bin (e.g., 10 m depth bins) and then relates these counts to the local bathymetry to produce a raster in which the value of each cell is given by the number of times in which the depth bin for that cell was used. The function returns a list of rasters, one for each time unit, and a plot of these rasters, if requested.</p>
    </div>

    <pre class="usage"><span class='fu'>dcq</span><span class='op'>(</span>
  <span class='va'>archival_ls</span>,
  <span class='va'>bathy</span>,
  bin <span class='op'>=</span> <span class='fl'>10</span>,
  transform <span class='op'>=</span> <span class='cn'>NULL</span>,
  plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
  before_plot <span class='op'>=</span> <span class='cn'>NULL</span>,
  after_plot <span class='op'>=</span> <span class='cn'>NULL</span>,
  fix_zlim <span class='op'>=</span> <span class='cn'>FALSE</span>,
  one_page <span class='op'>=</span> <span class='cn'>FALSE</span>,
  cl <span class='op'>=</span> <span class='cn'>NULL</span>,
  varlist <span class='op'>=</span> <span class='cn'>NULL</span>,
  verbose <span class='op'>=</span> <span class='cn'>TRUE</span>,
  <span class='va'>...</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>archival_ls</th>
      <td><p>A list of dataframes, with one element for each time unit (e.g., month), which contain depth time series to be related to the local bathymetry. Each dataframe should contain a column of depths (`depth') and a column that defines the time unit (`time_unit'). Depth should be recorded using absolute values in the same units as the bathymetry (see below).</p></td>
    </tr>
    <tr>
      <th>bathy</th>
      <td><p>A <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> of the bathymetry in an area within which the animal is likely to have been located over the study. Bathymetry values should be recorded as absolute values and in the same units as for depths (see <code>archival_ls</code>).</p></td>
    </tr>
    <tr>
      <th>bin</th>
      <td><p>A number that defines the interval into which depth observations are binned. This should be provided in the same units as depths (see <code>archival_ls</code>) and the bathymetry (see <code>bathy</code>). The appropriate value of <code>bin</code> depends on the measurement error of the <code>bathy</code> data and the depth time series, the tidal range in an area, computational requirements, and scale of biological research objectives. For large depth time series and/or large, high-resolution bathymetry rasters, it can be useful to test the algorithm's speed using a relatively large bin.</p></td>
    </tr>
    <tr>
      <th>transform</th>
      <td><p>(optional) A function, such as <code>sqrt</code>, to transform counts. This affects the returned rasters and any plots produced (see Value). Be careful with some functions, such as <code>log</code>, which can generate problematic outputs (such as z axis limits if these are not defined manually), in some situations (for example, if some cells in the area are not visited).</p></td>
    </tr>
    <tr>
      <th>plot</th>
      <td><p>A logical input that defines whether or not to plot the rasters. If <code>plot = TRUE</code>, the function produces a plot for each time unit.</p></td>
    </tr>
    <tr>
      <th>before_plot, after_plot</th>
      <td><p>(optional) Stand-alone functions that are executed before and after the plot for each time unit is created, respectively. For example, it may be useful to plot the coast in an area before each raster is plotted, or add custom axes after each plot has been produced.</p></td>
    </tr>
    <tr>
      <th>fix_zlim, one_page, ...</th>
      <td><p>(optional) Plot customisation options. <code>fix_zlim</code> is a logical input that defines whether or not to fix z axis limits across all plots (to facilitate comparisons), or a vector of two numbers that define a custom range for the z axis which is fixed across all plots. <code>fix_zlim = FALSE</code> produces plots in which the z axis is allowed to vary flexibly between time units. <code>one_page</code> is a logical input that defines whether or not to produce all plots on one page; this is only implemented if there are fewer than 25 time units, beyond which there are typically to many plots to fit on one page. Additional plot customisation arguments can be passed to <code><a href='https://rdrr.io/pkg/fields/man/image.plot.html'>image.plot</a></code> via <code>...</code>.</p></td>
    </tr>
    <tr>
      <th>cl, varlist</th>
      <td><p>(optional) Parallelisation options. <code>cl</code> is (a) a cluster object from <code><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></code> or (b) an integer that defines the number of child processes. <code>varlist</code> is a character vector of variables for export (see <code><a href='cl.html'>cl_export</a></code>). Exported variables must be located in the global environment. If a cluster is supplied, the connection to the cluster is closed within the function (see <code><a href='cl.html'>cl_stop</a></code>). For further information, see <code><a href='cl.html'>cl_lapply</a></code> and <code><a href='flapper-tips-parallel.html'>flapper-tips-parallel</a></code>.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>A logical input that defines whether or not to relay messages to the console to monitor function progress.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The function returns a named list of rasters, one for each time unit, in which the value of each cell is the number of times that that cell was represented by the corresponding depth bin in the depth time series.</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p>This is a modified version of the DC algorithm implemented by <code><a href='dc.html'>dc</a></code>. The ACDC algorithm (see <code><a href='acdc.html'>acdc</a></code>) extends the depth-contour algorithm by integrating information from acoustic detections of individuals at each time step to restrict the locations in which depth contours are identified.</p></div>
    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Edward Lavender</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'>#### Define data for examples</span>
<span class='co'># Define archival time series with required columns ('depth' and 'time_unit')</span>
<span class='va'>dat_archival</span> <span class='op'>&lt;-</span> <span class='va'>dat_archival</span><span class='op'>[</span><span class='fu'><a href='https://rdrr.io/r/base/order.html'>order</a></span><span class='op'>(</span><span class='va'>dat_archival</span><span class='op'>$</span><span class='va'>timestamp</span><span class='op'>)</span>, <span class='op'>]</span>
<span class='va'>dat_archival</span><span class='op'>$</span><span class='va'>time_unit</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/raster/man/cut.html'>cut</a></span><span class='op'>(</span><span class='va'>dat_archival</span><span class='op'>$</span><span class='va'>timestamp</span>, <span class='st'>"weeks"</span><span class='op'>)</span>
<span class='co'># Define a list of dataframes with one element for each time unit</span>
<span class='va'>archival_ls</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/split.html'>split</a></span><span class='op'>(</span><span class='va'>dat_archival</span>, f <span class='op'>=</span> <span class='va'>dat_archival</span><span class='op'>$</span><span class='va'>time_unit</span><span class='op'>)</span>
<span class='co'># Define bathymetry data (and coastline data for plotting)</span>
<span class='va'>bathy</span> <span class='op'>&lt;-</span> <span class='fu'>prettyGraphics</span><span class='fu'>::</span><span class='va'><a href='https://edwardlavender.github.io/prettyGraphics/reference/dat_gebco.html'>dat_gebco</a></span>
<span class='va'>coastline</span> <span class='op'>&lt;-</span> <span class='fu'>prettyGraphics</span><span class='fu'>::</span><span class='va'><a href='https://edwardlavender.github.io/prettyGraphics/reference/dat_coast_around_oban.html'>dat_coast_around_oban</a></span>

<span class='co'>#### Example (1) Implement the dcq() algorithm with 25 m bins</span>
<span class='va'>dcq_maps</span> <span class='op'>&lt;-</span> <span class='fu'>dcq</span><span class='op'>(</span>archival_ls <span class='op'>=</span> <span class='va'>archival_ls</span>,
              bathy <span class='op'>=</span> <span class='va'>bathy</span>,
              bin <span class='op'>=</span> <span class='fl'>25</span>,
              plot <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::dcq() called... 
#&gt; ... Step 1: Checking user inputs... 
#&gt; ... Step 2: Calculating the number of observations within each depth bin for each time unit... 
#&gt; ... Step 3: Translating counts of observations within depth bins into maps... </div><div class='input'><span class='co'># The function returns a list of rasters, with one raster</span>
<span class='co'># ... for each time unit.</span>
<span class='va'>dcq_maps</span>
</div><div class='output co'>#&gt; $`2016-03-14`
#&gt; class      : RasterLayer 
#&gt; dimensions : 36, 36, 1296  (nrow, ncol, ncell)
#&gt; resolution : 0.004166667, 0.004166667  (x, y)
#&gt; extent     : -5.545833, -5.395833, 56.34167, 56.49167  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=longlat +datum=WGS84 +no_defs 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 1685  (min, max)
#&gt; 
#&gt; 
#&gt; $`2016-03-21`
#&gt; class      : RasterLayer 
#&gt; dimensions : 36, 36, 1296  (nrow, ncol, ncell)
#&gt; resolution : 0.004166667, 0.004166667  (x, y)
#&gt; extent     : -5.545833, -5.395833, 56.34167, 56.49167  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=longlat +datum=WGS84 +no_defs 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 4702  (min, max)
#&gt; 
#&gt; 
#&gt; $`2016-03-28`
#&gt; class      : RasterLayer 
#&gt; dimensions : 36, 36, 1296  (nrow, ncol, ncell)
#&gt; resolution : 0.004166667, 0.004166667  (x, y)
#&gt; extent     : -5.545833, -5.395833, 56.34167, 56.49167  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=longlat +datum=WGS84 +no_defs 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 4815  (min, max)
#&gt; 
#&gt; 
#&gt; $`2016-04-04`
#&gt; class      : RasterLayer 
#&gt; dimensions : 36, 36, 1296  (nrow, ncol, ncell)
#&gt; resolution : 0.004166667, 0.004166667  (x, y)
#&gt; extent     : -5.545833, -5.395833, 56.34167, 56.49167  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=longlat +datum=WGS84 +no_defs 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 4082  (min, max)
#&gt; 
#&gt; 
#&gt; $`2016-04-11`
#&gt; class      : RasterLayer 
#&gt; dimensions : 36, 36, 1296  (nrow, ncol, ncell)
#&gt; resolution : 0.004166667, 0.004166667  (x, y)
#&gt; extent     : -5.545833, -5.395833, 56.34167, 56.49167  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=longlat +datum=WGS84 +no_defs 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 3788  (min, max)
#&gt; 
#&gt; 
#&gt; $`2016-04-18`
#&gt; class      : RasterLayer 
#&gt; dimensions : 36, 36, 1296  (nrow, ncol, ncell)
#&gt; resolution : 0.004166667, 0.004166667  (x, y)
#&gt; extent     : -5.545833, -5.395833, 56.34167, 56.49167  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=longlat +datum=WGS84 +no_defs 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 0, 2575  (min, max)
#&gt; 
#&gt; </div><div class='input'>
<span class='co'>#### Example (2): Implement the algorithm in parallel:</span>
<span class='va'>dcq_maps</span> <span class='op'>&lt;-</span> <span class='fu'>dcq</span><span class='op'>(</span>archival_ls <span class='op'>=</span> <span class='va'>archival_ls</span>,
              bathy <span class='op'>=</span> <span class='va'>bathy</span>,
              bin <span class='op'>=</span> <span class='fl'>25</span>,
              plot <span class='op'>=</span> <span class='cn'>FALSE</span>,
              cl <span class='op'>=</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::dcq() called... 
#&gt; ... Step 1: Checking user inputs... 
#&gt; ... Step 2: Calculating the number of observations within each depth bin for each time unit... 
#&gt; ... Step 3: Translating counts of observations within depth bins into maps... </div><div class='input'>
<span class='co'>#### Example (3): Visualise the function outputs on one page</span>
<span class='co'># ... using standard options.</span>
<span class='co'># Examine results with 25 m bin</span>
<span class='va'>dcq_maps</span> <span class='op'>&lt;-</span> <span class='fu'>dcq</span><span class='op'>(</span>archival_ls <span class='op'>=</span> <span class='va'>archival_ls</span>,
              bathy <span class='op'>=</span> <span class='va'>bathy</span>,
              bin <span class='op'>=</span> <span class='fl'>25</span>,
              plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
              one_page <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::dcq() called... 
#&gt; ... Step 1: Checking user inputs... 
#&gt; ... Step 2: Calculating the number of observations within each depth bin for each time unit... 
#&gt; ... Step 3: Translating counts of observations within depth bins into maps... 
#&gt; ... Step 4: Mapping the results... </div><div class='img'><img src='dcq-1.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'># Examine results with a higher resolution bin</span>
<span class='va'>dcq_maps</span> <span class='op'>&lt;-</span> <span class='fu'>dcq</span><span class='op'>(</span>archival_ls <span class='op'>=</span> <span class='va'>archival_ls</span>,
              bathy <span class='op'>=</span> <span class='va'>bathy</span>,
              bin <span class='op'>=</span> <span class='fl'>5</span>,
              plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
              one_page <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::dcq() called... 
#&gt; ... Step 1: Checking user inputs... 
#&gt; ... Step 2: Calculating the number of observations within each depth bin for each time unit... 
#&gt; ... Step 3: Translating counts of observations within depth bins into maps... 
#&gt; ... Step 4: Mapping the results... </div><div class='img'><img src='dcq-2.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'>#### Example (4): Plot customisation options</span>
<span class='co'># fix zlim to be constant across all plots to enable comparability</span>
<span class='va'>dcq_maps</span> <span class='op'>&lt;-</span> <span class='fu'>dcq</span><span class='op'>(</span>archival_ls <span class='op'>=</span> <span class='va'>archival_ls</span>,
              bathy <span class='op'>=</span> <span class='va'>bathy</span>,
              bin <span class='op'>=</span> <span class='fl'>5</span>,
              plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
              one_page <span class='op'>=</span> <span class='cn'>TRUE</span>,
              fix_zlim <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::dcq() called... 
#&gt; ... Step 1: Checking user inputs... 
#&gt; ... Step 2: Calculating the number of observations within each depth bin for each time unit... 
#&gt; ... Step 3: Translating counts of observations within depth bins into maps... 
#&gt; ... Step 4: Mapping the results... </div><div class='img'><img src='dcq-3.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'># fix zlim using custom limits across all plots</span>
<span class='va'>dcq_maps</span> <span class='op'>&lt;-</span> <span class='fu'>dcq</span><span class='op'>(</span>archival_ls <span class='op'>=</span> <span class='va'>archival_ls</span>,
              bathy <span class='op'>=</span> <span class='va'>bathy</span>,
              bin <span class='op'>=</span> <span class='fl'>5</span>,
              plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
              one_page <span class='op'>=</span> <span class='cn'>TRUE</span>,
              fix_zlim <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>5000</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::dcq() called... 
#&gt; ... Step 1: Checking user inputs... 
#&gt; ... Step 2: Calculating the number of observations within each depth bin for each time unit... 
#&gt; ... Step 3: Translating counts of observations within depth bins into maps... 
#&gt; ... Step 4: Mapping the results... </div><div class='img'><img src='dcq-4.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'># Transform the returned and plotted rasters by supplying a function to the</span>
<span class='co'># ... transform argument</span>
<span class='va'>dcq_maps</span> <span class='op'>&lt;-</span> <span class='fu'>dcq</span><span class='op'>(</span>archival_ls <span class='op'>=</span> <span class='va'>archival_ls</span>,
              bathy <span class='op'>=</span> <span class='va'>bathy</span>,
              bin <span class='op'>=</span> <span class='fl'>5</span>,
              plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
              one_page <span class='op'>=</span> <span class='cn'>TRUE</span>,
              transform <span class='op'>=</span> <span class='va'>sqrt</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::dcq() called... 
#&gt; ... Step 1: Checking user inputs... 
#&gt; ... Step 2: Calculating the number of observations within each depth bin for each time unit... 
#&gt; ... Step 3: Translating counts of observations within depth bins into maps... 
#&gt; ... Step 4: Mapping the results... </div><div class='img'><img src='dcq-5.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'># Customise the plot further via before_plot, after_plot functions</span>
<span class='co'># ... and other arguments passed via ... E.g., note the need to include</span>
<span class='co'># ... add = TRUE because the raster plot is added to the plot of the coastline.</span>
<span class='va'>dcq_maps</span> <span class='op'>&lt;-</span> <span class='fu'>dcq</span><span class='op'>(</span>archival_ls <span class='op'>=</span> <span class='va'>archival_ls</span>,
              bathy <span class='op'>=</span> <span class='va'>bathy</span>,
              bin <span class='op'>=</span> <span class='fl'>5</span>,
              plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
              one_page <span class='op'>=</span> <span class='cn'>TRUE</span>,
              transform <span class='op'>=</span> <span class='va'>sqrt</span>,
              fix_zlim <span class='op'>=</span> <span class='cn'>FALSE</span>,
              before_plot <span class='op'>=</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>coastline</span><span class='op'>)</span>,
              after_plot <span class='op'>=</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'>lines</span><span class='op'>(</span><span class='va'>coastline</span><span class='op'>)</span>,
              add <span class='op'>=</span> <span class='cn'>TRUE</span>,
              col <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/grDevices/palettes.html'>topo.colors</a></span><span class='op'>(</span><span class='fl'>100</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::dcq() called... 
#&gt; ... Step 1: Checking user inputs... 
#&gt; ... Step 2: Calculating the number of observations within each depth bin for each time unit... 
#&gt; ... Step 3: Translating counts of observations within depth bins into maps... 
#&gt; ... Step 4: Mapping the results... </div><div class='output co'>#&gt; <span class='warning'>Warning: Discarded datum WGS_1984 in CRS definition,</span>
#&gt; <span class='warning'> but +towgs84= values preserved</span></div><div class='output co'>#&gt; <span class='warning'>Warning: Discarded datum WGS_1984 in CRS definition,</span>
#&gt; <span class='warning'> but +towgs84= values preserved</span></div><div class='output co'>#&gt; <span class='warning'>Warning: Discarded datum WGS_1984 in CRS definition,</span>
#&gt; <span class='warning'> but +towgs84= values preserved</span></div><div class='output co'>#&gt; <span class='warning'>Warning: Discarded datum WGS_1984 in CRS definition,</span>
#&gt; <span class='warning'> but +towgs84= values preserved</span></div><div class='output co'>#&gt; <span class='warning'>Warning: Discarded datum WGS_1984 in CRS definition,</span>
#&gt; <span class='warning'> but +towgs84= values preserved</span></div><div class='output co'>#&gt; <span class='warning'>Warning: Discarded datum WGS_1984 in CRS definition,</span>
#&gt; <span class='warning'> but +towgs84= values preserved</span></div><div class='img'><img src='dcq-6.png' alt='' width='700' height='433' /></div><div class='input'>
</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Edward Lavender.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


