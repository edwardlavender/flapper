<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Calculate shortest path(s) and/or distance(s) over a surface between origin and destination coordinates — lcp_over_surface • flapper</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Calculate shortest path(s) and/or distance(s) over a surface between origin and destination coordinates — lcp_over_surface" />
<meta property="og:description" content="This function computes the shortest path(s) and/or distance(s) over a surface between origin and destination coordinates. To implement this function, origin and destination coordinates need to be specified as matrices and the surface over which movement occurs should be supplied as a raster. Since determining shortest paths can be computationally and memory-intensive, the surface can be reduced in size and/or resolution before these are computed, by (a) cropping the surface within user-defined extents; (b) focusing on a buffer zone along a Euclidean transect connecting origin and destination coordinates; (c) aggregating the surface to reduce the resolution; and/or (d) masking out areas over which movement is impossible (e.g., land for marine animals). Then, the function computes distances between connected cells, given (a) the planar distances between connected cells and (b) their difference in elevation. These distances are taken as a measure of `cost'. For each pair of origin and destination coordinates, or for all combinations of coordinates, these distances are used to compute the least-cost (i.e., shortest) path and/or the distance of this path, using functions in the cppRouting or gdistance package. The function returns the shortest path(s) and/or their distance(s) (m) along with a plot and a list of objects involved in the calculations." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flapper</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/flapper.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/edwardlavender/flapper/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Calculate shortest path(s) and/or distance(s) over a surface between origin and destination coordinates</h1>
    <small class="dont-index">Source: <a href='https://github.com/edwardlavender/flapper/blob/master/R/lcps.R'><code>R/lcps.R</code></a></small>
    <div class="hidden name"><code>lcp_over_surface.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function computes the shortest path(s) and/or distance(s) over a <code>surface</code> between <code>origin</code> and <code>destination</code> coordinates. To implement this function, <code>origin</code> and <code>destination</code> coordinates need to be specified as matrices and the surface over which movement occurs should be supplied as a <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>. Since determining shortest paths can be computationally and memory-intensive, the <code>surface</code> can be reduced in size and/or resolution before these are computed, by (a) cropping the surface within user-defined extents; (b) focusing on a buffer zone along a Euclidean transect connecting <code>origin</code> and <code>destination</code> coordinates; (c) aggregating the surface to reduce the resolution; and/or (d) masking out areas over which movement is impossible (e.g., land for marine animals). Then, the function computes distances between connected cells, given (a) the planar distances between connected cells and (b) their difference in elevation. These distances are taken as a measure of `cost'. For each pair of <code>origin</code> and <code>destination</code> coordinates, or for all combinations of coordinates, these distances are used to compute the least-cost (i.e., shortest) path and/or the distance of this path, using functions in the <code><a href='https://rdrr.io/pkg/cppRouting/man/cppRouting-package.html'>cppRouting</a></code> or <code><a href='https://rdrr.io/pkg/gdistance/man/gdistance.html'>gdistance</a></code> package. The function returns the shortest path(s) and/or their distance(s) (m) along with a plot and a list of objects involved in the calculations.</p>
    </div>

    <pre class="usage"><span class='fu'>lcp_over_surface</span><span class='op'>(</span>
  <span class='va'>origin</span>,
  <span class='va'>destination</span>,
  <span class='va'>surface</span>,
  crop <span class='op'>=</span> <span class='cn'>NULL</span>,
  buffer <span class='op'>=</span> <span class='cn'>NULL</span>,
  aggregate <span class='op'>=</span> <span class='cn'>NULL</span>,
  mask <span class='op'>=</span> <span class='cn'>NULL</span>,
  mask_inside <span class='op'>=</span> <span class='cn'>TRUE</span>,
  plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
  goal <span class='op'>=</span> <span class='fl'>1</span>,
  combination <span class='op'>=</span> <span class='st'>"pair"</span>,
  method <span class='op'>=</span> <span class='st'>"cppRouting"</span>,
  cppRouting_algorithm <span class='op'>=</span> <span class='st'>"bi"</span>,
  cl <span class='op'>=</span> <span class='cn'>NULL</span>,
  varlist <span class='op'>=</span> <span class='cn'>NULL</span>,
  use_all_cores <span class='op'>=</span> <span class='cn'>FALSE</span>,
  check <span class='op'>=</span> <span class='cn'>TRUE</span>,
  verbose <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>origin</th>
      <td><p>A matrix which defines the coordinates (x, y) of the starting location(s). Coordinates should lie on a plane (i.e., Universal Transverse Mercator projection).</p></td>
    </tr>
    <tr>
      <th>destination</th>
      <td><p>A matrix which defines the coordinates (x, y) of the finishing location(s). Coordinates should lie on a plane (i.e., Universal Transverse Mercator projection).</p></td>
    </tr>
    <tr>
      <th>surface</th>
      <td><p>A <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> over which the object (e.g., individual) must move from <code>origin</code> to <code>destination</code>. The <code>surface</code> must be planar (i.e., Universal Transverse Mercator projection) with units of metres in x, y and z directions (m). The <code>surface</code>'s <code>resolution</code> is taken to define the distance between horizontally and vertically connected cells and must be the same in both x and y directions (for <code>surface</code>'s with unequal horizontal resolution, <code><a href='https://rdrr.io/pkg/raster/man/resample.html'>resample</a></code> can be used to equalise resolution: see Examples). Any cells with NA values (e.g., due to missing data) are treated as `impossible' to move though by the algorithm. In this case, the <code>surface</code> might need to be pre-processed so that NAs are replaced/removed before implementing the function, depending on their source.</p></td>
    </tr>
    <tr>
      <th>crop</th>
      <td><p>(optional) An <code><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></code> object that is used to <code><a href='https://rdrr.io/pkg/raster/man/crop.html'>crop</a></code> the extent of the <code>surface</code>, before the least-cost algorithms are implemented. This may be useful for large rasters to reduce memory requirements/computation time.</p></td>
    </tr>
    <tr>
      <th>buffer</th>
      <td><p>(optional) A named list of arguments, passed to <code><a href='https://rdrr.io/pkg/rgeos/man/misc-gBuffer.html'>gBuffer</a></code> (e.g. <code>buffer = list(width = 1000)</code>) (m) that is used to define a buffer around a Euclidean transect connecting the <code>origin</code> and <code>destination</code>. (This option can only be implemented for a single <code>origin</code> and <code>destination</code> pair.) The <code>surface</code> is then cropped to the extent of this buffer before the least-cost algorithms are implemented. This may be useful for large rasters to reduce memory requirements and/or computation time.</p></td>
    </tr>
    <tr>
      <th>aggregate</th>
      <td><p>(optional) A named list of arguments, passed to <code><a href='https://rdrr.io/pkg/raster/man/aggregate.html'>aggregate</a></code>, to aggregate raster cells before the least-cost algorithms are implemented. This may be useful for large rasters to reduce memory requirements and/or computation time.</p></td>
    </tr>
    <tr>
      <th>mask</th>
      <td><p>(optional) A Raster or Spatial <code><a href='https://rdrr.io/pkg/raster/man/mask.html'>mask</a></code> that is used to prevent movement over `impossible' areas on the <code>surface</code>. This must also lie on a planar surface (i.e., Universal Transverse Mercator projection). For example, for marine animals, <code>mask</code> might be a <code><a href='https://rdrr.io/pkg/sp/man/SpatialPolygons.html'>SpatialPolygonsDataFrame</a></code> which defines the coastline. The effect of the <code>mask</code> depends on <code>mask_inside</code> (see below).</p></td>
    </tr>
    <tr>
      <th>mask_inside</th>
      <td><p>A logical input that defines whether or not to mask the <code>surface</code> inside (<code>TRUE</code>) or outside (<code>FALSE</code>) of the <code>mask</code> (see <code><a href='mask_io.html'>mask_io</a></code>).</p></td>
    </tr>
    <tr>
      <th>plot</th>
      <td><p>A logical input that defines whether or not to plot the inputted and processed surfaces. If <code>TRUE</code>, the inputted and processed plots are produced side-by-side. For the inputted surface, the <code>mask</code> and the region selected (via <code>crop</code> and/or <code>buffer</code>) are shown along with the <code>origin</code> and <code>destination</code>. For the processed surface, the surface and the <code>origin</code> and <code>destination</code> are shown, along with the shortest path(s) (if and once computed: see <code>goal</code>). This is useful for checking that any <code>surface</code> processing steps have been applied correctly and the <code>origin</code> and <code>destination</code> are positioned correctly on the <code>surface</code>.</p></td>
    </tr>
    <tr>
      <th>goal</th>
      <td><p>An integer that defines the output of the function: <code>goal = 1</code> computes shortest distances, <code>goal = 2</code> computes shortest paths and <code>goal = 3</code> computes both shortest paths and the corresponding distances. Note that <code>goal = 3</code> results in least-cost algorithms being implemented twice, which will be inefficient for large problems; in this case, use <code>goal = 2</code> to compute shortest paths and then calculate their distance using outputs returned by the function (see Value).</p></td>
    </tr>
    <tr>
      <th>combination</th>
      <td><p>A character string (<code>"pair"</code> or <code>"matrix"</code>) that defines whether or not to compute shortest distances/paths for (a) each sequential <code>origin</code> and <code>destination</code> pair of coordinates (<code>combination = "pair"</code>) or (b) all combinations of <code>origin</code> and <code>destination</code> coordinates (<code>combination = "matrix"</code>). This argument is only applicable if there is more than one <code>origin</code> and <code>destination</code>. For <code>combination = "pair"</code>, the number of <code>origin</code> and <code>destination</code> coordinates needs to be the same, since each <code>origin</code> is matched with each <code>destination</code>.</p></td>
    </tr>
    <tr>
      <th>method</th>
      <td><p>A character string (<code>"cppRouting"</code> or <code>"gdistance"</code>) that defines the method used to compute the shortest distances between the <code>origin</code> and the <code>destination</code>. <code>"cppRouting"</code> is the default <code>method</code>. Under this option, functions in the <code><a href='https://rdrr.io/pkg/cppRouting/man/cppRouting-package.html'>cppRouting</a></code> package are used to compute the shortest paths (<code><a href='https://rdrr.io/pkg/cppRouting/man/get_path_pair.html'>get_path_pair</a></code> or <code><a href='https://rdrr.io/pkg/cppRouting/man/get_multi_paths.html'>get_multi_paths</a></code> for each pair of coordinates or for all combinations of coordinates, respectively) and/or distances (<code><a href='https://rdrr.io/pkg/cppRouting/man/get_distance_pair.html'>get_distance_pair</a></code> or <code><a href='https://rdrr.io/pkg/cppRouting/man/get_distance_matrix.html'>get_distance_matrix</a></code>). This package implements functions written in C++ and massively outperforms the other <code>method = "gdistance"</code> for large problems. Otherwise, if <code>method = "gdistance"</code>, functions in the <code><a href='https://rdrr.io/pkg/gdistance/man/gdistance.html'>gdistance</a></code> are called iteratively to compute shortest paths (via <code><a href='https://rdrr.io/pkg/gdistance/man/shortestPath.html'>shortestPath</a></code>) or distances (via <code><a href='https://rdrr.io/pkg/gdistance/man/costDistance-methods.html'>costDistance</a></code>).</p></td>
    </tr>
    <tr>
      <th>cppRouting_algorithm</th>
      <td><p>A character string that defines the algorithm used to compute shortest paths or distances. This is only applicable if <code>method = "cppRouting"</code>: <code>method = "gdistance"</code> implements Dijkstra's algorithm only. For shortest paths or their distances between pairs of coordinates, the options are <code>"Dijkstra"</code>, <code>"bi"</code>, <code>"A*"</code> or <code>"NBA"</code> for the uni-directional Dijkstra, bi-directional Dijkstra, A star unidirectional search or new bi-directional A star algorithms respectively (see <code><a href='https://rdrr.io/pkg/cppRouting/man/get_path_pair.html'>get_path_pair</a></code> or <code><a href='https://rdrr.io/pkg/cppRouting/man/get_distance_pair.html'>get_distance_pair</a></code>). For shortest paths between all combinations of coordinates, <code>cppRouting_algorithm</code> is ignored and the Dijkstra algorithm is implemented recursively. For shortest distances between all combinations of coordinates, the options are <code>"phast"</code> or <code>"mch"</code> (see <code><a href='https://rdrr.io/pkg/cppRouting/man/get_distance_matrix.html'>get_distance_matrix</a></code>).</p></td>
    </tr>
    <tr>
      <th>use_all_cores, cl, varlist</th>
      <td><p>Parallelisation options for <code>method = "cppRouting"</code> (<code>use_all_cores</code>) or <code>method = "gdistance"</code> (<code>cl</code> and <code>varlist</code>) respectively. If <code>method = "cppRouting"</code>, parallelisation is implemented via <code>use_all_cores</code> for computing shortest distances only (not computing shortest paths). <code>use_all_cores</code> is a logical input that defines whether or not to use all cores for computing shortest distance(s). If <code>method = "gdistance"</code>, parallelisation is implemented via <code>cl</code> and <code>varlist</code> for both shortest paths and distances function calls. <code>cl</code> is (a) a cluster object from <code><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></code> or (b) an integer that defines the number of child processes. <code>varlist</code> is a character vector of variables for export (see <code><a href='cl.html'>cl_export</a></code>). Exported variables must be located in the global environment. If a cluster is supplied, the connection to the cluster is closed within the function (see <code><a href='cl.html'>cl_stop</a></code>). For further information, see <code><a href='cl.html'>cl_lapply</a></code> and <code><a href='flapper-tips-parallel.html'>flapper-tips-parallel</a></code>.</p></td>
    </tr>
    <tr>
      <th>check</th>
      <td><p>A logical input that defines whether or not to check function inputs. If <code>TRUE</code>, internal checks are implemented to check user-inputs and whether or not inputted coordinates are in appropriate places on the processed <code>surface</code> (for instance, to ensure inputted coordinates do not lie over masked areas). This helps to prevent intractable error messages. If <code>FALSE</code>, these checks are not implemented, so function progress may be faster initially (especially for large <code>origin</code>/<code>destination</code> coordinate matrices).</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>A logical input that defines whether or not to print messages to the console to monitor function progress. This is especially useful with a large <code>surface</code> since the algorithms are computationally intensive.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    
<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>A named list</h3>
<p>The function returns a named list. The most important element(s) of this list are `path_lcp' and/or `dist_lcp', the shortest path(s) and/or distance(s) (m) between <code>origin</code> and <code>destination</code> coordinate pairs/combinations. `path_lcp' is returned if <code>goal = 2</code> or <code>goal = 3</code> and `dist_lcp' is returned if <code>goal = 1</code> or <code>goal = 3</code>. `path_lcp' contains (a) a dataframe with the cells comprising each path (`cells'), (b) a named list containing a <code><a href='https://rdrr.io/pkg/sp/man/SpatialLines.html'>SpatialLines</a></code> object for each path (`SpatialLines') and (c) a named list of matrices of the coordinates of each path (`coordinates'). `dist_lcp' is a (a) numeric vector or (b) matrix with the distances (m) between each pair or combination of coordinates respectively. If `dist_lcp' is computed, `dist_euclid', the Euclidean distances (m) between the <code>origin</code> and <code>destination</code>, is also returned for comparison.</p>

<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Common elements</h3>
<p>Other elements of the list record important outputs at sequential stages of the algorithm's progression. These include the following elements: `args', a named list of user inputs; `time', a dataframe that defines the times of sequential stages in the algorithm's progression; `surface', the surface over which shortest distances are computed (this may differ from the inputted surface if any of the processing options, such as <code>crop</code>, have been implemented); `surface_param', a named list that defines the cell IDs, the number of rows, the number of columns, the coordinates of the implemented surface and the cell IDs of the <code>origin</code> and <code>destination</code> nodes; `cost', a named list of arguments that defines the distances (m) between connected cells under a rook's or bishop's movement (`dist_rook' and `dist_bishop'), the planar and vertical distances between connected cells (`dist_planar' and `dist_vertical') and the total distance between connected cells (`dist_total'); and `cppRouting_param' or `gdistance_param', a named list of arguments used to compute shortest paths/distances via <code><a href='https://rdrr.io/pkg/cppRouting/man/cppRouting-package.html'>cppRouting</a></code> or <code><a href='https://rdrr.io/pkg/gdistance/man/gdistance.html'>gdistance</a></code> (see below).</p>

<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method-specific elements</h3>
<p>If <code>method = "cppRouting"</code>, the `cppRouting_param' list contains a named list of arguments passed to <code><a href='https://rdrr.io/pkg/cppRouting/man/makegraph.html'>makegraph</a></code> (`makegraph_param') as well as <code><a href='https://rdrr.io/pkg/cppRouting/man/get_path_pair.html'>get_path_pair</a></code> (`get_path_pair_param') or <code><a href='https://rdrr.io/pkg/cppRouting/man/get_multi_paths.html'>get_multi_paths</a></code> (`get_multi_paths_param') and/or <code><a href='https://rdrr.io/pkg/cppRouting/man/get_distance_pair.html'>get_distance_pair</a></code> (`get_distance_pair_param') or <code><a href='https://rdrr.io/pkg/cppRouting/man/get_distance_matrix.html'>get_distance_matrix</a></code> (`get_distance_matrix_param'), depending on whether or not shortest paths and/or distances have been computed (see <code>goal</code>) and whether or not shortest paths/distances have been computed for each pair of coordinates or all combinations of coordinates. If <code>method = "gdistance"</code>, this list contains a named list of arguments passed iteratively, for each pair/combination of coordinates, to <code><a href='https://rdrr.io/pkg/gdistance/man/shortestPath.html'>shortestPath</a></code> (`shortestPath_param') or <code><a href='https://rdrr.io/pkg/gdistance/man/costDistance-methods.html'>costDistance</a></code> (`costDistance_param'). This includes an object of class TransitionLayer (see <code><a href='https://rdrr.io/pkg/gdistance/man/Transition-classes.html'>Transition-classes</a></code>), in which the <code>transitionMatrix</code> slot contains a (sparse) matrix that defines the ease of moving between connected cells (the reciprocal of the `dist_total' matrix).</p>

<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Plot</h3>
<p>If <code>plot = TRUE</code>, a plot is also produced of the inputted and processed surfaces that are used in the calculations, along with the shortest path(s) (if and once computed).</p>

    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    
<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Methods</h3>
<p>This function was motivated by the need to determine the shortest paths and their distances between points for benthic animals, which must move over the seabed to navigate from A to B. For these animals, especially in areas with heterogeneous bathymetric landscapes and/or coastline, the shortest path that an individual must travel to move from A and B may differ substantially from the Euclidean path that is often used as a proxy for distance in biological studies. However, this function can still be used in situations where the surface over which an individual must move is irrelevant (e.g., for a pelagic animal), by supplying a flat surface; then shortest paths/distances simply depend on the planar distances between locations and any barriers (e.g., the coastline). (However, this process will be somewhat inefficient.)</p>
<p>The function conceptualises an object moving across a landscape as a queen on a chessboard which can move, in eight directions around its current position, across this surface. Given the potentially large number of possible paths between an <code>origin</code> and <code>destination</code>, the surface may be reduced in extent or size before the game begins. To determine shortest path/distance over the surface between each <code>origin</code> and <code>destination</code> pair/combination, the function first considers the distance that an object must travel between pairs of connected cells. This depends on the planar distances between cells and their differences in elevation. Planar distances (\(d_p\), m) depend on the movement type: under a rook's movement (i.e., horizontally or vertically), the distance (\(d_{p,r}\)) between connected cells is extracted from the raster's resolution (which is assumed to be identical in the x and y directions); under a bishop's movement (i.e., diagonally), the distance between connected cells \(d_{p,b}\) is given by Pythagoras' Theorem: \(d_{p,b} = \sqrt{(d_{p, r}^2 + d_{p, r}^2)}\). Vertical distances (\(d_v\), m) are simply the differences in height between cells. The total distance (\(d_t\)) between any two connected cells is a combination of these distances given by Pythagoras' Theorem: \(d_t = \sqrt{(d_p^2 + d_v^2)}\). These distances are taken to define the `cost' of movement between connected cells. Thus, `costs' are symmetric (i.e., the cost of moving from A to B equals the cost of moving from B to A).</p>
<p>This cost surface is then used to compute the shortest path and/or distance of the shortest path between each <code>origin</code> and <code>destination</code> pair/combination using functions in the <code><a href='https://rdrr.io/pkg/cppRouting/man/cppRouting-package.html'>cppRouting</a></code> or <code><a href='https://rdrr.io/pkg/gdistance/man/gdistance.html'>gdistance</a></code> package. The functions implemented depend on the <code>goal</code> (i.e., whether the aim is to compute shortest paths, shortest distances or both) and, if there is more than one <code>origin</code>/<code>destination</code>, the <code>combination</code> type (i.e., whether to compute shortest paths/distances for each sequential pair of coordinates or all possible combinations of coordinates).</p>

<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Warnings</h3>
<p>The function returns a warning produced by <code><a href='https://rdrr.io/pkg/gdistance/man/transition.html'>transition</a></code> which is implemented to facilitate the definition of the cost surface, before shortest paths/distances are computed by either method: `In .TfromR(x, transitionFunction, directions, symm) : transition function gives negative values'. This warning arises because the height differences between connecting cells can be negative. It can be safely ignored.</p>

    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Edward Lavender</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'>#### Example types</span>
<span class='co'># Shortest distances between a single origin and a single destination</span>
<span class='co'># Shortest paths between a single origin and a single destination</span>
<span class='co'># Shortest distances/paths between origin/destination pairs</span>
<span class='co'># Shortest distances/paths between all origin/destination combinations</span>

<span class='co'>#### Simulate a hypothetical landscape</span>
<span class='co'># Define a miniature, blank landscape with appropriate dimensions</span>
<span class='va'>proj_utm</span> <span class='op'>&lt;-</span> <span class='fu'>sp</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/sp/man/CRS-class.html'>CRS</a></span><span class='op'>(</span>SRS_string <span class='op'>=</span> <span class='st'>"EPSG:32629"</span><span class='op'>)</span>
<span class='va'>r</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></span><span class='op'>(</span>nrows <span class='op'>=</span> <span class='fl'>3</span>, ncols <span class='op'>=</span> <span class='fl'>3</span>,
                    crs <span class='op'>=</span> <span class='va'>proj_utm</span>,
                    resolution <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>5</span>, <span class='fl'>5</span><span class='op'>)</span>,
                    ext <span class='op'>=</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>15</span>, <span class='fl'>0</span>, <span class='fl'>15</span><span class='op'>)</span><span class='op'>)</span>
<span class='co'># Define a matrix of hypothetical values for the landscape</span>
<span class='va'>mat</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>5</span>, <span class='fl'>10</span>, <span class='fl'>3</span>,
                <span class='fl'>2</span>, <span class='fl'>1</span>, <span class='fl'>4</span>,
                <span class='fl'>5</span>, <span class='fl'>6</span>, <span class='fl'>6</span><span class='op'>)</span>, ncol <span class='op'>=</span> <span class='fl'>3</span>, nrow <span class='op'>=</span> <span class='fl'>3</span>, byrow <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
<span class='va'>r</span><span class='op'>[</span><span class='op'>]</span> <span class='op'>&lt;-</span> <span class='va'>mat</span>
<span class='co'># Visualise simulated landscape</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>r</span><span class='op'>)</span>
</div><div class='input'><span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/text.html'>text</a></span><span class='op'>(</span><span class='va'>r</span><span class='op'>)</span>
</div><div class='img'><img src='lcp_over_surface-1.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'># Extract coordinates of cells</span>
<span class='va'>rxy</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/xyFromCell.html'>coordinates</a></span><span class='op'>(</span><span class='va'>r</span><span class='op'>)</span>


<span class='co'>############################################################################</span>
<span class='co'>#### Shortest distances between a single origin and a single destination</span>

<span class='co'>#### Example (1): Find the distance between a single origin and destination</span>
<span class='co'># ... using the "cppRouting" method:</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:55)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:55) after ~0 minutes. </div><div class='input'><span class='co'># Extract shortest distance</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 7.071068</div><div class='input'>
<span class='co'>#### Example (1) continued: An explanation of function outputs</span>
<span class='co'># The function returns a list:</span>
<span class='co'># The 'args' element simply contains all inputted arguments</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>args</span>
</div><div class='output co'>#&gt; $origin
#&gt;        x    y
#&gt; [1,] 2.5 12.5
#&gt; 
#&gt; $destination
#&gt;        x    y
#&gt; [1,] 7.5 12.5
#&gt; 
#&gt; $surface
#&gt; class      : RasterLayer 
#&gt; dimensions : 3, 3, 9  (nrow, ncol, ncell)
#&gt; resolution : 5, 5  (x, y)
#&gt; extent     : 0, 15, 0, 15  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 1, 10  (min, max)
#&gt; 
#&gt; 
#&gt; $crop
#&gt; NULL
#&gt; 
#&gt; $buffer
#&gt; NULL
#&gt; 
#&gt; $aggregate
#&gt; NULL
#&gt; 
#&gt; $mask
#&gt; NULL
#&gt; 
#&gt; $mask_inside
#&gt; [1] TRUE
#&gt; 
#&gt; $plot
#&gt; [1] TRUE
#&gt; 
#&gt; $goal
#&gt; [1] 1
#&gt; 
#&gt; $combination
#&gt; [1] "pair"
#&gt; 
#&gt; $method
#&gt; [1] "cppRouting"
#&gt; 
#&gt; $cppRouting_algorithm
#&gt; [1] "bi"
#&gt; 
#&gt; $cl
#&gt; NULL
#&gt; 
#&gt; $varlist
#&gt; NULL
#&gt; 
#&gt; $use_all_cores
#&gt; [1] FALSE
#&gt; 
#&gt; $check
#&gt; [1] TRUE
#&gt; 
#&gt; $verbose
#&gt; [1] TRUE
#&gt; </div><div class='input'><span class='co'># The 'surface' element contains the surface used to compute shortest distances</span>
<span class='co'># ... This may differ from $args$surface if cropped, buffered etc.</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>surface</span>
</div><div class='output co'>#&gt; class      : RasterLayer 
#&gt; dimensions : 3, 3, 9  (nrow, ncol, ncell)
#&gt; resolution : 5, 5  (x, y)
#&gt; extent     : 0, 15, 0, 15  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; source     : memory
#&gt; names      : layer 
#&gt; values     : 1, 10  (min, max)
#&gt; </div><div class='input'><span class='co'># The 'surface_param' element contains the cell IDs, number of rows, cells and coordinates</span>
<span class='co'># ... of this surface</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>surface_param</span>
</div><div class='output co'>#&gt; $cells
#&gt; [1] 1 2 3 4 5 6 7 8 9
#&gt; 
#&gt; $nrow
#&gt; [1] 3
#&gt; 
#&gt; $ncol
#&gt; [1] 3
#&gt; 
#&gt; $coordinates
#&gt;          x    y
#&gt;  [1,]  2.5 12.5
#&gt;  [2,]  7.5 12.5
#&gt;  [3,] 12.5 12.5
#&gt;  [4,]  2.5  7.5
#&gt;  [5,]  7.5  7.5
#&gt;  [6,] 12.5  7.5
#&gt;  [7,]  2.5  2.5
#&gt;  [8,]  7.5  2.5
#&gt;  [9,] 12.5  2.5
#&gt; 
#&gt; $origin_cell
#&gt; [1] 1
#&gt; 
#&gt; $destination_cell
#&gt; [1] 2
#&gt; </div><div class='input'><span class='co'># The 'cost' element is a list of objects that define the cost matrix:</span>
<span class='co'># ... 'dist_rook' and 'dist_bishop' are matrices which define the distance of planar</span>
<span class='co'># ... ... movement from one cell to any other cell under a rook's or bishop's movement.</span>
<span class='co'># ... ... For example, the planar distance of moving from cell 1 to cell 2 to is 5 m:</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>cost</span><span class='op'>$</span><span class='va'>dist_rook</span>
</div><div class='output co'>#&gt; 9 x 9 sparse Matrix of class "dsCMatrix"
#&gt;                        
#&gt;  [1,] . 5 . 5 . . . . .
#&gt;  [2,] 5 . 5 . 5 . . . .
#&gt;  [3,] . 5 . . . 5 . . .
#&gt;  [4,] 5 . . . 5 . 5 . .
#&gt;  [5,] . 5 . 5 . 5 . 5 .
#&gt;  [6,] . . 5 . 5 . . . 5
#&gt;  [7,] . . . 5 . . . 5 .
#&gt;  [8,] . . . . 5 . 5 . 5
#&gt;  [9,] . . . . . 5 . 5 .</div><div class='input'><span class='va'>out1</span><span class='op'>$</span><span class='va'>cost</span><span class='op'>$</span><span class='va'>dist_bishop</span>
</div><div class='output co'>#&gt; 9 x 9 sparse Matrix of class "dsCMatrix"
#&gt;                                                                              
#&gt;  [1,] .        .        .        .        7.071068 .        .        .       
#&gt;  [2,] .        .        .        7.071068 .        7.071068 .        .       
#&gt;  [3,] .        .        .        .        7.071068 .        .        .       
#&gt;  [4,] .        7.071068 .        .        .        .        .        7.071068
#&gt;  [5,] 7.071068 .        7.071068 .        .        .        7.071068 .       
#&gt;  [6,] .        7.071068 .        .        .        .        .        7.071068
#&gt;  [7,] .        .        .        .        7.071068 .        .        .       
#&gt;  [8,] .        .        .        7.071068 .        7.071068 .        .       
#&gt;  [9,] .        .        .        .        7.071068 .        .        .       
#&gt;               
#&gt;  [1,] .       
#&gt;  [2,] .       
#&gt;  [3,] .       
#&gt;  [4,] .       
#&gt;  [5,] 7.071068
#&gt;  [6,] .       
#&gt;  [7,] .       
#&gt;  [8,] .       
#&gt;  [9,] .       </div><div class='input'><span class='co'># ... 'dist_planar' gives the planar distance between connected cell combinations</span>
<span class='co'># ... ... under a queen's movements:</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>cost</span><span class='op'>$</span><span class='va'>dist_planar</span>
</div><div class='output co'>#&gt; 9 x 9 sparse Matrix of class "dsCMatrix"
#&gt;                                                                              
#&gt;  [1,] .        5.000000 .        5.000000 7.071068 .        .        .       
#&gt;  [2,] 5.000000 .        5.000000 7.071068 5.000000 7.071068 .        .       
#&gt;  [3,] .        5.000000 .        .        7.071068 5.000000 .        .       
#&gt;  [4,] 5.000000 7.071068 .        .        5.000000 .        5.000000 7.071068
#&gt;  [5,] 7.071068 5.000000 7.071068 5.000000 .        5.000000 7.071068 5.000000
#&gt;  [6,] .        7.071068 5.000000 .        5.000000 .        .        7.071068
#&gt;  [7,] .        .        .        5.000000 7.071068 .        .        5.000000
#&gt;  [8,] .        .        .        7.071068 5.000000 7.071068 5.000000 .       
#&gt;  [9,] .        .        .        .        7.071068 5.000000 .        5.000000
#&gt;               
#&gt;  [1,] .       
#&gt;  [2,] .       
#&gt;  [3,] .       
#&gt;  [4,] .       
#&gt;  [5,] 7.071068
#&gt;  [6,] 5.000000
#&gt;  [7,] .       
#&gt;  [8,] 5.000000
#&gt;  [9,] .       </div><div class='input'><span class='co'># ... 'dist_vertical' gives the vertical distance between connected cells</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>cost</span><span class='op'>$</span><span class='va'>dist_vertical</span>
</div><div class='output co'>#&gt; 9 x 9 sparse Matrix of class "dsCMatrix"
#&gt;                              
#&gt;  [1,]  .  5  . -3 -4  . . . .
#&gt;  [2,]  5  . -7 -8 -9 -6 . . .
#&gt;  [3,]  . -7  .  . -2  1 . . .
#&gt;  [4,] -3 -8  .  . -1  . 3 4 .
#&gt;  [5,] -4 -9 -2 -1  .  3 4 5 5
#&gt;  [6,]  . -6  1  .  3  . . 2 2
#&gt;  [7,]  .  .  .  3  4  . . 1 .
#&gt;  [8,]  .  .  .  4  5  2 1 . .
#&gt;  [9,]  .  .  .  .  5  2 . . .</div><div class='input'><span class='co'># ... and 'dist_total' gives the total distance between connected cells</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>cost</span><span class='op'>$</span><span class='va'>dist_total</span>
</div><div class='output co'>#&gt; 9 x 9 sparse Matrix of class "dsCMatrix"
#&gt;                                                                        
#&gt;  [1,] .         7.071068 .         5.830952  8.124038 .        .       
#&gt;  [2,] 7.071068  .        8.602325 10.677078 10.295630 9.273618 .       
#&gt;  [3,] .         8.602325 .         .         7.348469 5.099020 .       
#&gt;  [4,] 5.830952 10.677078 .         .         5.099020 .        5.830952
#&gt;  [5,] 8.124038 10.295630 7.348469  5.099020  .        5.830952 8.124038
#&gt;  [6,] .         9.273618 5.099020  .         5.830952 .        .       
#&gt;  [7,] .         .        .         5.830952  8.124038 .        .       
#&gt;  [8,] .         .        .         8.124038  7.071068 7.348469 5.099020
#&gt;  [9,] .         .        .         .         8.660254 5.385165 .       
#&gt;                        
#&gt;  [1,] .        .       
#&gt;  [2,] .        .       
#&gt;  [3,] .        .       
#&gt;  [4,] 8.124038 .       
#&gt;  [5,] 7.071068 8.660254
#&gt;  [6,] 7.348469 5.385165
#&gt;  [7,] 5.099020 .       
#&gt;  [8,] .        5.000000
#&gt;  [9,] 5.000000 .       </div><div class='input'><span class='co'># 'dist_euclid' is the Euclidean distance between the origin and destination</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_euclid</span>
</div><div class='output co'>#&gt; [1] 5</div><div class='input'><span class='co'># 'cppRouting_param' contains lists of parameters passed to (a) makegraph() and (b)</span>
<span class='co'># ... get_distance_matrix() to compute shortest distances using cppRouting</span>
<span class='fu'>utils</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/utils/str.html'>str</a></span><span class='op'>(</span><span class='va'>out1</span><span class='op'>$</span><span class='va'>cppRouting_param</span><span class='op'>)</span>
</div><div class='output co'>#&gt; List of 2
#&gt;  $ makegraph_param        :List of 3
#&gt;   ..$ df      :'data.frame':	40 obs. of  3 variables:
#&gt;   .. ..$ from: int [1:40] 2 3 4 4 5 5 5 5 6 6 ...
#&gt;   .. ..$ to  : int [1:40] 1 2 1 2 1 2 3 4 2 3 ...
#&gt;   .. ..$ cost: num [1:40] 7.07 8.6 5.83 10.68 8.12 ...
#&gt;   ..$ directed: logi FALSE
#&gt;   ..$ coords  :'data.frame':	9 obs. of  3 variables:
#&gt;   .. ..$ node: int [1:9] 1 2 3 4 5 6 7 8 9
#&gt;   .. ..$ X   : num [1:9] 2.5 7.5 12.5 2.5 7.5 12.5 2.5 7.5 12.5
#&gt;   .. ..$ Y   : num [1:9] 12.5 12.5 12.5 7.5 7.5 7.5 2.5 2.5 2.5
#&gt;  $ get_distance_pair_param:List of 5
#&gt;   ..$ Graph    :List of 4
#&gt;   .. ..$ data  :'data.frame':	40 obs. of  3 variables:
#&gt;   .. .. ..$ from: int [1:40] 0 0 0 0 0 1 1 1 2 2 ...
#&gt;   .. .. ..$ to  : int [1:40] 8 1 2 3 4 0 3 4 8 0 ...
#&gt;   .. .. ..$ dist: num [1:40] 7.07 8.6 10.68 10.3 9.27 ...
#&gt;   .. ..$ coords:'data.frame':	9 obs. of  3 variables:
#&gt;   .. .. ..$ node: chr [1:9] "2" "3" "4" "5" ...
#&gt;   .. .. ..$ X   : num [1:9] 7.5 12.5 2.5 7.5 12.5 2.5 7.5 12.5 2.5
#&gt;   .. .. ..$ Y   : num [1:9] 12.5 12.5 7.5 7.5 7.5 2.5 2.5 2.5 12.5
#&gt;   .. ..$ nbnode: int 9
#&gt;   .. ..$ dict  :'data.frame':	9 obs. of  2 variables:
#&gt;   .. .. ..$ ref: chr [1:9] "2" "3" "4" "5" ...
#&gt;   .. .. ..$ id : int [1:9] 0 1 2 3 4 5 6 7 8
#&gt;   ..$ from     : num 1
#&gt;   ..$ to       : num 2
#&gt;   ..$ algorithm: chr "bi"
#&gt;   ..$ allcores : logi FALSE</div><div class='input'><span class='co'># 'time' records the time of each stage</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>time</span>
</div><div class='output co'>#&gt;                       event                time   serial_duration
#&gt; 1                     onset 2021-12-02 14:41:55 0.0511431694 secs
#&gt; 2         surface_processed 2021-12-02 14:41:55 0.0167269707 secs
#&gt; 3 transition_matrix_defined 2021-12-02 14:41:55 0.0028979778 secs
#&gt; 4             graph_defined 2021-12-02 14:41:55 0.0006589890 secs
#&gt; 5          dist_lcp_defined 2021-12-02 14:41:55 0.0002920628 secs
#&gt; 6                    finish 2021-12-02 14:41:55           NA secs</div><div class='input'>
<span class='co'>#### Example (2): Find the distance between a single origin and destination</span>
<span class='co'># ... using the "gdistance" method</span>
<span class='va'>out2</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span>
                         <span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:55)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-2.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:55) after ~0 minutes. </div><div class='input'><span class='co'># Extract distance</span>
<span class='va'>out2</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 7.071068</div><div class='input'><span class='co'># Elements of the returned list are the same apart from 'gdistance_param'</span>
<span class='co'># ... which contains a list of arguments passed to costDistance() to compute</span>
<span class='co'># ... shortest distances</span>
<span class='fu'>utils</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/utils/str.html'>str</a></span><span class='op'>(</span><span class='va'>out2</span><span class='op'>$</span><span class='va'>gdistance_param</span><span class='op'>)</span>
</div><div class='output co'>#&gt; List of 1
#&gt;  $ costDistance_param:List of 3
#&gt;   ..$ x         :Formal class 'TransitionLayer' [package "gdistance"] with 12 slots
#&gt;   .. .. ..@ title           : chr(0) 
#&gt;   .. .. ..@ extent          :Formal class 'Extent' [package "raster"] with 4 slots
#&gt;   .. .. .. .. ..@ xmin: num 0
#&gt;   .. .. .. .. ..@ xmax: num 15
#&gt;   .. .. .. .. ..@ ymin: num 0
#&gt;   .. .. .. .. ..@ ymax: num 15
#&gt;   .. .. ..@ rotated         : logi FALSE
#&gt;   .. .. ..@ rotation        :Formal class '.Rotation' [package "raster"] with 2 slots
#&gt;   .. .. .. .. ..@ geotrans: num(0) 
#&gt;   .. .. .. .. ..@ transfun:function ()  
#&gt;   .. .. ..@ ncols           : int 3
#&gt;   .. .. ..@ nrows           : int 3
#&gt;   .. .. ..@ crs             :Formal class 'CRS' [package "sp"] with 1 slot
#&gt;   .. .. .. .. ..@ projargs: chr "+proj=utm +zone=29 +datum=WGS84 +units=m +no_defs"
#&gt;   .. .. ..@ history         : list()
#&gt;   .. .. ..@ z               : list()
#&gt;   .. .. ..@ transitionMatrix:Formal class 'dsCMatrix' [package "Matrix"] with 7 slots
#&gt;   .. .. .. .. ..@ i       : int [1:20] 0 1 0 1 0 1 2 3 1 2 ...
#&gt;   .. .. .. .. ..@ p       : int [1:10] 0 0 1 2 4 8 11 13 17 20
#&gt;   .. .. .. .. ..@ Dim     : int [1:2] 9 9
#&gt;   .. .. .. .. ..@ Dimnames:List of 2
#&gt;   .. .. .. .. .. ..$ : NULL
#&gt;   .. .. .. .. .. ..$ : NULL
#&gt;   .. .. .. .. ..@ x       : num [1:20] 0.1414 0.1162 0.1715 0.0937 0.1231 ...
#&gt;   .. .. .. .. ..@ uplo    : chr "U"
#&gt;   .. .. .. .. ..@ factors : list()
#&gt;   .. .. ..@ transitionCells : int [1:9] 1 2 3 4 5 6 7 8 9
#&gt;   .. .. ..@ matrixValues    : chr "conductance"
#&gt;   ..$ fromCoords: num [1, 1:2] 2.5 12.5
#&gt;   .. ..- attr(*, "dimnames")=List of 2
#&gt;   .. .. ..$ : NULL
#&gt;   .. .. ..$ : chr [1:2] "x" "y"
#&gt;   ..$ toCoords  : num [1, 1:2] 7.5 12.5
#&gt;   .. ..- attr(*, "dimnames")=List of 2
#&gt;   .. .. ..$ : NULL
#&gt;   .. .. ..$ : chr [1:2] "x" "y"</div><div class='input'>
<span class='co'>#### Example (3): Find the distances between other origins and destinations</span>
<span class='co'>## Implement function to determine shortest distances:</span>
<span class='co'># shortest distance between cell 1 and 6 via gdistance</span>
<span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                 destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                 surface <span class='op'>=</span> <span class='va'>r</span>,
                 method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                 verbose <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-3.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; [1] 13.95499</div><div class='input'><span class='co'># shortest distance between cell 1 and 6 via cppRouting</span>
<span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                 destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                 surface <span class='op'>=</span> <span class='va'>r</span>,
                 method <span class='op'>=</span> <span class='st'>"cppRouting"</span>,
                 verbose <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; [1] 13.95499</div><div class='input'><span class='co'>## Compare to manually computed distances</span>
<span class='co'># The shortest distance from cell 1 to cell 6 is to move diagonally</span>
<span class='co'># ... from cell 1 to 5 and then 6.</span>
<span class='co'># Define planar distances of moving like a rook (d_pr) or bishop (d_pb)</span>
<span class='va'>d_pr</span> <span class='op'>&lt;-</span> <span class='fl'>5</span>
<span class='va'>d_pb</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>5</span><span class='op'>^</span><span class='fl'>2</span> <span class='op'>+</span> <span class='fl'>5</span><span class='op'>^</span><span class='fl'>2</span><span class='op'>)</span>
<span class='co'># Define total distance travelled along shortest path, as computed by the</span>
<span class='co'># ... algorithm to demonstrate we obtain the same value:</span>
<span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='op'>(</span><span class='fl'>5</span> <span class='op'>-</span> <span class='fl'>1</span><span class='op'>)</span><span class='op'>^</span><span class='fl'>2</span> <span class='op'>+</span> <span class='va'>d_pb</span><span class='op'>^</span><span class='fl'>2</span><span class='op'>)</span> <span class='op'>+</span> <span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='op'>(</span><span class='fl'>4</span> <span class='op'>-</span> <span class='fl'>1</span><span class='op'>)</span><span class='op'>^</span><span class='fl'>2</span> <span class='op'>+</span> <span class='va'>d_pr</span><span class='op'>^</span><span class='fl'>2</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 13.95499</div><div class='input'>
<span class='co'>#### Example (4): Find the shortest distances around NAs</span>
<span class='co'>## Force the 5th cell to be NA</span>
<span class='va'>rtmp</span> <span class='op'>&lt;-</span> <span class='va'>r</span>
<span class='va'>rtmp</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>]</span> <span class='op'>&lt;-</span> <span class='cn'>NA</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>rtmp</span><span class='op'>)</span>; <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/text.html'>text</a></span><span class='op'>(</span><span class='va'>rtmp</span><span class='op'>)</span>
</div><div class='img'><img src='lcp_over_surface-4.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'>## Compute shortest distances via algorithm:</span>
<span class='co'># Now compute shortest distances, which we can see have increased the distance</span>
<span class='co'># ... since movement through an NA cell is not allowed. Therefore, if this NA</span>
<span class='co'># ... reflects missing data, it may be appropriate to interpolate NAs using</span>
<span class='co'># ... surrounding cells (e.g., see raster::approxNA()) so that movement</span>
<span class='co'># ... is possible through these cells</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>rtmp</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                         verbose <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='input'><span class='va'>out2</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>rtmp</span>,
                         method <span class='op'>=</span> <span class='st'>"cppRouting"</span>,
                         verbose <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='img'><img src='lcp_over_surface-5.png' alt='' width='700' height='433' /></div><div class='input'><span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_lcp</span>; <span class='va'>out2</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 16.34469</div><div class='output co'>#&gt; [1] 16.34469</div><div class='input'><span class='co'>## Compare to manual calculations of shortest route:</span>
<span class='co'># Route option one: cell 1 to 2, 2 to 6</span>
<span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='op'>(</span><span class='fl'>5</span> <span class='op'>-</span> <span class='fl'>10</span><span class='op'>)</span><span class='op'>^</span><span class='fl'>2</span> <span class='op'>+</span> <span class='va'>d_pr</span><span class='op'>^</span><span class='fl'>2</span><span class='op'>)</span> <span class='op'>+</span> <span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='op'>(</span><span class='fl'>10</span> <span class='op'>-</span> <span class='fl'>4</span><span class='op'>)</span><span class='op'>^</span><span class='fl'>2</span> <span class='op'>+</span> <span class='va'>d_pb</span><span class='op'>^</span><span class='fl'>2</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 16.34469</div><div class='input'><span class='co'># Or, using the numbers computed in the dist_total object:</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>cost</span><span class='op'>$</span><span class='va'>dist_total</span><span class='op'>[</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>]</span> <span class='op'>+</span> <span class='va'>out1</span><span class='op'>$</span><span class='va'>cost</span><span class='op'>$</span><span class='va'>dist_total</span><span class='op'>[</span><span class='fl'>2</span>, <span class='fl'>6</span><span class='op'>]</span>
</div><div class='output co'>#&gt; [1] 16.34469</div><div class='input'><span class='co'>## Compare to effect of making a value in the landscape extremely large</span>
<span class='co'># In the same way, we can force the shortest path away from particular areas</span>
<span class='co'># ... by making the height of the landscape in those areas very large or Inf:</span>
<span class='va'>rtmp</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>]</span> <span class='op'>&lt;-</span> <span class='fl'>1e20</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>rtmp</span><span class='op'>)</span>; <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/text.html'>text</a></span><span class='op'>(</span><span class='va'>rtmp</span><span class='op'>)</span>
</div><div class='img'><img src='lcp_over_surface-6.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                 destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                 surface <span class='op'>=</span> <span class='va'>rtmp</span>,
                 method <span class='op'>=</span> <span class='st'>"cppRouting"</span>,
                 verbose <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; [1] 16.34469</div><div class='input'><span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                 destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                 surface <span class='op'>=</span> <span class='va'>rtmp</span>,
                 method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                 verbose <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-7.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; [1] 16.34469</div><div class='input'>
<span class='co'>#### Example (4): Find the distances between points on a real landscape</span>
<span class='co'>## We will use some example bathymetry data:</span>
<span class='va'>dat_gebco_oban</span> <span class='op'>&lt;-</span> <span class='fu'>prettyGraphics</span><span class='fu'>::</span><span class='va'><a href='https://edwardlavender.github.io/prettyGraphics/reference/dat_gebco.html'>dat_gebco</a></span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>dat_gebco_oban</span><span class='op'>)</span>
</div><div class='img'><img src='lcp_over_surface-8.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'>## Process bathymetry data before function implementation</span>
<span class='co'># (a) Define utm coordinates:</span>
<span class='va'>dat_gebco_utm</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/projectRaster.html'>projectRaster</a></span><span class='op'>(</span><span class='va'>dat_gebco_oban</span>, crs <span class='op'>=</span> <span class='va'>proj_utm</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/resolution.html'>res</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 257 463</div><div class='input'><span class='co'># (b) Resample so that the resolution in the x and y directions is identical</span>
<span class='va'>dat_gebco_utm_planar</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></span><span class='op'>(</span>crs <span class='op'>=</span> <span class='va'>proj_utm</span>,
                                       ext <span class='op'>=</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm</span><span class='op'>)</span>,
                                       resolution <span class='op'>=</span> <span class='fl'>250</span><span class='op'>)</span>
<span class='va'>dat_gebco_utm_planar</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/resample.html'>resample</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm</span>, <span class='va'>dat_gebco_utm_planar</span>, method <span class='op'>=</span> <span class='st'>"bilinear"</span><span class='op'>)</span>
<span class='co'># Examine processed raster</span>
<span class='va'>pp</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span>mfrow <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm</span>, main <span class='op'>=</span> <span class='st'>"UTM raster"</span><span class='op'>)</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar</span>, main <span class='op'>=</span> <span class='st'>"UTM raster with equal res"</span><span class='op'>)</span>
</div><div class='img'><img src='lcp_over_surface-9.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/par.html'>par</a></span><span class='op'>(</span><span class='va'>pp</span><span class='op'>)</span>
<span class='co'>## Define example origin and destination</span>
<span class='fu'><a href='https://rdrr.io/r/base/Random.html'>set.seed</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>)</span>
<span class='va'>dat_gebco_utm_planar_xy</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/xyFromCell.html'>coordinates</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar</span><span class='op'>)</span>
<span class='va'>index</span>       <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/sample.html'>sample</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>:</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/ncell.html'>nrow</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar_xy</span><span class='op'>)</span>, <span class='fl'>2</span><span class='op'>)</span>
<span class='va'>origin</span>      <span class='op'>&lt;-</span> <span class='va'>dat_gebco_utm_planar_xy</span><span class='op'>[</span><span class='va'>index</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>]</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>
<span class='va'>destination</span> <span class='op'>&lt;-</span> <span class='va'>dat_gebco_utm_planar_xy</span><span class='op'>[</span><span class='va'>index</span><span class='op'>[</span><span class='fl'>2</span><span class='op'>]</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>
<span class='co'>## Implement function to compute shortest distances</span>
<span class='va'>out_gebco1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"gdistance"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:56)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-10.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:56) after ~0 minutes. </div><div class='input'><span class='va'>out_gebco2</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                              method <span class='op'>=</span> <span class='st'>"cppRouting"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:56)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:56) after ~0 minutes. </div><div class='input'><span class='co'># Compare Euclidean and shortest distances</span>
<span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_euclid</span>; <span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 8902.247</div><div class='output co'>#&gt; [1] 9278.626</div><div class='input'><span class='va'>out_gebco2</span><span class='op'>$</span><span class='va'>dist_euclid</span>; <span class='va'>out_gebco2</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 8902.247</div><div class='output co'>#&gt; [1] 9278.626</div><div class='input'>
<span class='co'>#### Example (5A): Reduce the complexity of the landscape by cropping</span>
<span class='va'>ext</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar</span><span class='op'>)</span>
<span class='va'>ext</span><span class='op'>[</span><span class='fl'>3</span><span class='op'>]</span> <span class='op'>&lt;-</span> <span class='fl'>6255000</span>
<span class='va'>ext</span><span class='op'>[</span><span class='fl'>4</span><span class='op'>]</span> <span class='op'>&lt;-</span> <span class='fl'>6265000</span>
<span class='va'>out_gebco1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                               crop <span class='op'>=</span> <span class='va'>ext</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:56)... 
#&gt; ... Checking user inputs... 
#&gt; ... Cropping raster to inputted extent... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-11.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:57) after ~0 minutes. </div><div class='input'><span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 9278.626</div><div class='input'>
<span class='co'>#### Example (5B): Reduce the complexity of the landscape around a buffer</span>
<span class='va'>out_gebco1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                               buffer <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>width <span class='op'>=</span> <span class='fl'>1000</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:57)... 
#&gt; ... Checking user inputs... 
#&gt; ... Cropping raster to buffer zone around a Euclidean transect between the origin and destination... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-12.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:57) after ~0 minutes. </div><div class='input'><span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 9278.626</div><div class='input'>
<span class='co'>#### Example (5C): Reduce the complexity of the landscape via aggregation</span>
<span class='va'>out_gebco1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                               buffer <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>width <span class='op'>=</span> <span class='fl'>1000</span><span class='op'>)</span>,
                               aggregate <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>fact <span class='op'>=</span> <span class='fl'>5</span>, fun <span class='op'>=</span> <span class='va'>mean</span>, na.rm <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:57)... 
#&gt; ... Checking user inputs... 
#&gt; ... Cropping raster to buffer zone around a Euclidean transect between the origin and destination... 
#&gt; ... Aggregating raster... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-13.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:57) after ~0 minutes. </div><div class='input'><span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 10088.96</div><div class='input'>
<span class='co'>#### Example (6C): Implement a mask</span>
<span class='co'># Define coastline</span>
<span class='va'>dat_coast_around_oban</span> <span class='op'>&lt;-</span> <span class='fu'>prettyGraphics</span><span class='fu'>::</span><span class='va'><a href='https://edwardlavender.github.io/prettyGraphics/reference/dat_coast_around_oban.html'>dat_coast_around_oban</a></span>
<span class='va'>coastline</span> <span class='op'>&lt;-</span> <span class='fu'>sp</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/sp/man/spTransform.html'>spTransform</a></span><span class='op'>(</span><span class='va'>dat_coast_around_oban</span>, <span class='va'>proj_utm</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: NULL source CRS comment, falling back to PROJ string</span></div><div class='input'><span class='co'># Visualise bathymetry and coastline</span>
<span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/plot.html'>plot</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar</span><span class='op'>)</span>
</div><div class='input'><span class='fu'>raster</span><span class='fu'>::</span><span class='fu'>lines</span><span class='op'>(</span><span class='va'>coastline</span><span class='op'>)</span>
</div><div class='img'><img src='lcp_over_surface-14.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'># Define example origin and destination within the sea</span>
<span class='va'>origin</span>      <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>714000</span>, <span class='fl'>6260000</span><span class='op'>)</span>, ncol <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
<span class='va'>destination</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>721000</span>, <span class='fl'>6265000</span><span class='op'>)</span>, ncol <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
<span class='co'># Implement algorithm</span>
<span class='va'>out_gebco1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                               crop <span class='op'>=</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>coastline</span><span class='op'>)</span>,
                               mask <span class='op'>=</span> <span class='va'>coastline</span>,
                               mask_inside <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:57)... 
#&gt; ... Checking user inputs... 
#&gt; ... Cropping raster to inputted extent... 
#&gt; ... Masking raster... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:57) after ~0 minutes. </div><div class='input'><span class='va'>out_gebco2</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"cppRouting"</span>,
                               crop <span class='op'>=</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>coastline</span><span class='op'>)</span>,
                               mask <span class='op'>=</span> <span class='va'>coastline</span>,
                               mask_inside <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:57)... 
#&gt; ... Checking user inputs... 
#&gt; ... Cropping raster to inputted extent... 
#&gt; ... Masking raster... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='img'><img src='lcp_over_surface-15.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:57) after ~0 minutes. </div><div class='input'><span class='co'># Compare Euclidean and least-cost distances</span>
<span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_euclid</span>; <span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 8602.325</div><div class='output co'>#&gt; [1] 9071.48</div><div class='input'><span class='va'>out_gebco2</span><span class='op'>$</span><span class='va'>dist_euclid</span>; <span class='va'>out_gebco2</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 8602.325</div><div class='output co'>#&gt; [1] 9071.48</div><div class='input'>
<span class='co'>#### Example (7) Implement shortest distance algorithms in parallel:</span>
<span class='co'># With the default method ("cppRouting"), use use_all_cores = TRUE</span>
<span class='va'>out_gebco1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"cppRouting"</span>,
                               crop <span class='op'>=</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>coastline</span><span class='op'>)</span>,
                               mask <span class='op'>=</span> <span class='va'>coastline</span>,
                               mask_inside <span class='op'>=</span> <span class='cn'>TRUE</span>,
                               use_all_cores <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:57)... 
#&gt; ... Checking user inputs... 
#&gt; ... Cropping raster to inputted extent... 
#&gt; ... Masking raster... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:57) after ~0 minutes. </div><div class='input'><span class='co'># With method = "gdistance" use cl argument</span>
<span class='va'>out_gebco2</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"cppRouting"</span>,
                               crop <span class='op'>=</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>coastline</span><span class='op'>)</span>,
                               mask <span class='op'>=</span> <span class='va'>coastline</span>,
                               mask_inside <span class='op'>=</span> <span class='cn'>TRUE</span>,
                               cl <span class='op'>=</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:57)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; <span class='message'>'cl' or 'varlist' arguments ignored for method = 'cppRouting': use use_all_cores = TRUE instead.</span></div><div class='output co'>#&gt; ... Cropping raster to inputted extent... 
#&gt; ... Masking raster... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:58) after ~0.01 minutes. </div><div class='input'><span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_lcp</span>; <span class='va'>out_gebco2</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt; [1] 9071.48</div><div class='output co'>#&gt; [1] 9071.48</div><div class='input'>

<span class='co'>############################################################################</span>
<span class='co'>#### Shortest paths between a single origin and a single destination</span>

<span class='co'>#### Example (8) Shortest paths (goal = 2) only using default method</span>
<span class='co'># Implement function</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:58)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:58) after ~0 minutes. </div><div class='input'><span class='co'># The path is stored in path_lcp, This includes:</span>
<span class='co'># ... (a) a dataframe with the cells comprising each path:</span>
<span class='co'># ... (b) a SpatialLines object of the path</span>
<span class='co'># ... (c) a matrix of the coordinates of the path</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>path_lcp</span>
</div><div class='output co'>#&gt; $cells
#&gt;   path_id path origin destination cell
#&gt; 1       1  1-6      1           6    1
#&gt; 2       1  1-6      1           6    5
#&gt; 3       1  1-6      1           6    6
#&gt; 
#&gt; $SpatialLines
#&gt; $SpatialLines$`1`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; 
#&gt; $coordinates
#&gt; $coordinates$`1`
#&gt;         x    y
#&gt; [1,]  2.5 12.5
#&gt; [2,]  7.5  7.5
#&gt; [3,] 12.5  7.5
#&gt; 
#&gt; </div><div class='input'><span class='co'># For method = "cppRouting", paths between pairs of coordinates are computed</span>
<span class='co'># ... by cppRouting::get_path_pair(), the arguments of which are retained in</span>
<span class='co'># ... this list:</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>cppRouting_param</span><span class='op'>$</span><span class='va'>get_path_pair_param</span>
</div><div class='output co'>#&gt; $Graph
#&gt; $Graph$data
#&gt;    from to      dist
#&gt; 1     0  8  7.071068
#&gt; 2     0  1  8.602325
#&gt; 3     0  2 10.677078
#&gt; 4     0  3 10.295630
#&gt; 5     0  4  9.273618
#&gt; 6     1  0  8.602325
#&gt; 7     1  3  7.348469
#&gt; 8     1  4  5.099020
#&gt; 9     2  8  5.830952
#&gt; 10    2  0 10.677078
#&gt; 11    2  3  5.099020
#&gt; 12    2  5  5.830952
#&gt; 13    2  6  8.124038
#&gt; 14    3  8  8.124038
#&gt; 15    3  0 10.295630
#&gt; 16    3  1  7.348469
#&gt; 17    3  2  5.099020
#&gt; 18    3  4  5.830952
#&gt; 19    3  5  8.124038
#&gt; 20    3  6  7.071068
#&gt; 21    3  7  8.660254
#&gt; 22    4  0  9.273618
#&gt; 23    4  1  5.099020
#&gt; 24    4  3  5.830952
#&gt; 25    4  6  7.348469
#&gt; 26    4  7  5.385165
#&gt; 27    5  2  5.830952
#&gt; 28    5  3  8.124038
#&gt; 29    5  6  5.099020
#&gt; 30    6  2  8.124038
#&gt; 31    6  3  7.071068
#&gt; 32    6  4  7.348469
#&gt; 33    6  5  5.099020
#&gt; 34    6  7  5.000000
#&gt; 35    7  3  8.660254
#&gt; 36    7  4  5.385165
#&gt; 37    7  6  5.000000
#&gt; 38    8  0  7.071068
#&gt; 39    8  2  5.830952
#&gt; 40    8  3  8.124038
#&gt; 
#&gt; $Graph$coords
#&gt;   node    X    Y
#&gt; 2    2  7.5 12.5
#&gt; 3    3 12.5 12.5
#&gt; 4    4  2.5  7.5
#&gt; 5    5  7.5  7.5
#&gt; 6    6 12.5  7.5
#&gt; 7    7  2.5  2.5
#&gt; 8    8  7.5  2.5
#&gt; 9    9 12.5  2.5
#&gt; 1    1  2.5 12.5
#&gt; 
#&gt; $Graph$nbnode
#&gt; [1] 9
#&gt; 
#&gt; $Graph$dict
#&gt;   ref id
#&gt; 1   2  0
#&gt; 2   3  1
#&gt; 3   4  2
#&gt; 4   5  3
#&gt; 5   6  4
#&gt; 6   7  5
#&gt; 7   8  6
#&gt; 8   9  7
#&gt; 9   1  8
#&gt; 
#&gt; 
#&gt; $from
#&gt; [1] 1
#&gt; 
#&gt; $to
#&gt; [1] 6
#&gt; 
#&gt; $algorithm
#&gt; [1] "bi"
#&gt; 
#&gt; $constant
#&gt; [1] 1
#&gt; 
#&gt; $keep
#&gt; NULL
#&gt; 
#&gt; $long
#&gt; [1] TRUE
#&gt; </div><div class='input'><span class='co'># Note the path is also added to the plot produced, if plot = TRUE.</span>

<span class='co'>#### Example (9) Shortest distances and paths (goal = 3) using default method</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:58)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='img'><img src='lcp_over_surface-16.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:58) after ~0 minutes. </div><div class='input'><span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_lcp</span>; <span class='va'>out1</span><span class='op'>$</span><span class='va'>path_lcp</span>
</div><div class='output co'>#&gt; [1] 13.95499</div><div class='output co'>#&gt; $cells
#&gt;   path_id path origin destination cell
#&gt; 1       1  1-6      1           6    1
#&gt; 2       1  1-6      1           6    5
#&gt; 3       1  1-6      1           6    6
#&gt; 
#&gt; $SpatialLines
#&gt; $SpatialLines$`1`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; 
#&gt; $coordinates
#&gt; $coordinates$`1`
#&gt;         x    y
#&gt; [1,]  2.5 12.5
#&gt; [2,]  7.5  7.5
#&gt; [3,] 12.5  7.5
#&gt; 
#&gt; </div><div class='input'>
<span class='co'>#### Example (10) Shortest distances and paths (goal = 3) via gdistance</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:58)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:58) after ~0 minutes. </div><div class='input'><span class='co'># As above, paths are stored in path_lcp and distances in dist_lcp</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>path_lcp</span>
</div><div class='output co'>#&gt; $cells
#&gt;   path_id path origin destination cell
#&gt; 1       1  1-6      1           6    1
#&gt; 2       1  1-6      1           6    5
#&gt; 3       1  1-6      1           6    6
#&gt; 
#&gt; $SpatialLines
#&gt; $SpatialLines$`1`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; 
#&gt; $coordinates
#&gt; $coordinates$`1`
#&gt;         x    y
#&gt; [1,]  2.5 12.5
#&gt; [2,]  7.5  7.5
#&gt; [3,] 12.5  7.5
#&gt; 
#&gt; </div><div class='input'><span class='co'># For method = "gdistance", paths between pairs of coordinates are computed</span>
<span class='co'># ... by repeated calls to gdistance::shortestPath(), for each pair of coordinates</span>
<span class='co'># ... in the following list of arguments:</span>
<span class='va'>out1</span><span class='op'>$</span><span class='va'>gdistance_param</span><span class='op'>$</span><span class='va'>shortestPath_param</span>
</div><div class='output co'>#&gt; $x
#&gt; class      : TransitionLayer 
#&gt; dimensions : 3, 3, 9  (nrow, ncol, ncell)
#&gt; resolution : 5, 5  (x, y)
#&gt; extent     : 0, 15, 0, 15  (xmin, xmax, ymin, ymax)
#&gt; crs        : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; values      : conductance 
#&gt; matrix class: dsCMatrix 
#&gt; 
#&gt; $fromCoords
#&gt;        x    y
#&gt; [1,] 2.5 12.5
#&gt; 
#&gt; $toCoords
#&gt;         x   y
#&gt; [1,] 12.5 7.5
#&gt; </div><div class='input'>
<span class='co'>#### Example (11): Parallelisation proceeds as described above via</span>
<span class='co'># ... use_all_cores or cl arguments. For cppRouting, parallelisation</span>
<span class='co'># ... is only implemented for distance calculations (so not if goal = 2),</span>
<span class='co'># ... while parallelisation is implemented for both distance and shortest</span>
<span class='co'># ... paths for method = "gdistance"</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         use_all_cores <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:58)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:41:58) after ~0 minutes. </div><div class='input'><span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>2</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                         cl <span class='op'>=</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:41:58)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:01) after ~0.05 minutes. </div><div class='input'><span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                         cl <span class='op'>=</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:01)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:04) after ~0.05 minutes. </div><div class='input'>

<span class='co'>############################################################################</span>
<span class='co'>#### Shortest distances/paths between origin/destination pairs</span>

<span class='co'>#### Example (12): Shortest distances/paths computed in sequence:</span>
<span class='co'># cppRouting method</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>:</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:04)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='img'><img src='lcp_over_surface-17.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:04) after ~0 minutes. </div><div class='input'><span class='co'># gdistance method</span>
<span class='va'>out2</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>:</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:04)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:04) after ~0 minutes. </div><div class='input'><span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_lcp</span>; <span class='va'>out1</span><span class='op'>$</span><span class='va'>path_lcp</span>
</div><div class='output co'>#&gt; [1] 8.124038 9.273618</div><div class='output co'>#&gt; $cells
#&gt;   path_id path origin destination cell
#&gt; 1       1  1-5      1           5    1
#&gt; 2       1  1-5      1           5    5
#&gt; 3       2  2-6      2           6    2
#&gt; 4       2  2-6      2           6    6
#&gt; 
#&gt; $SpatialLines
#&gt; $SpatialLines$`1`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; $SpatialLines$`2`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 7.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; 
#&gt; $coordinates
#&gt; $coordinates$`1`
#&gt;        x    y
#&gt; [1,] 2.5 12.5
#&gt; [2,] 7.5  7.5
#&gt; 
#&gt; $coordinates$`2`
#&gt;         x    y
#&gt; [1,]  7.5 12.5
#&gt; [2,] 12.5  7.5
#&gt; 
#&gt; </div><div class='input'><span class='va'>out2</span><span class='op'>$</span><span class='va'>dist_lcp</span>; <span class='va'>out2</span><span class='op'>$</span><span class='va'>path_lcp</span>
</div><div class='output co'>#&gt; [1] 8.124038 9.273618</div><div class='output co'>#&gt; $cells
#&gt;   path_id path origin destination cell
#&gt; 1       1  1-5      1           5    1
#&gt; 2       1  1-5      1           5    5
#&gt; 3       2  2-6      2           6    2
#&gt; 4       2  2-6      2           6    6
#&gt; 
#&gt; $SpatialLines
#&gt; $SpatialLines$`1`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; $SpatialLines$`2`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 7.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; 
#&gt; $coordinates
#&gt; $coordinates$`1`
#&gt;        x    y
#&gt; [1,] 2.5 12.5
#&gt; [2,] 7.5  7.5
#&gt; 
#&gt; $coordinates$`2`
#&gt;         x    y
#&gt; [1,]  7.5 12.5
#&gt; [2,] 12.5  7.5
#&gt; 
#&gt; </div><div class='input'>
<span class='co'>#### Example (13): Shortest distances/paths computed in parallel:</span>
<span class='co'># cppRouting method for goal 3</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>:</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         use_all_cores <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:04)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing bi algorithm to compute least-cost distance(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... ... Implementing bi algorithm to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='message'>Running bidirectional Dijkstra...</span></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:04) after ~0 minutes. </div><div class='input'><span class='co'># gdistance method for goal 2</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>:</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>2</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                         cl <span class='op'>=</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:04)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:08) after ~0.07 minutes. </div><div class='input'><span class='co'># gdistance method for goal 3</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>:</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                         cl <span class='op'>=</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:08)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:12) after ~0.07 minutes. </div><div class='input'>

<span class='co'>############################################################################</span>
<span class='co'>#### Shortest distances/paths between all origin/destination combinations</span>

<span class='co'>#### Example (14) Compute all combinations via combination = "matrix"</span>
<span class='co'># cppRouting goal 3</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>:</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         cppRouting_algorithm <span class='op'>=</span> <span class='st'>"phast"</span>,
                         combination <span class='op'>=</span> <span class='st'>"matrix"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:12)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-18.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing phast algorithm to compute least-cost distance(s)... 
#&gt; ... .... Implementing Dijkstra's algorithm recursively to compute least-cost paths(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:12) after ~0 minutes. </div><div class='input'><span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_euclid</span>; <span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_lcp</span>; <span class='va'>out1</span><span class='op'>$</span><span class='va'>path_lcp</span>
</div><div class='output co'>#&gt;          5         6
#&gt; 1 7.071068 11.180340
#&gt; 2 5.000000  7.071068</div><div class='output co'>#&gt;           5         6
#&gt; 1  8.124038 13.954990
#&gt; 2 10.295630  9.273618</div><div class='output co'>#&gt; $cells
#&gt;   path_id path origin destination cell
#&gt; 1       1  1-5      1           5    1
#&gt; 2       1  1-5      1           5    5
#&gt; 3       2  1-6      1           6    1
#&gt; 4       2  1-6      1           6    5
#&gt; 5       2  1-6      1           6    6
#&gt; 6       3  2-5      2           5    2
#&gt; 7       3  2-5      2           5    5
#&gt; 8       4  2-6      2           6    2
#&gt; 9       4  2-6      2           6    6
#&gt; 
#&gt; $SpatialLines
#&gt; $SpatialLines$`1`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; $SpatialLines$`2`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; $SpatialLines$`3`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 7.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; $SpatialLines$`4`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 7.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; 
#&gt; $coordinates
#&gt; $coordinates$`1`
#&gt;        x    y
#&gt; [1,] 2.5 12.5
#&gt; [2,] 7.5  7.5
#&gt; 
#&gt; $coordinates$`2`
#&gt;         x    y
#&gt; [1,]  2.5 12.5
#&gt; [2,]  7.5  7.5
#&gt; [3,] 12.5  7.5
#&gt; 
#&gt; $coordinates$`3`
#&gt;        x    y
#&gt; [1,] 7.5 12.5
#&gt; [2,] 7.5  7.5
#&gt; 
#&gt; $coordinates$`4`
#&gt;         x    y
#&gt; [1,]  7.5 12.5
#&gt; [2,] 12.5  7.5
#&gt; 
#&gt; </div><div class='input'><span class='co'># cppRouting goal 3 parallelised</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>:</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         combination <span class='op'>=</span> <span class='st'>"matrix"</span>,
                         cppRouting_algorithm <span class='op'>=</span> <span class='st'>"phast"</span>,
                         use_all_cores <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:12)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing phast algorithm to compute least-cost distance(s)... 
#&gt; ... .... Implementing Dijkstra's algorithm recursively to compute least-cost paths(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:12) after ~0 minutes. </div><div class='input'><span class='co'># gdistance goal 3</span>
<span class='va'>out1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>2</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         destination <span class='op'>=</span> <span class='va'>rxy</span><span class='op'>[</span><span class='fl'>5</span><span class='op'>:</span><span class='fl'>6</span>, , drop <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>]</span>,
                         surface <span class='op'>=</span> <span class='va'>r</span>,
                         goal <span class='op'>=</span> <span class='fl'>3</span>,
                         method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                         combination <span class='op'>=</span> <span class='st'>"matrix"</span>,
                         cl <span class='op'>=</span> <span class='fu'>parallel</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></span><span class='op'>(</span><span class='fl'>2L</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:12)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-19.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:16) after ~0.07 minutes. </div><div class='input'><span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_euclid</span>; <span class='va'>out1</span><span class='op'>$</span><span class='va'>dist_lcp</span>; <span class='va'>out1</span><span class='op'>$</span><span class='va'>path_lcp</span>
</div><div class='output co'>#&gt;          5         6
#&gt; 1 7.071068 11.180340
#&gt; 2 5.000000  7.071068</div><div class='output co'>#&gt;           5         6
#&gt; 1  8.124038 13.954990
#&gt; 2 10.295630  9.273618</div><div class='output co'>#&gt; $cells
#&gt;   path_id path origin destination cell
#&gt; 1       1  1-5      1           5    1
#&gt; 2       1  1-5      1           5    5
#&gt; 3       2  2-5      2           5    2
#&gt; 4       2  2-5      2           5    5
#&gt; 5       3  1-6      1           6    1
#&gt; 6       3  1-6      1           6    5
#&gt; 7       3  1-6      1           6    6
#&gt; 8       4  2-6      2           6    2
#&gt; 9       4  2-6      2           6    6
#&gt; 
#&gt; $SpatialLines
#&gt; $SpatialLines$`1`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; $SpatialLines$`2`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 7.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; $SpatialLines$`3`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; $SpatialLines$`4`
#&gt; class       : SpatialLines 
#&gt; features    : 1 
#&gt; extent      : 7.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)
#&gt; crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs 
#&gt; 
#&gt; 
#&gt; $coordinates
#&gt; $coordinates$`1`
#&gt;        x    y
#&gt; [1,] 2.5 12.5
#&gt; [2,] 7.5  7.5
#&gt; 
#&gt; $coordinates$`2`
#&gt;        x    y
#&gt; [1,] 7.5 12.5
#&gt; [2,] 7.5  7.5
#&gt; 
#&gt; $coordinates$`3`
#&gt;         x    y
#&gt; [1,]  2.5 12.5
#&gt; [2,]  7.5  7.5
#&gt; [3,] 12.5  7.5
#&gt; 
#&gt; $coordinates$`4`
#&gt;         x    y
#&gt; [1,]  7.5 12.5
#&gt; [2,] 12.5  7.5
#&gt; 
#&gt; </div><div class='input'>
<span class='co'>#### Example (15): Real world example with multiple origins/destinations</span>
<span class='co'>## Zoom in on an area of interest</span>
<span class='va'>ext</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='fl'>715000</span>, <span class='fl'>720000</span>, <span class='fl'>6250000</span>, <span class='fl'>6260000</span><span class='op'>)</span>
<span class='va'>dat_gebco_utm_planar_zoom</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/crop.html'>crop</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar</span>, <span class='va'>ext</span><span class='op'>)</span>
<span class='co'>## Define example origins/destinations</span>
<span class='co'># Define available coordinates</span>
<span class='va'>dat_gebco_utm_planar_zoom_xy</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/xyFromCell.html'>coordinates</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar_zoom</span><span class='op'>)</span>
<span class='co'># Sample random origins</span>
<span class='fu'><a href='https://rdrr.io/r/base/Random.html'>set.seed</a></span><span class='op'>(</span><span class='fl'>2019</span><span class='op'>)</span>
<span class='va'>index</span>       <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/sample.html'>sample</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>:</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/ncell.html'>nrow</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar_zoom_xy</span><span class='op'>)</span>, <span class='fl'>2</span><span class='op'>)</span>
<span class='va'>origin</span>      <span class='op'>&lt;-</span> <span class='va'>dat_gebco_utm_planar_zoom_xy</span><span class='op'>[</span><span class='va'>index</span>, <span class='op'>]</span>
<span class='co'># Sample random destinations</span>
<span class='fu'><a href='https://rdrr.io/r/base/Random.html'>set.seed</a></span><span class='op'>(</span><span class='fl'>2020</span><span class='op'>)</span>
<span class='va'>index</span>       <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/sample.html'>sample</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>:</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/ncell.html'>nrow</a></span><span class='op'>(</span><span class='va'>dat_gebco_utm_planar_zoom_xy</span><span class='op'>)</span>, <span class='fl'>3</span><span class='op'>)</span>
<span class='va'>destination</span> <span class='op'>&lt;-</span> <span class='va'>dat_gebco_utm_planar_zoom_xy</span><span class='op'>[</span><span class='va'>index</span>, <span class='op'>]</span>
<span class='co'># Implement algorithm</span>
<span class='va'>out_gebco1</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"gdistance"</span>,
                               goal <span class='op'>=</span> <span class='fl'>3</span>,
                               combination <span class='op'>=</span> <span class='st'>"matrix"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:16)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='img'><img src='lcp_over_surface-20.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'gdistance'... 
#&gt; ... ... Defining 'ease' matrix... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... 
#&gt; ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... 
#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:17) after ~0 minutes. </div><div class='input'><span class='va'>out_gebco2</span> <span class='op'>&lt;-</span> <span class='fu'>lcp_over_surface</span><span class='op'>(</span>origin <span class='op'>=</span> <span class='va'>origin</span>,
                               destination <span class='op'>=</span> <span class='va'>destination</span>,
                               surface <span class='op'>=</span> <span class='va'>dat_gebco_utm_planar</span>,
                               method <span class='op'>=</span> <span class='st'>"cppRouting"</span>,
                               goal <span class='op'>=</span> <span class='fl'>3</span>,
                               combination <span class='op'>=</span> <span class='st'>"matrix"</span>,
                               cppRouting_algorithm <span class='op'>=</span> <span class='st'>"phast"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::lcp_over_surface() called (@ 2021-12-02 14:42:17)... 
#&gt; ... Checking user inputs... </div><div class='output co'>#&gt; ... Defining cost matrix... </div><div class='output co'>#&gt; <span class='warning'>Warning: transition function gives negative values</span></div><div class='output co'>#&gt; ... Calculating Euclidean distance(s)... 
#&gt; ... Using method = 'cppRouting'... 
#&gt; ... ... Defining nodes, edges and costs to make graph... 
#&gt; ... ... Constructing graph object... 
#&gt; ... ... Implementing phast algorithm to compute least-cost distance(s)... 
#&gt; ... .... Implementing Dijkstra's algorithm recursively to compute least-cost paths(s)... </div><div class='output co'>#&gt; <span class='warning'>Warning: number of rows of result is not a multiple of vector length (arg 1)</span></div><div class='img'><img src='lcp_over_surface-21.png' alt='' width='700' height='433' /></div><div class='output co'>#&gt; ... flapper::lcp_over_surface() call completed (@ 2021-12-02 14:42:17) after ~0 minutes. </div><div class='input'><span class='co'># The function returns distances between all combinations</span>
<span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>dist_lcp</span>; <span class='va'>out_gebco2</span><span class='op'>$</span><span class='va'>dist_lcp</span>
</div><div class='output co'>#&gt;          2945     2463      3438
#&gt; 2610 3375.062 4064.206 6062.3124
#&gt; 3544 3270.267 5106.123  707.1401</div><div class='output co'>#&gt;          2945     2463      3438
#&gt; 2610 3375.062 4064.206 6062.3124
#&gt; 3544 3270.267 5106.123  707.1401</div><div class='input'><span class='co'># The two outputs are the same (though the ordering of factor levels differs)</span>
<span class='fu'><a href='https://rdrr.io/r/utils/str.html'>str</a></span><span class='op'>(</span><span class='va'>out_gebco1</span><span class='op'>$</span><span class='va'>path_lcp</span><span class='op'>$</span><span class='va'>cells</span><span class='op'>)</span>; <span class='fu'><a href='https://rdrr.io/r/utils/str.html'>str</a></span><span class='op'>(</span><span class='va'>out_gebco2</span><span class='op'>$</span><span class='va'>path_lcp</span><span class='op'>$</span><span class='va'>cells</span><span class='op'>)</span>
</div><div class='output co'>#&gt; 'data.frame':	83 obs. of  5 variables:
#&gt;  $ path_id    : num  1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ path       : Factor w/ 6 levels "2610-2945","3544-2945",..: 1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ origin     : int  2610 2610 2610 2610 2610 2610 2610 2610 2610 2610 ...
#&gt;  $ destination: int  2945 2945 2945 2945 2945 2945 2945 2945 2945 2945 ...
#&gt;  $ cell       : int  2610 2665 2666 2667 2668 2723 2778 2833 2834 2835 ...</div><div class='output co'>#&gt; 'data.frame':	83 obs. of  5 variables:
#&gt;  $ path_id    : num  1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ path       : Factor w/ 6 levels "2610-2945","2610-2463",..: 1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ origin     : int  2610 2610 2610 2610 2610 2610 2610 2610 2610 2610 ...
#&gt;  $ destination: int  2945 2945 2945 2945 2945 2945 2945 2945 2945 2945 ...
#&gt;  $ cell       : int  2610 2665 2666 2667 2668 2723 2778 2833 2834 2835 ...</div><div class='input'>
</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Edward Lavender.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


