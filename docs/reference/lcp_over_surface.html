<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Calculate shortest path(s) and/or distance(s) over a surface between origin and destination coordinates — lcp_over_surface • flapper</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Calculate shortest path(s) and/or distance(s) over a surface between origin and destination coordinates — lcp_over_surface"><meta property="og:description" content="This function computes the shortest path(s) and/or distance(s) over a surface between origin and destination coordinates. To implement this function, origin and destination coordinates need to be specified as matrices and the surface over which movement occurs should be supplied as a raster. Since determining shortest paths can be computationally and memory-intensive, the surface can be reduced in size and/or resolution before these are computed, by (a) cropping the surface within user-defined extents; (b) focusing on a buffer zone along a Euclidean transect connecting origin and destination coordinates; (c) aggregating the surface to reduce the resolution; and/or (d) masking out areas over which movement is impossible (e.g., land for marine animals). Then, the function computes distances between connected cells, given (a) the planar distances between connected cells and (b) their difference in elevation. These distances are taken as a measure of `cost'. For each pair of origin and destination coordinates, or for all combinations of coordinates, these distances are used to compute the least-cost (i.e., shortest) path and/or the distance of this path, using functions in the cppRouting or gdistance package. The function returns the shortest path(s) and/or their distance(s) (m) along with a plot and a list of objects involved in the calculations."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flapper</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.1.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/flapper_algorithms_faqs.html">`flapper`: practitioner FAQs</a>
    </li>
    <li>
      <a href="../articles/flapper_overview.html">`flapper`: an overview</a>
    </li>
  </ul></li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/edwardlavender/flapper/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Calculate shortest path(s) and/or distance(s) over a surface between origin and destination coordinates</h1>
    <small class="dont-index">Source: <a href="https://github.com/edwardlavender/flapper/blob/HEAD/R/lcps.R" class="external-link"><code>R/lcps.R</code></a></small>
    <div class="hidden name"><code>lcp_over_surface.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function computes the shortest path(s) and/or distance(s) over a <code>surface</code> between <code>origin</code> and <code>destination</code> coordinates. To implement this function, <code>origin</code> and <code>destination</code> coordinates need to be specified as matrices and the surface over which movement occurs should be supplied as a <code><a href="https://rdrr.io/pkg/raster/man/raster.html" class="external-link">raster</a></code>. Since determining shortest paths can be computationally and memory-intensive, the <code>surface</code> can be reduced in size and/or resolution before these are computed, by (a) cropping the surface within user-defined extents; (b) focusing on a buffer zone along a Euclidean transect connecting <code>origin</code> and <code>destination</code> coordinates; (c) aggregating the surface to reduce the resolution; and/or (d) masking out areas over which movement is impossible (e.g., land for marine animals). Then, the function computes distances between connected cells, given (a) the planar distances between connected cells and (b) their difference in elevation. These distances are taken as a measure of `cost'. For each pair of <code>origin</code> and <code>destination</code> coordinates, or for all combinations of coordinates, these distances are used to compute the least-cost (i.e., shortest) path and/or the distance of this path, using functions in the <code>cppRouting</code> or <code><a href="https://AgrDataSci.github.io/gdistance/reference/gdistance.html" class="external-link">gdistance</a></code> package. The function returns the shortest path(s) and/or their distance(s) (m) along with a plot and a list of objects involved in the calculations.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">lcp_over_surface</span><span class="op">(</span></span>
<span>  <span class="va">origin</span>,</span>
<span>  <span class="va">destination</span>,</span>
<span>  <span class="va">surface</span>,</span>
<span>  crop <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  buffer <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  aggregate <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  mask <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  mask_inside <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  plot <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  goal <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  combination <span class="op">=</span> <span class="st">"pair"</span>,</span>
<span>  method <span class="op">=</span> <span class="st">"cppRouting"</span>,</span>
<span>  cppRouting_algorithm <span class="op">=</span> <span class="st">"bi"</span>,</span>
<span>  cl <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  varlist <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  use_all_cores <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  check <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>origin</dt>
<dd><p>A matrix which defines the coordinates (x, y) of the starting location(s). Coordinates should lie on a plane (i.e., Universal Transverse Mercator projection).</p></dd>


<dt>destination</dt>
<dd><p>A matrix which defines the coordinates (x, y) of the finishing location(s). Coordinates should lie on a plane (i.e., Universal Transverse Mercator projection).</p></dd>


<dt>surface</dt>
<dd><p>A <code><a href="https://rdrr.io/pkg/raster/man/raster.html" class="external-link">raster</a></code> over which the object (e.g., individual) must move from <code>origin</code> to <code>destination</code>. The <code>surface</code> must be planar (i.e., Universal Transverse Mercator projection) with units of metres in x, y and z directions (m). The <code>surface</code>'s <code>resolution</code> is taken to define the distance between horizontally and vertically connected cells and must be the same in both x and y directions (for <code>surface</code>'s with unequal horizontal resolution, <code><a href="https://rdrr.io/pkg/terra/man/resample.html" class="external-link">resample</a></code> can be used to equalise resolution: see Examples). Any cells with NA values (e.g., due to missing data) are treated as `impossible' to move though by the algorithm. In this case, the <code>surface</code> might need to be pre-processed so that NAs are replaced/removed before implementing the function, depending on their source.</p></dd>


<dt>crop</dt>
<dd><p>(optional) An <code><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></code> object that is used to <code><a href="https://rdrr.io/pkg/terra/man/crop.html" class="external-link">crop</a></code> the extent of the <code>surface</code>, before the least-cost algorithms are implemented. This may be useful for large rasters to reduce memory requirements/computation time.</p></dd>


<dt>buffer</dt>
<dd><p>(optional) A named list of arguments, passed to <code><a href="https://rdrr.io/pkg/rgeos/man/rgeos-deprecated.html" class="external-link">gBuffer</a></code> (e.g. <code>buffer = list(width = 1000)</code>) (m) that is used to define a buffer around a Euclidean transect connecting the <code>origin</code> and <code>destination</code>. (This option can only be implemented for a single <code>origin</code> and <code>destination</code> pair.) The <code>surface</code> is then cropped to the extent of this buffer before the least-cost algorithms are implemented. This may be useful for large rasters to reduce memory requirements and/or computation time.</p></dd>


<dt>aggregate</dt>
<dd><p>(optional) A named list of arguments, passed to <code><a href="https://rdrr.io/r/stats/aggregate.html" class="external-link">aggregate</a></code>, to aggregate raster cells before the least-cost algorithms are implemented. This may be useful for large rasters to reduce memory requirements and/or computation time.</p></dd>


<dt>mask</dt>
<dd><p>(optional) A Raster or Spatial <code><a href="https://rdrr.io/pkg/terra/man/mask.html" class="external-link">mask</a></code> that is used to prevent movement over `impossible' areas on the <code>surface</code>. This must also lie on a planar surface (i.e., Universal Transverse Mercator projection). For example, for marine animals, <code>mask</code> might be a <code><a href="https://rdrr.io/pkg/sp/man/SpatialPolygons.html" class="external-link">SpatialPolygonsDataFrame</a></code> which defines the coastline. The effect of the <code>mask</code> depends on <code>mask_inside</code> (see below).</p></dd>


<dt>mask_inside</dt>
<dd><p>A logical input that defines whether or not to mask the <code>surface</code> inside (<code>TRUE</code>) or outside (<code>FALSE</code>) of the <code>mask</code> (see <code><a href="mask_io.html">mask_io</a></code>).</p></dd>


<dt>plot</dt>
<dd><p>A logical input that defines whether or not to plot the inputted and processed surfaces. If <code>TRUE</code>, the inputted and processed plots are produced side-by-side. For the inputted surface, the <code>mask</code> and the region selected (via <code>crop</code> and/or <code>buffer</code>) are shown along with the <code>origin</code> and <code>destination</code>. For the processed surface, the surface and the <code>origin</code> and <code>destination</code> are shown, along with the shortest path(s) (if and once computed: see <code>goal</code>). This is useful for checking that any <code>surface</code> processing steps have been applied correctly and the <code>origin</code> and <code>destination</code> are positioned correctly on the <code>surface</code>.</p></dd>


<dt>goal</dt>
<dd><p>An integer that defines the output of the function: <code>goal = 1</code> computes shortest distances, <code>goal = 2</code> computes shortest paths and <code>goal = 3</code> computes both shortest paths and the corresponding distances. Note that <code>goal = 3</code> results in least-cost algorithms being implemented twice, which will be inefficient for large problems; in this case, use <code>goal = 2</code> to compute shortest paths and then calculate their distance using outputs returned by the function (see Value).</p></dd>


<dt>combination</dt>
<dd><p>A character string (<code>"pair"</code> or <code>"matrix"</code>) that defines whether or not to compute shortest distances/paths for (a) each sequential <code>origin</code> and <code>destination</code> pair of coordinates (<code>combination = "pair"</code>) or (b) all combinations of <code>origin</code> and <code>destination</code> coordinates (<code>combination = "matrix"</code>). This argument is only applicable if there is more than one <code>origin</code> and <code>destination</code>. For <code>combination = "pair"</code>, the number of <code>origin</code> and <code>destination</code> coordinates needs to be the same, since each <code>origin</code> is matched with each <code>destination</code>.</p></dd>


<dt>method</dt>
<dd><p>A character string (<code>"cppRouting"</code> or <code>"gdistance"</code>) that defines the method used to compute the shortest distances between the <code>origin</code> and the <code>destination</code>. <code>"cppRouting"</code> is the default <code>method</code>. Under this option, functions in the <code>cppRouting</code> package are used to compute the shortest paths (<code><a href="https://rdrr.io/pkg/cppRouting/man/get_path_pair.html" class="external-link">get_path_pair</a></code> or <code><a href="https://rdrr.io/pkg/cppRouting/man/get_multi_paths.html" class="external-link">get_multi_paths</a></code> for each pair of coordinates or for all combinations of coordinates, respectively) and/or distances (<code><a href="https://rdrr.io/pkg/cppRouting/man/get_distance_pair.html" class="external-link">get_distance_pair</a></code> or <code><a href="https://rdrr.io/pkg/cppRouting/man/get_distance_matrix.html" class="external-link">get_distance_matrix</a></code>). This package implements functions written in C++ and massively outperforms the other <code>method = "gdistance"</code> for large problems. Otherwise, if <code>method = "gdistance"</code>, functions in the <code><a href="https://AgrDataSci.github.io/gdistance/reference/gdistance.html" class="external-link">gdistance</a></code> are called iteratively to compute shortest paths (via <code><a href="https://AgrDataSci.github.io/gdistance/reference/shortestPath.html" class="external-link">shortestPath</a></code>) or distances (via <code><a href="https://AgrDataSci.github.io/gdistance/reference/costDistance-methods.html" class="external-link">costDistance</a></code>).</p></dd>


<dt>cppRouting_algorithm</dt>
<dd><p>A character string that defines the algorithm used to compute shortest paths or distances. This is only applicable if <code>method = "cppRouting"</code>: <code>method = "gdistance"</code> implements Dijkstra's algorithm only. For shortest paths or their distances between pairs of coordinates, the options are <code>"Dijkstra"</code>, <code>"bi"</code>, <code>"A*"</code> or <code>"NBA"</code> for the uni-directional Dijkstra, bi-directional Dijkstra, A star unidirectional search or new bi-directional A star algorithms respectively (see <code><a href="https://rdrr.io/pkg/cppRouting/man/get_path_pair.html" class="external-link">get_path_pair</a></code> or <code><a href="https://rdrr.io/pkg/cppRouting/man/get_distance_pair.html" class="external-link">get_distance_pair</a></code>). For shortest paths between all combinations of coordinates, <code>cppRouting_algorithm</code> is ignored and the Dijkstra algorithm is implemented recursively. For shortest distances between all combinations of coordinates, the options are <code>"phast"</code> or <code>"mch"</code> (see <code><a href="https://rdrr.io/pkg/cppRouting/man/get_distance_matrix.html" class="external-link">get_distance_matrix</a></code>).</p></dd>


<dt>use_all_cores, cl, varlist</dt>
<dd><p>Parallelisation options for <code>method = "cppRouting"</code> (<code>use_all_cores</code>) or <code>method = "gdistance"</code> (<code>cl</code> and <code>varlist</code>) respectively. If <code>method = "cppRouting"</code>, parallelisation is implemented via <code>use_all_cores</code> for computing shortest distances only (not computing shortest paths). <code>use_all_cores</code> is a logical input that defines whether or not to use all cores for computing shortest distance(s). If <code>method = "gdistance"</code>, parallelisation is implemented via <code>cl</code> and <code>varlist</code> for both shortest paths and distances function calls. <code>cl</code> is (a) a cluster object from <code><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></code> or (b) an integer that defines the number of child processes. <code>varlist</code> is a character vector of variables for export (see <code><a href="cl.html">cl_export</a></code>). Exported variables must be located in the global environment. If a cluster is supplied, the connection to the cluster is closed within the function (see <code><a href="cl.html">cl_stop</a></code>). For further information, see <code><a href="cl.html">cl_lapply</a></code> and <code><a href="flapper-tips-parallel.html">flapper-tips-parallel</a></code>.</p></dd>


<dt>check</dt>
<dd><p>A logical input that defines whether or not to check function inputs. If <code>TRUE</code>, internal checks are implemented to check user-inputs and whether or not inputted coordinates are in appropriate places on the processed <code>surface</code> (for instance, to ensure inputted coordinates do not lie over masked areas). This helps to prevent intractable error messages. If <code>FALSE</code>, these checks are not implemented, so function progress may be faster initially (especially for large <code>origin</code>/<code>destination</code> coordinate matrices).</p></dd>


<dt>verbose</dt>
<dd><p>A logical input that defines whether or not to print messages to the console to monitor function progress. This is especially useful with a large <code>surface</code> since the algorithms are computationally intensive.</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    

<div class="section">
<h3 id="a-named-list">A named list<a class="anchor" aria-label="anchor" href="#a-named-list"></a></h3>
<p>The function returns a named list. The most important element(s) of this list are `path_lcp' and/or `dist_lcp', the shortest path(s) and/or distance(s) (m) between <code>origin</code> and <code>destination</code> coordinate pairs/combinations. `path_lcp' is returned if <code>goal = 2</code> or <code>goal = 3</code> and `dist_lcp' is returned if <code>goal = 1</code> or <code>goal = 3</code>. `path_lcp' contains (a) a dataframe with the cells comprising each path (`cells'), (b) a named list containing a <code><a href="https://rdrr.io/pkg/sp/man/SpatialLines.html" class="external-link">SpatialLines</a></code> object for each path (`SpatialLines') and (c) a named list of matrices of the coordinates of each path (`coordinates'). `dist_lcp' is a (a) numeric vector or (b) matrix with the distances (m) between each pair or combination of coordinates respectively. If `dist_lcp' is computed, `dist_euclid', the Euclidean distances (m) between the <code>origin</code> and <code>destination</code>, is also returned for comparison.</p>
</div>



<div class="section">
<h3 id="common-elements">Common elements<a class="anchor" aria-label="anchor" href="#common-elements"></a></h3>
<p>Other elements of the list record important outputs at sequential stages of the algorithm's progression. These include the following elements: `args', a named list of user inputs; `time', a dataframe that defines the times of sequential stages in the algorithm's progression; `surface', the surface over which shortest distances are computed (this may differ from the inputted surface if any of the processing options, such as <code>crop</code>, have been implemented); `surface_param', a named list that defines the cell IDs, the number of rows, the number of columns, the coordinates of the implemented surface and the cell IDs of the <code>origin</code> and <code>destination</code> nodes; `cost', a named list of arguments that defines the distances (m) between connected cells under a rook's or bishop's movement (`dist_rook' and `dist_bishop'), the planar and vertical distances between connected cells (`dist_planar' and `dist_vertical') and the total distance between connected cells (`dist_total'); and `cppRouting_param' or `gdistance_param', a named list of arguments used to compute shortest paths/distances via <code>cppRouting</code> or <code><a href="https://AgrDataSci.github.io/gdistance/reference/gdistance.html" class="external-link">gdistance</a></code> (see below).</p>
</div>



<div class="section">
<h3 id="method-specific-elements">Method-specific elements<a class="anchor" aria-label="anchor" href="#method-specific-elements"></a></h3>
<p>If <code>method = "cppRouting"</code>, the `cppRouting_param' list contains a named list of arguments passed to <code><a href="https://rdrr.io/pkg/cppRouting/man/makegraph.html" class="external-link">makegraph</a></code> (`makegraph_param') as well as <code><a href="https://rdrr.io/pkg/cppRouting/man/get_path_pair.html" class="external-link">get_path_pair</a></code> (`get_path_pair_param') or <code><a href="https://rdrr.io/pkg/cppRouting/man/get_multi_paths.html" class="external-link">get_multi_paths</a></code> (`get_multi_paths_param') and/or <code><a href="https://rdrr.io/pkg/cppRouting/man/get_distance_pair.html" class="external-link">get_distance_pair</a></code> (`get_distance_pair_param') or <code><a href="https://rdrr.io/pkg/cppRouting/man/get_distance_matrix.html" class="external-link">get_distance_matrix</a></code> (`get_distance_matrix_param'), depending on whether or not shortest paths and/or distances have been computed (see <code>goal</code>) and whether or not shortest paths/distances have been computed for each pair of coordinates or all combinations of coordinates. If <code>method = "gdistance"</code>, this list contains a named list of arguments passed iteratively, for each pair/combination of coordinates, to <code><a href="https://AgrDataSci.github.io/gdistance/reference/shortestPath.html" class="external-link">shortestPath</a></code> (`shortestPath_param') or <code><a href="https://AgrDataSci.github.io/gdistance/reference/costDistance-methods.html" class="external-link">costDistance</a></code> (`costDistance_param'). This includes an object of class TransitionLayer (see <code><a href="https://AgrDataSci.github.io/gdistance/reference/Transition-classes.html" class="external-link">Transition-classes</a></code>), in which the <code>transitionMatrix</code> slot contains a (sparse) matrix that defines the ease of moving between connected cells (the reciprocal of the `dist_total' matrix).</p>
</div>



<div class="section">
<h3 id="plot">Plot<a class="anchor" aria-label="anchor" href="#plot"></a></h3>
<p>If <code>plot = TRUE</code>, a plot is also produced of the inputted and processed surfaces that are used in the calculations, along with the shortest path(s) (if and once computed).</p>
</div>


    </div>
    <div id="details">
    <h2>Details</h2>
    
<div class="section">
<h3 id="methods">Methods<a class="anchor" aria-label="anchor" href="#methods"></a></h3>
<p>This function was motivated by the need to determine the shortest paths and their distances between points for benthic animals, which must move over the seabed to navigate from A to B. For these animals, especially in areas with heterogeneous bathymetric landscapes and/or coastline, the shortest path that an individual must travel to move from A and B may differ substantially from the Euclidean path that is often used as a proxy for distance in biological studies. However, this function can still be used in situations where the surface over which an individual must move is irrelevant (e.g., for a pelagic animal), by supplying a flat surface; then shortest paths/distances simply depend on the planar distances between locations and any barriers (e.g., the coastline). (However, this process will be somewhat inefficient.)</p>
<p>The function conceptualises an object moving across a landscape as a queen on a chessboard which can move, in eight directions around its current position, across this surface. Given the potentially large number of possible paths between an <code>origin</code> and <code>destination</code>, the surface may be reduced in extent or size before the game begins. To determine shortest path/distance over the surface between each <code>origin</code> and <code>destination</code> pair/combination, the function first considers the distance that an object must travel between pairs of connected cells. This depends on the planar distances between cells and their differences in elevation. Planar distances (\(d_p\), m) depend on the movement type: under a rook's movement (i.e., horizontally or vertically), the distance (\(d_{p,r}\)) between connected cells is extracted from the raster's resolution (which is assumed to be identical in the x and y directions); under a bishop's movement (i.e., diagonally), the distance between connected cells \(d_{p,b}\) is given by Pythagoras' Theorem: \(d_{p,b} = \sqrt{(d_{p, r}^2 + d_{p, r}^2)}\). Vertical distances (\(d_v\), m) are simply the differences in height between cells. The total distance (\(d_t\)) between any two connected cells is a combination of these distances given by Pythagoras' Theorem: \(d_t = \sqrt{(d_p^2 + d_v^2)}\). These distances are taken to define the `cost' of movement between connected cells. Thus, `costs' are symmetric (i.e., the cost of moving from A to B equals the cost of moving from B to A).</p>
<p>This cost surface is then used to compute the shortest path and/or distance of the shortest path between each <code>origin</code> and <code>destination</code> pair/combination using functions in the <code>cppRouting</code> or <code><a href="https://AgrDataSci.github.io/gdistance/reference/gdistance.html" class="external-link">gdistance</a></code> package. The functions implemented depend on the <code>goal</code> (i.e., whether the aim is to compute shortest paths, shortest distances or both) and, if there is more than one <code>origin</code>/<code>destination</code>, the <code>combination</code> type (i.e., whether to compute shortest paths/distances for each sequential pair of coordinates or all possible combinations of coordinates).</p>
</div>

<div class="section">
<h3 id="warnings">Warnings<a class="anchor" aria-label="anchor" href="#warnings"></a></h3>
<p>The function returns a warning produced by <code><a href="https://AgrDataSci.github.io/gdistance/reference/transition.html" class="external-link">transition</a></code> which is implemented to facilitate the definition of the cost surface, before shortest paths/distances are computed by either method: `In .TfromR(x, transitionFunction, directions, symm) : transition function gives negative values'. This warning arises because the height differences between connecting cells can be negative. It can be safely ignored.</p>
</div>

    </div>
    <div id="author">
    <h2>Author</h2>
    <p>Edward Lavender</p>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co">#### Example types</span></span></span>
<span class="r-in"><span><span class="co"># Shortest distances between a single origin and a single destination</span></span></span>
<span class="r-in"><span><span class="co"># Shortest paths between a single origin and a single destination</span></span></span>
<span class="r-in"><span><span class="co"># Shortest distances/paths between origin/destination pairs</span></span></span>
<span class="r-in"><span><span class="co"># Shortest distances/paths between all origin/destination combinations</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Simulate a hypothetical landscape</span></span></span>
<span class="r-in"><span><span class="co"># Define a miniature, blank landscape with appropriate dimensions</span></span></span>
<span class="r-in"><span><span class="va">proj_utm</span> <span class="op">&lt;-</span> <span class="fu">sp</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sp/man/CRS-class.html" class="external-link">CRS</a></span><span class="op">(</span>SRS_string <span class="op">=</span> <span class="st">"EPSG:32629"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/raster.html" class="external-link">raster</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  nrows <span class="op">=</span> <span class="fl">3</span>, ncols <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  crs <span class="op">=</span> <span class="va">proj_utm</span>,</span></span>
<span class="r-in"><span>  resolution <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">5</span>, <span class="fl">5</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  ext <span class="op">=</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">15</span>, <span class="fl">0</span>, <span class="fl">15</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Define a matrix of hypothetical values for the landscape</span></span></span>
<span class="r-in"><span><span class="va">mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="fl">5</span>, <span class="fl">10</span>, <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  <span class="fl">2</span>, <span class="fl">1</span>, <span class="fl">4</span>,</span></span>
<span class="r-in"><span>  <span class="fl">5</span>, <span class="fl">6</span>, <span class="fl">6</span></span></span>
<span class="r-in"><span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">3</span>, nrow <span class="op">=</span> <span class="fl">3</span>, byrow <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">r</span><span class="op">[</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mat</span></span></span>
<span class="r-in"><span><span class="co"># Visualise simulated landscape</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/graphics/text.html" class="external-link">text</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span></span>
<span class="r-plt img"><img src="lcp_over_surface-1.png" alt="" width="700" height="433"></span>
<span class="r-in"><span><span class="co"># Extract coordinates of cells</span></span></span>
<span class="r-in"><span><span class="va">rxy</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sp/man/coordinates.html" class="external-link">coordinates</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">############################################################################</span></span></span>
<span class="r-in"><span><span class="co">#### Shortest distances between a single origin and a single destination</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (1): Find the distance between a single origin and destination</span></span></span>
<span class="r-in"><span><span class="co"># ... using the "cppRouting" method:</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:43:57)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:43:57) after ~0 minutes. </span>
<span class="r-in"><span><span class="co"># Extract shortest distance</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 7.071068</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (1) continued: An explanation of function outputs</span></span></span>
<span class="r-in"><span><span class="co"># The function returns a list:</span></span></span>
<span class="r-in"><span><span class="co"># The 'args' element simply contains all inputted arguments</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">args</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $origin</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $destination</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $surface</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class      : RasterLayer </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dimensions : 3, 3, 9  (nrow, ncol, ncell)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> resolution : 5, 5  (x, y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent     : 0, 15, 0, 15  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs        : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> source     : memory</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> names      : layer </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> values     : 1, 10  (min, max)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $crop</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $buffer</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $aggregate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $mask</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $mask_inside</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $plot</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $goal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $combination</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "pair"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $method</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "cppRouting"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cppRouting_algorithm</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "bi"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cl</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $varlist</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $use_all_cores</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $check</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $verbose</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># The 'surface' element contains the surface used to compute shortest distances</span></span></span>
<span class="r-in"><span><span class="co"># ... This may differ from $args$surface if cropped, buffered etc.</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">surface</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class      : RasterLayer </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dimensions : 3, 3, 9  (nrow, ncol, ncell)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> resolution : 5, 5  (x, y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent     : 0, 15, 0, 15  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs        : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> source     : memory</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> names      : layer </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> values     : 1, 10  (min, max)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># The 'surface_param' element contains the cell IDs, number of rows, cells and coordinates</span></span></span>
<span class="r-in"><span><span class="co"># ... of this surface</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">surface_param</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cells</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1 2 3 4 5 6 7 8 9</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $nrow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $ncol</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>          x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,]  2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,]  7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,] 12.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,]  2.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,]  7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,] 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,]  2.5  2.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,]  7.5  2.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,] 12.5  2.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $origin_cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $destination_cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># The 'cost' element is a list of objects that define the cost matrix:</span></span></span>
<span class="r-in"><span><span class="co"># ... 'dist_rook' and 'dist_bishop' are matrices which define the distance of planar</span></span></span>
<span class="r-in"><span><span class="co"># ... ... movement from one cell to any other cell under a rook's or bishop's movement.</span></span></span>
<span class="r-in"><span><span class="co"># ... ... For example, the planar distance of moving from cell 1 to cell 2 to is 5 m:</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">cost</span><span class="op">$</span><span class="va">dist_rook</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9 x 9 sparse Matrix of class "dsCMatrix"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                        </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,] . 5 . 5 . . . . .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,] 5 . 5 . 5 . . . .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,] . 5 . . . 5 . . .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,] 5 . . . 5 . 5 . .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,] . 5 . 5 . 5 . 5 .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,] . . 5 . 5 . . . 5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,] . . . 5 . . . 5 .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,] . . . . 5 . 5 . 5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,] . . . . . 5 . 5 .</span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">cost</span><span class="op">$</span><span class="va">dist_bishop</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9 x 9 sparse Matrix of class "dsCMatrix"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                                                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,] .        .        .        .        7.071068 .        .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,] .        .        .        7.071068 .        7.071068 .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,] .        .        .        .        7.071068 .        .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,] .        7.071068 .        .        .        .        .        7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,] 7.071068 .        7.071068 .        .        .        7.071068 .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,] .        7.071068 .        .        .        .        .        7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,] .        .        .        .        7.071068 .        .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,] .        .        .        7.071068 .        7.071068 .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,] .        .        .        .        7.071068 .        .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>               </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,] 7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,] .       </span>
<span class="r-in"><span><span class="co"># ... 'dist_planar' gives the planar distance between connected cell combinations</span></span></span>
<span class="r-in"><span><span class="co"># ... ... under a queen's movements:</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">cost</span><span class="op">$</span><span class="va">dist_planar</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9 x 9 sparse Matrix of class "dsCMatrix"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                                                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,] .        5.000000 .        5.000000 7.071068 .        .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,] 5.000000 .        5.000000 7.071068 5.000000 7.071068 .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,] .        5.000000 .        .        7.071068 5.000000 .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,] 5.000000 7.071068 .        .        5.000000 .        5.000000 7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,] 7.071068 5.000000 7.071068 5.000000 .        5.000000 7.071068 5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,] .        7.071068 5.000000 .        5.000000 .        .        7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,] .        .        .        5.000000 7.071068 .        .        5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,] .        .        .        7.071068 5.000000 7.071068 5.000000 .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,] .        .        .        .        7.071068 5.000000 .        5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>               </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,] 7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,] 5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,] .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,] 5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,] .       </span>
<span class="r-in"><span><span class="co"># ... 'dist_vertical' gives the vertical distance between connected cells</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">cost</span><span class="op">$</span><span class="va">dist_vertical</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9 x 9 sparse Matrix of class "dsCMatrix"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,]  .  5  . -3 -4  . . . .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,]  5  . -7 -8 -9 -6 . . .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,]  . -7  .  . -2  1 . . .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,] -3 -8  .  . -1  . 3 4 .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,] -4 -9 -2 -1  .  3 4 5 5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,]  . -6  1  .  3  . . 2 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,]  .  .  .  3  4  . . 1 .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,]  .  .  .  4  5  2 1 . .</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,]  .  .  .  .  5  2 . . .</span>
<span class="r-in"><span><span class="co"># ... and 'dist_total' gives the total distance between connected cells</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">cost</span><span class="op">$</span><span class="va">dist_total</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9 x 9 sparse Matrix of class "dsCMatrix"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                                                        </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,] .         7.071068 .         5.830952  8.124038 .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,] 7.071068  .        8.602325 10.677078 10.295630 9.273618 .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,] .         8.602325 .         .         7.348469 5.099020 .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,] 5.830952 10.677078 .         .         5.099020 .        5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,] 8.124038 10.295630 7.348469  5.099020  .        5.830952 8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,] .         9.273618 5.099020  .         5.830952 .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,] .         .        .         5.830952  8.124038 .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,] .         .        .         8.124038  7.071068 7.348469 5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,] .         .        .         .         8.660254 5.385165 .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                        </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1,] .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [2,] .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3,] .        .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [4,] 8.124038 .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5,] 7.071068 8.660254</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [6,] 7.348469 5.385165</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7,] 5.099020 .       </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [8,] .        5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9,] 5.000000 .       </span>
<span class="r-in"><span><span class="co"># 'dist_euclid' is the Euclidean distance between the origin and destination</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_euclid</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 5</span>
<span class="r-in"><span><span class="co"># 'cppRouting_param' contains lists of parameters passed to (a) makegraph() and (b)</span></span></span>
<span class="r-in"><span><span class="co"># ... get_distance_matrix() to compute shortest distances using cppRouting</span></span></span>
<span class="r-in"><span><span class="fu">utils</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">out1</span><span class="op">$</span><span class="va">cppRouting_param</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> List of 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ makegraph_param        :List of 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ df      :'data.frame':	40 obs. of  3 variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ from: int [1:40] 2 4 5 1 3 4 5 6 2 5 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ to  : int [1:40] 1 1 1 2 2 2 2 2 3 3 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ cost: num [1:40] 7.07 5.83 8.12 7.07 8.6 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ directed: logi FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ coords  :'data.frame':	9 obs. of  3 variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ node: int [1:9] 1 2 3 4 5 6 7 8 9</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ X   : num [1:9] 2.5 7.5 12.5 2.5 7.5 12.5 2.5 7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ Y   : num [1:9] 12.5 12.5 12.5 7.5 7.5 7.5 2.5 2.5 2.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ get_distance_pair_param:List of 5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ Graph    :List of 5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ data  :'data.frame':	80 obs. of  3 variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ from: int [1:80] 0 1 2 3 4 1 2 5 0 2 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ to  : int [1:80] 3 3 3 0 0 0 0 0 4 4 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ dist: num [1:80] 7.07 5.83 8.12 7.07 8.6 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ coords:'data.frame':	9 obs. of  3 variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ node: chr [1:9] "2" "4" "5" "1" ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ X   : num [1:9] 7.5 2.5 7.5 2.5 12.5 12.5 2.5 7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ Y   : num [1:9] 12.5 7.5 7.5 12.5 12.5 7.5 2.5 2.5 2.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ nbnode: int 9</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ dict  :'data.frame':	9 obs. of  2 variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ ref: chr [1:9] "2" "4" "5" "1" ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ id : int [1:9] 0 1 2 3 4 5 6 7 8</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..$ attrib:List of 4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ aux  : NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ cap  : NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ alpha: NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ beta : NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ from     : num 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ to       : num 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ algorithm: chr "bi"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ allcores : logi FALSE</span>
<span class="r-in"><span><span class="co"># 'time' records the time of each stage</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">time</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       event                time   serial_duration</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1                     onset 2023-08-29 15:43:57 0.0471990108 secs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2         surface_processed 2023-08-29 15:43:57 0.0285661221 secs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3 transition_matrix_defined 2023-08-29 15:43:57 0.0011448860 secs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4             graph_defined 2023-08-29 15:43:57 0.0004138947 secs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5          dist_lcp_defined 2023-08-29 15:43:57 0.0002651215 secs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6                    finish 2023-08-29 15:43:57           NA secs</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (2): Find the distance between a single origin and destination</span></span></span>
<span class="r-in"><span><span class="co"># ... using the "gdistance" method</span></span></span>
<span class="r-in"><span><span class="va">out2</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:43:57)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-2.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:43:58) after ~0 minutes. </span>
<span class="r-in"><span><span class="co"># Extract distance</span></span></span>
<span class="r-in"><span><span class="va">out2</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 7.071068</span>
<span class="r-in"><span><span class="co"># Elements of the returned list are the same apart from 'gdistance_param'</span></span></span>
<span class="r-in"><span><span class="co"># ... which contains a list of arguments passed to costDistance() to compute</span></span></span>
<span class="r-in"><span><span class="co"># ... shortest distances</span></span></span>
<span class="r-in"><span><span class="fu">utils</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">out2</span><span class="op">$</span><span class="va">gdistance_param</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> List of 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ costDistance_param:List of 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ x         :Formal class 'TransitionLayer' [package "gdistance"] with 13 slots</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ title           : chr(0) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ extent          :Formal class 'Extent' [package "raster"] with 4 slots</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ xmin: num 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ xmax: num 15</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ ymin: num 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ ymax: num 15</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ rotated         : logi FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ rotation        :Formal class '.Rotation' [package "raster"] with 2 slots</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ geotrans: num(0) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ transfun:function ()  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ ncols           : int 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ nrows           : int 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ crs             :Formal class 'CRS' [package "sp"] with 1 slot</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ projargs: chr NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ srs             : chr "PROJCRS[\"WGS 84 / UTM zone 29N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 "| __truncated__</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ history         : list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ z               : list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ transitionMatrix:Formal class 'dsCMatrix' [package "Matrix"] with 7 slots</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ i       : int [1:20] 0 1 0 1 0 1 2 3 1 2 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ p       : int [1:10] 0 0 1 2 4 8 11 13 17 20</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ Dim     : int [1:2] 9 9</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ Dimnames:List of 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. .. ..$ : NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. .. ..$ : NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ x       : num [1:20] 0.1414 0.1162 0.1715 0.0937 0.1231 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ uplo    : chr "U"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. .. .. ..@ factors : list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ transitionCells : int [1:9] 1 2 3 4 5 6 7 8 9</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..@ matrixValues    : chr "conductance"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ layernames: chr ""</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ unit      : chr ""</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ fromCoords: num [1, 1:2] 2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..- attr(*, "dimnames")=List of 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ : NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ : chr [1:2] "x" "y"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ..$ toCoords  : num [1, 1:2] 7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. ..- attr(*, "dimnames")=List of 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ : NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .. .. ..$ : chr [1:2] "x" "y"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (3): Find the distances between other origins and destinations</span></span></span>
<span class="r-in"><span><span class="co">## Implement function to determine shortest distances:</span></span></span>
<span class="r-in"><span><span class="co"># shortest distance between cell 1 and 6 via gdistance</span></span></span>
<span class="r-in"><span><span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-3.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 13.95499</span>
<span class="r-in"><span><span class="co"># shortest distance between cell 1 and 6 via cppRouting</span></span></span>
<span class="r-in"><span><span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"cppRouting"</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 13.95499</span>
<span class="r-in"><span><span class="co">## Compare to manually computed distances</span></span></span>
<span class="r-in"><span><span class="co"># The shortest distance from cell 1 to cell 6 is to move diagonally</span></span></span>
<span class="r-in"><span><span class="co"># ... from cell 1 to 5 and then 6.</span></span></span>
<span class="r-in"><span><span class="co"># Define planar distances of moving like a rook (d_pr) or bishop (d_pb)</span></span></span>
<span class="r-in"><span><span class="va">d_pr</span> <span class="op">&lt;-</span> <span class="fl">5</span></span></span>
<span class="r-in"><span><span class="va">d_pb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fl">5</span><span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="fl">5</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Define total distance travelled along shortest path, as computed by the</span></span></span>
<span class="r-in"><span><span class="co"># ... algorithm to demonstrate we obtain the same value:</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="op">(</span><span class="fl">5</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="va">d_pb</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="op">(</span><span class="fl">4</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="va">d_pr</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 13.95499</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (4): Find the shortest distances around NAs</span></span></span>
<span class="r-in"><span><span class="co">## Force the 5th cell to be NA</span></span></span>
<span class="r-in"><span><span class="va">rtmp</span> <span class="op">&lt;-</span> <span class="va">r</span></span></span>
<span class="r-in"><span><span class="va">rtmp</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="cn">NA</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">rtmp</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/graphics/text.html" class="external-link">text</a></span><span class="op">(</span><span class="va">rtmp</span><span class="op">)</span></span></span>
<span class="r-plt img"><img src="lcp_over_surface-4.png" alt="" width="700" height="433"></span>
<span class="r-in"><span><span class="co">## Compute shortest distances via algorithm:</span></span></span>
<span class="r-in"><span><span class="co"># Now compute shortest distances, which we can see have increased the distance</span></span></span>
<span class="r-in"><span><span class="co"># ... since movement through an NA cell is not allowed. Therefore, if this NA</span></span></span>
<span class="r-in"><span><span class="co"># ... reflects missing data, it may be appropriate to interpolate NAs using</span></span></span>
<span class="r-in"><span><span class="co"># ... surrounding cells (e.g., see raster::approxNA()) so that movement</span></span></span>
<span class="r-in"><span><span class="co"># ... is possible through these cells</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">rtmp</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-in"><span><span class="va">out2</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">rtmp</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"cppRouting"</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-5.png" alt="" width="700" height="433"></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 16.34469</span>
<span class="r-in"><span><span class="va">out2</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 16.34469</span>
<span class="r-in"><span><span class="co">## Compare to manual calculations of shortest route:</span></span></span>
<span class="r-in"><span><span class="co"># Route option one: cell 1 to 2, 2 to 6</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="op">(</span><span class="fl">5</span> <span class="op">-</span> <span class="fl">10</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="va">d_pr</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="op">(</span><span class="fl">10</span> <span class="op">-</span> <span class="fl">4</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span> <span class="op">+</span> <span class="va">d_pb</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 16.34469</span>
<span class="r-in"><span><span class="co"># Or, using the numbers computed in the dist_total object:</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">cost</span><span class="op">$</span><span class="va">dist_total</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">out1</span><span class="op">$</span><span class="va">cost</span><span class="op">$</span><span class="va">dist_total</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">6</span><span class="op">]</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 16.34469</span>
<span class="r-in"><span><span class="co">## Compare to effect of making a value in the landscape extremely large</span></span></span>
<span class="r-in"><span><span class="co"># In the same way, we can force the shortest path away from particular areas</span></span></span>
<span class="r-in"><span><span class="co"># ... by making the height of the landscape in those areas very large or Inf:</span></span></span>
<span class="r-in"><span><span class="va">rtmp</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1e20</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">rtmp</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/graphics/text.html" class="external-link">text</a></span><span class="op">(</span><span class="va">rtmp</span><span class="op">)</span></span></span>
<span class="r-plt img"><img src="lcp_over_surface-6.png" alt="" width="700" height="433"></span>
<span class="r-in"><span><span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">rtmp</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"cppRouting"</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 16.34469</span>
<span class="r-in"><span><span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">rtmp</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-7.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 16.34469</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (4): Find the distances between points on a real landscape</span></span></span>
<span class="r-in"><span><span class="co">## We will use some example bathymetry data:</span></span></span>
<span class="r-in"><span><span class="va">dat_gebco_oban</span> <span class="op">&lt;-</span> <span class="fu">prettyGraphics</span><span class="fu">::</span><span class="va"><a href="https://edwardlavender.github.io/prettyGraphics/reference/dat_gebco.html" class="external-link">dat_gebco</a></span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">dat_gebco_oban</span><span class="op">)</span></span></span>
<span class="r-plt img"><img src="lcp_over_surface-8.png" alt="" width="700" height="433"></span>
<span class="r-in"><span><span class="co">## Process bathymetry data before function implementation</span></span></span>
<span class="r-in"><span><span class="co"># (a) Define utm coordinates:</span></span></span>
<span class="r-in"><span><span class="va">dat_gebco_utm</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/projectRaster.html" class="external-link">projectRaster</a></span><span class="op">(</span><span class="va">dat_gebco_oban</span>, crs <span class="op">=</span> <span class="va">proj_utm</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/dimensions.html" class="external-link">res</a></span><span class="op">(</span><span class="va">dat_gebco_utm</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 257 463</span>
<span class="r-in"><span><span class="co"># (b) Resample so that the resolution in the x and y directions is identical</span></span></span>
<span class="r-in"><span><span class="va">dat_gebco_utm_planar</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/raster.html" class="external-link">raster</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  crs <span class="op">=</span> <span class="va">proj_utm</span>,</span></span>
<span class="r-in"><span>  ext <span class="op">=</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></span><span class="op">(</span><span class="va">dat_gebco_utm</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  resolution <span class="op">=</span> <span class="fl">250</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dat_gebco_utm_planar</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/resample.html" class="external-link">resample</a></span><span class="op">(</span><span class="va">dat_gebco_utm</span>, <span class="va">dat_gebco_utm_planar</span>, method <span class="op">=</span> <span class="st">"bilinear"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Examine processed raster</span></span></span>
<span class="r-in"><span><span class="va">pp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">dat_gebco_utm</span>, main <span class="op">=</span> <span class="st">"UTM raster"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar</span>, main <span class="op">=</span> <span class="st">"UTM raster with equal res"</span><span class="op">)</span></span></span>
<span class="r-plt img"><img src="lcp_over_surface-9.png" alt="" width="700" height="433"></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">pp</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co">## Define example origin and destination</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dat_gebco_utm_planar_xy</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sp/man/coordinates.html" class="external-link">coordinates</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">index</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar_xy</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">origin</span> <span class="op">&lt;-</span> <span class="va">dat_gebco_utm_planar_xy</span><span class="op">[</span><span class="va">index</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span></span></span>
<span class="r-in"><span><span class="va">destination</span> <span class="op">&lt;-</span> <span class="va">dat_gebco_utm_planar_xy</span><span class="op">[</span><span class="va">index</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span></span></span>
<span class="r-in"><span><span class="co">## Implement function to compute shortest distances</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:43:59)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-10.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:43:59) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out_gebco2</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"cppRouting"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:43:59)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:43:59) after ~0.01 minutes. </span>
<span class="r-in"><span><span class="co"># Compare Euclidean and shortest distances</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_euclid</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 8902.247</span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9278.626</span>
<span class="r-in"><span><span class="va">out_gebco2</span><span class="op">$</span><span class="va">dist_euclid</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 8902.247</span>
<span class="r-in"><span><span class="va">out_gebco2</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9278.626</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (5A): Reduce the complexity of the landscape by cropping</span></span></span>
<span class="r-in"><span><span class="va">ext</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">ext</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">6255000</span></span></span>
<span class="r-in"><span><span class="va">ext</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">6265000</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  crop <span class="op">=</span> <span class="va">ext</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:43:59)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Cropping raster to inputted extent... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-11.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:00) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9278.626</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (5B): Reduce the complexity of the landscape around a buffer</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  buffer <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>width <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:00)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Cropping raster to buffer zone around a Euclidean transect between the origin and destination... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>GEOS support is provided by the sf and terra packages among others</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-12.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:00) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9278.626</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (5C): Reduce the complexity of the landscape via aggregation</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  buffer <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>width <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  aggregate <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>fact <span class="op">=</span> <span class="fl">5</span>, fun <span class="op">=</span> <span class="va">mean</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:00)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Cropping raster to buffer zone around a Euclidean transect between the origin and destination... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>GEOS support is provided by the sf and terra packages among others</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Aggregating raster... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-13.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:00) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 10088.96</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (6C): Implement a mask</span></span></span>
<span class="r-in"><span><span class="co"># Define coastline</span></span></span>
<span class="r-in"><span><span class="va">dat_coast_around_oban</span> <span class="op">&lt;-</span> <span class="fu">prettyGraphics</span><span class="fu">::</span><span class="va"><a href="https://edwardlavender.github.io/prettyGraphics/reference/dat_coast_around_oban.html" class="external-link">dat_coast_around_oban</a></span></span></span>
<span class="r-in"><span><span class="va">coastline</span> <span class="op">&lt;-</span> <span class="fu">sp</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sp/man/spTransform.html" class="external-link">spTransform</a></span><span class="op">(</span><span class="va">dat_coast_around_oban</span>, <span class="va">proj_utm</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Visualise bathymetry and coastline</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">raster</span><span class="fu">::</span><span class="fu">lines</span><span class="op">(</span><span class="va">coastline</span><span class="op">)</span></span></span>
<span class="r-plt img"><img src="lcp_over_surface-14.png" alt="" width="700" height="433"></span>
<span class="r-in"><span><span class="co"># Define example origin and destination within the sea</span></span></span>
<span class="r-in"><span><span class="va">origin</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">714000</span>, <span class="fl">6260000</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">destination</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">721000</span>, <span class="fl">6265000</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Implement algorithm</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  crop <span class="op">=</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></span><span class="op">(</span><span class="va">coastline</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  mask <span class="op">=</span> <span class="va">coastline</span>,</span></span>
<span class="r-in"><span>  mask_inside <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:00)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Cropping raster to inputted extent... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Masking raster... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>GEOS support is provided by the sf and terra packages among others</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:00) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out_gebco2</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"cppRouting"</span>,</span></span>
<span class="r-in"><span>  crop <span class="op">=</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></span><span class="op">(</span><span class="va">coastline</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  mask <span class="op">=</span> <span class="va">coastline</span>,</span></span>
<span class="r-in"><span>  mask_inside <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:00)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Cropping raster to inputted extent... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Masking raster... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>GEOS support is provided by the sf and terra packages among others</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-15.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:01) after ~0.01 minutes. </span>
<span class="r-in"><span><span class="co"># Compare Euclidean and least-cost distances</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_euclid</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 8602.325</span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9071.48</span>
<span class="r-in"><span><span class="va">out_gebco2</span><span class="op">$</span><span class="va">dist_euclid</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 8602.325</span>
<span class="r-in"><span><span class="va">out_gebco2</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9071.48</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (7) Implement shortest distance algorithms in parallel:</span></span></span>
<span class="r-in"><span><span class="co"># With the default method ("cppRouting"), use use_all_cores = TRUE</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"cppRouting"</span>,</span></span>
<span class="r-in"><span>  crop <span class="op">=</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></span><span class="op">(</span><span class="va">coastline</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  mask <span class="op">=</span> <span class="va">coastline</span>,</span></span>
<span class="r-in"><span>  mask_inside <span class="op">=</span> <span class="cn">TRUE</span>,</span></span>
<span class="r-in"><span>  use_all_cores <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:01)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Cropping raster to inputted extent... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Masking raster... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>GEOS support is provided by the sf and terra packages among others</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> allcores argument is deprecated since v3.0. </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Please use RcppParallel::setThreadOptions() to set the number of threads</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:01) after ~0 minutes. </span>
<span class="r-in"><span><span class="co"># With method = "gdistance" use cl argument</span></span></span>
<span class="r-in"><span><span class="va">out_gebco2</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"cppRouting"</span>,</span></span>
<span class="r-in"><span>  crop <span class="op">=</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></span><span class="op">(</span><span class="va">coastline</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  mask <span class="op">=</span> <span class="va">coastline</span>,</span></span>
<span class="r-in"><span>  mask_inside <span class="op">=</span> <span class="cn">TRUE</span>,</span></span>
<span class="r-in"><span>  cl <span class="op">=</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">2L</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:01)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 'cl' or 'varlist' arguments ignored for method = 'cppRouting': use use_all_cores = TRUE instead.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Cropping raster to inputted extent... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Masking raster... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>GEOS support is provided by the sf and terra packages among others</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:02) after ~0.01 minutes. </span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9071.48</span>
<span class="r-in"><span><span class="va">out_gebco2</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9071.48</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">############################################################################</span></span></span>
<span class="r-in"><span><span class="co">#### Shortest paths between a single origin and a single destination</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (8) Shortest paths (goal = 2) only using default method</span></span></span>
<span class="r-in"><span><span class="co"># Implement function</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">2</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:02)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost paths(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:02) after ~0 minutes. </span>
<span class="r-in"><span><span class="co"># The path is stored in path_lcp, This includes:</span></span></span>
<span class="r-in"><span><span class="co"># ... (a) a dataframe with the cells comprising each path:</span></span></span>
<span class="r-in"><span><span class="co"># ... (b) a SpatialLines object of the path</span></span></span>
<span class="r-in"><span><span class="co"># ... (c) a matrix of the coordinates of the path</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">path_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cells</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   path_id path origin destination cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1       1  1-6      1           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2       1  1-6      1           6    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3       1  1-6      1           6    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,]  7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [3,]  2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># For method = "cppRouting", paths between pairs of coordinates are computed</span></span></span>
<span class="r-in"><span><span class="co"># ... by cppRouting::get_path_pair(), the arguments of which are retained in</span></span></span>
<span class="r-in"><span><span class="co"># ... this list:</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">cppRouting_param</span><span class="op">$</span><span class="va">get_path_pair_param</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    from to      dist</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1     0  3  7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2     1  3  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3     2  3  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4     3  0  7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5     4  0  8.602325</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6     1  0 10.677078</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7     2  0 10.295630</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 8     5  0  9.273618</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9     0  4  8.602325</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 10    2  4  7.348469</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 11    5  4  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 12    3  1  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 13    0  1 10.677078</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 14    2  1  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 15    6  1  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 16    7  1  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 17    3  2  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 18    0  2 10.295630</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 19    4  2  7.348469</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 20    1  2  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 21    5  2  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 22    6  2  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 23    7  2  7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 24    8  2  8.660254</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 25    0  5  9.273618</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 26    4  5  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 27    2  5  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 28    7  5  7.348469</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 29    8  5  5.385165</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 30    1  6  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 31    2  6  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 32    7  6  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 33    1  7  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 34    2  7  7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 35    5  7  7.348469</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 36    6  7  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 37    8  7  5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 38    2  8  8.660254</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 39    5  8  5.385165</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 40    7  8  5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 41    3  0  7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 42    3  1  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 43    3  2  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 44    0  3  7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 45    0  4  8.602325</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 46    0  1 10.677078</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 47    0  2 10.295630</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 48    0  5  9.273618</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 49    4  0  8.602325</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 50    4  2  7.348469</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 51    4  5  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 52    1  3  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 53    1  0 10.677078</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 54    1  2  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 55    1  6  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 56    1  7  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 57    2  3  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 58    2  0 10.295630</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 59    2  4  7.348469</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 60    2  1  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 61    2  5  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 62    2  6  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 63    2  7  7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 64    2  8  8.660254</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 65    5  0  9.273618</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 66    5  4  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 67    5  2  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 68    5  7  7.348469</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 69    5  8  5.385165</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 70    6  1  5.830952</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 71    6  2  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 72    6  7  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 73    7  1  8.124038</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 74    7  2  7.071068</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 75    7  5  7.348469</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 76    7  6  5.099020</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 77    7  8  5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 78    8  2  8.660254</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 79    8  5  5.385165</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 80    8  7  5.000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$coords</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   node    X    Y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2    2  7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4    4  2.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5    5  7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1    1  2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3    3 12.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6    6 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7    7  2.5  2.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 8    8  7.5  2.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9    9 12.5  2.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$nbnode</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 9</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$dict</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ref id</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1   2  0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2   4  1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3   5  2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4   1  3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5   3  4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6   6  5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7   7  6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 8   8  7</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9   9  8</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$attrib</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$attrib$aux</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$attrib$cap</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$attrib$alpha</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $Graph$attrib$beta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $from</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $algorithm</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "bi"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $constant</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $keep</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $long</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># Note the path is also added to the plot produced, if plot = TRUE.</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (9) Shortest distances and paths (goal = 3) using default method</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:02)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-16.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost paths(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:02) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 13.95499</span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">path_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cells</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   path_id path origin destination cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1       1  1-6      1           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2       1  1-6      1           6    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3       1  1-6      1           6    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,]  7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [3,]  2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (10) Shortest distances and paths (goal = 3) via gdistance</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:02)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-17.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:02) after ~0 minutes. </span>
<span class="r-in"><span><span class="co"># As above, paths are stored in path_lcp and distances in dist_lcp</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">path_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cells</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   path_id path origin destination cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1       1  1-6      1           6    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2       1  1-6      1           6    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3       1  1-6      1           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : NA </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,]  2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,]  7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [3,] 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># For method = "gdistance", paths between pairs of coordinates are computed</span></span></span>
<span class="r-in"><span><span class="co"># ... by repeated calls to gdistance::shortestPath(), for each pair of coordinates</span></span></span>
<span class="r-in"><span><span class="co"># ... in the following list of arguments:</span></span></span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">gdistance_param</span><span class="op">$</span><span class="va">shortestPath_param</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class      : TransitionLayer </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dimensions : 3, 3, 9  (nrow, ncol, ncell)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> resolution : 5, 5  (x, y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent     : 0, 15, 0, 15  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs        : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> values      : conductance </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> matrix class: dsCMatrix </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $fromCoords</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $toCoords</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x   y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 12.5 7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (11): Parallelisation proceeds as described above via</span></span></span>
<span class="r-in"><span><span class="co"># ... use_all_cores or cl arguments. For cppRouting, parallelisation</span></span></span>
<span class="r-in"><span><span class="co"># ... is only implemented for distance calculations (so not if goal = 2),</span></span></span>
<span class="r-in"><span><span class="co"># ... while parallelisation is implemented for both distance and shortest</span></span></span>
<span class="r-in"><span><span class="co"># ... paths for method = "gdistance"</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  use_all_cores <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:02)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> allcores argument is deprecated since v3.0. </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Please use RcppParallel::setThreadOptions() to set the number of threads</span>
<span class="r-plt img"><img src="lcp_over_surface-18.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost paths(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:02) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  cl <span class="op">=</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">2L</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:02)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-19.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:08) after ~0.1 minutes. </span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  cl <span class="op">=</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">2L</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:08)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:13) after ~0.09 minutes. </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">############################################################################</span></span></span>
<span class="r-in"><span><span class="co">#### Shortest distances/paths between origin/destination pairs</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (12): Shortest distances/paths computed in sequence:</span></span></span>
<span class="r-in"><span><span class="co"># cppRouting method</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:13)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-20.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost paths(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:14) after ~0 minutes. </span>
<span class="r-in"><span><span class="co"># gdistance method</span></span></span>
<span class="r-in"><span><span class="va">out2</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:14)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-21.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:14) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 8.124038 9.273618</span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">path_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cells</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   path_id path origin destination cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1       1  2-6      2           6    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2       1  1-5      1           5    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3       2  2-6      2           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 7.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`2`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 12.5, 12.5, 7.5, 7.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`2`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x   y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 12.5 7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="va">out2</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 8.124038 9.273618</span>
<span class="r-in"><span><span class="va">out2</span><span class="op">$</span><span class="va">path_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cells</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   path_id path origin destination cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1       1  1-5      1           5    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2       1  1-5      1           5    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3       2  2-6      2           6    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4       2  2-6      2           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 2.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : NA </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`2`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 7.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : NA </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`2`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,]  7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (13): Shortest distances/paths computed in parallel:</span></span></span>
<span class="r-in"><span><span class="co"># cppRouting method for goal 3</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  use_all_cores <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:14)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost distance(s)... </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> allcores argument is deprecated since v3.0. </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Please use RcppParallel::setThreadOptions() to set the number of threads</span>
<span class="r-plt img"><img src="lcp_over_surface-22.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing bi algorithm to compute least-cost paths(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:14) after ~0 minutes. </span>
<span class="r-in"><span><span class="co"># gdistance method for goal 2</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  cl <span class="op">=</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">2L</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:14)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-23.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:22) after ~0.13 minutes. </span>
<span class="r-in"><span><span class="co"># gdistance method for goal 3</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  cl <span class="op">=</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">2L</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:22)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:34) after ~0.2 minutes. </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">############################################################################</span></span></span>
<span class="r-in"><span><span class="co">#### Shortest distances/paths between all origin/destination combinations</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (14) Compute all combinations via combination = "matrix"</span></span></span>
<span class="r-in"><span><span class="co"># cppRouting goal 3</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  cppRouting_algorithm <span class="op">=</span> <span class="st">"phast"</span>,</span></span>
<span class="r-in"><span>  combination <span class="op">=</span> <span class="st">"matrix"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:34)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-24.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing phast algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... .... Implementing Dijkstra's algorithm recursively to compute least-cost paths(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:34) after ~0 minutes. </span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_euclid</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>          5         6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 7.071068 11.180340</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2 5.000000  7.071068</span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           5         6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1  8.124038 13.954990</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2 10.295630  9.273618</span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">path_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cells</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   path_id path origin destination cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1       1  1-6      1           6    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2       1  1-6      1           6    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3       1  1-5      1           5    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4       2  2-5      2           5    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5       2  1-6      1           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6       3  2-6      2           6    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7       3  2-5      2           5    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 8       4  2-6      2           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 2.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`2`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 7.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`3`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 7.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`4`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 12.5, 12.5, 7.5, 7.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [3,] 7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`2`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,]  7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`3`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`4`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x   y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 12.5 7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># cppRouting goal 3 parallelised</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  combination <span class="op">=</span> <span class="st">"matrix"</span>,</span></span>
<span class="r-in"><span>  cppRouting_algorithm <span class="op">=</span> <span class="st">"phast"</span>,</span></span>
<span class="r-in"><span>  use_all_cores <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:34)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing phast algorithm to compute least-cost distance(s)... </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> allcores argument is deprecated since v3.0. </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Please use RcppParallel::setThreadOptions() to set the number of threads</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... .... Implementing Dijkstra's algorithm recursively to compute least-cost paths(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:34) after ~0 minutes. </span>
<span class="r-in"><span><span class="co"># gdistance goal 3</span></span></span>
<span class="r-in"><span><span class="va">out1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">rxy</span><span class="op">[</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">r</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  combination <span class="op">=</span> <span class="st">"matrix"</span>,</span></span>
<span class="r-in"><span>  cl <span class="op">=</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">2L</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:34)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-25.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:44) after ~0.16 minutes. </span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_euclid</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>          5         6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 7.071068 11.180340</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2 5.000000  7.071068</span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           5         6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1  8.124038 13.954990</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2 10.295630  9.273618</span>
<span class="r-in"><span><span class="va">out1</span><span class="op">$</span><span class="va">path_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cells</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   path_id path origin destination cell</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1       1  1-5      1           5    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2       1  1-5      1           5    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3       2  2-5      2           5    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4       2  2-5      2           5    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5       3  1-6      1           6    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6       3  1-6      1           6    5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7       3  1-6      1           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 8       4  2-6      2           6    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9       4  2-6      2           6    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 2.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : NA </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`2`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 7.5, 7.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : NA </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`3`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 2.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : NA </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $SpatialLines$`4`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> class       : SpatialLines </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> features    : 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> extent      : 7.5, 12.5, 7.5, 12.5  (xmin, xmax, ymin, ymax)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> crs         : NA </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`1`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`2`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] 7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`3`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,]  2.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,]  7.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [3,] 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $coordinates$`4`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x    y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,]  7.5 12.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,] 12.5  7.5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#### Example (15): Real world example with multiple origins/destinations</span></span></span>
<span class="r-in"><span><span class="co">## Zoom in on an area of interest</span></span></span>
<span class="r-in"><span><span class="va">ext</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/extent.html" class="external-link">extent</a></span><span class="op">(</span><span class="fl">715000</span>, <span class="fl">720000</span>, <span class="fl">6250000</span>, <span class="fl">6260000</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dat_gebco_utm_planar_zoom</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/crop.html" class="external-link">crop</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar</span>, <span class="va">ext</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co">## Define example origins/destinations</span></span></span>
<span class="r-in"><span><span class="co"># Define available coordinates</span></span></span>
<span class="r-in"><span><span class="va">dat_gebco_utm_planar_zoom_xy</span> <span class="op">&lt;-</span> <span class="fu">raster</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sp/man/coordinates.html" class="external-link">coordinates</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar_zoom</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Sample random origins</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">2019</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">index</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar_zoom_xy</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">origin</span> <span class="op">&lt;-</span> <span class="va">dat_gebco_utm_planar_zoom_xy</span><span class="op">[</span><span class="va">index</span>, <span class="op">]</span></span></span>
<span class="r-in"><span><span class="co"># Sample random destinations</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">2020</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">index</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">dat_gebco_utm_planar_zoom_xy</span><span class="op">)</span>, <span class="fl">3</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">destination</span> <span class="op">&lt;-</span> <span class="va">dat_gebco_utm_planar_zoom_xy</span><span class="op">[</span><span class="va">index</span>, <span class="op">]</span></span></span>
<span class="r-in"><span><span class="co"># Implement algorithm</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"gdistance"</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  combination <span class="op">=</span> <span class="st">"matrix"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:44)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-plt img"><img src="lcp_over_surface-26.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'gdistance'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining 'ease' matrix... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing Dijkstra's algorithm to compute least-cost path(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:44) after ~0.01 minutes. </span>
<span class="r-in"><span><span class="va">out_gebco2</span> <span class="op">&lt;-</span> <span class="fu">lcp_over_surface</span><span class="op">(</span></span></span>
<span class="r-in"><span>  origin <span class="op">=</span> <span class="va">origin</span>,</span></span>
<span class="r-in"><span>  destination <span class="op">=</span> <span class="va">destination</span>,</span></span>
<span class="r-in"><span>  surface <span class="op">=</span> <span class="va">dat_gebco_utm_planar</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"cppRouting"</span>,</span></span>
<span class="r-in"><span>  goal <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  combination <span class="op">=</span> <span class="st">"matrix"</span>,</span></span>
<span class="r-in"><span>  cppRouting_algorithm <span class="op">=</span> <span class="st">"phast"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> flapper::lcp_over_surface() called (@ 2023-08-29 15:44:44)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Checking user inputs... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Defining cost matrix... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>transition function gives negative values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Calculating Euclidean distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... Using method = 'cppRouting'... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Defining nodes, edges and costs to make graph... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Constructing graph object... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... ... Implementing phast algorithm to compute least-cost distance(s)... </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... .... Implementing Dijkstra's algorithm recursively to compute least-cost paths(s)... </span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>number of rows of result is not a multiple of vector length (arg 1)</span>
<span class="r-plt img"><img src="lcp_over_surface-27.png" alt="" width="700" height="433"></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ... flapper::lcp_over_surface() call completed (@ 2023-08-29 15:44:45) after ~0.01 minutes. </span>
<span class="r-in"><span><span class="co"># The function returns distances between all combinations</span></span></span>
<span class="r-in"><span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>          2945     2463      3438</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2610 3375.062 4064.206 6062.3124</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3544 3270.267 5106.123  707.1401</span>
<span class="r-in"><span><span class="va">out_gebco2</span><span class="op">$</span><span class="va">dist_lcp</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>          2945     2463      3438</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2610 3375.062 4064.206 6062.3124</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3544 3270.267 5106.123  707.1401</span>
<span class="r-in"><span><span class="co"># The two outputs are the same (though the ordering of factor levels differs)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">out_gebco1</span><span class="op">$</span><span class="va">path_lcp</span><span class="op">$</span><span class="va">cells</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 'data.frame':	83 obs. of  5 variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ path_id    : num  1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ path       : Factor w/ 6 levels "2610-2945","3544-2945",..: 1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ origin     : int  2610 2610 2610 2610 2610 2610 2610 2610 2610 2610 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ destination: int  2945 2945 2945 2945 2945 2945 2945 2945 2945 2945 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ cell       : int  2610 2665 2666 2667 2668 2723 2778 2833 2834 2835 ...</span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">out_gebco2</span><span class="op">$</span><span class="va">path_lcp</span><span class="op">$</span><span class="va">cells</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 'data.frame':	72 obs. of  5 variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ path_id    : num  1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ path       : Factor w/ 6 levels "2610-2945","2610-2463",..: 2 2 2 2 2 2 2 2 2 2 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ origin     : int  2610 2610 2610 2610 2610 2610 2610 2610 2610 2610 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ destination: int  2463 2463 2463 2463 2463 2463 2463 2463 2463 2463 ...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  $ cell       : int  2462 2461 2460 2459 2458 2457 2456 2455 2508 2561 ...</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Edward Lavender.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

