<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Process a Raster* by aggregation and quantify the error induced by this process — process_surface • flapper</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Process a Raster* by aggregation and quantify the error induced by this process — process_surface" />
<meta property="og:description" content="This function reduces the resolution of a raster by multiple aggregation methods and then quantifies the relative error induced by each method from the differences between the original values and the aggregated values. To implement the function, a raster (x) must be supplied as well as an aggregation factor (fact) and a named list of functions (stat) used to aggregate the raster. The raster is aggregated using each method (function) and mapped back onto the original resolution for calculation of the differences between the original raster and the aggregated raster(s). The function returns a visual statistical summary of the differences (if plot = TRUE) and a named list comprising the aggregated raster(s) and the re-sampled version(s) of those mapped back onto the original resolution." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flapper</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/flapper.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/edwardlavender/flapper/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Process a Raster* by aggregation and quantify the error induced by this process</h1>
    <small class="dont-index">Source: <a href='https://github.com/edwardlavender/flapper/blob/master/R/processing.R'><code>R/processing.R</code></a></small>
    <div class="hidden name"><code>process_surface.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function reduces the resolution of a <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> by multiple aggregation methods and then quantifies the relative error induced by each method from the differences between the original values and the aggregated values. To implement the function, a <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> (<code>x</code>) must be supplied as well as an aggregation factor (<code>fact</code>) and a named list of functions (<code>stat</code>) used to aggregate the <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>. The <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> is aggregated using each method (function) and mapped back onto the original resolution for calculation of the differences between the original <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> and the aggregated <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>(s). The function returns a visual statistical summary of the differences (if <code>plot = TRUE</code>) and a named list comprising the aggregated <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>(s) and the re-sampled version(s) of those mapped back onto the original resolution.</p>
    </div>

    <pre class="usage"><span class='fu'>process_surface</span><span class='op'>(</span>
  <span class='va'>x</span>,
  fact <span class='op'>=</span> <span class='fl'>2L</span>,
  stat <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>mean <span class='op'>=</span> <span class='va'>mean</span><span class='op'>)</span>,
  <span class='va'>...</span>,
  plot <span class='op'>=</span> <span class='cn'>TRUE</span>,
  cl <span class='op'>=</span> <span class='cn'>NULL</span>,
  varlist <span class='op'>=</span> <span class='cn'>NULL</span>,
  verbose <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>x</th>
      <td><p>A <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> to be processed. For implementations preceding a call to of one of <code><a href='flapper.html'>flapper</a></code>'s particle filtering algorithms, <code>x</code> should be planar (i.e., Universal Transverse Mercator projection) with equal resolution in the x, y directions and identical units in the x, y and z directions (see <code><a href='pf.html'>pf</a></code>).</p></td>
    </tr>
    <tr>
      <th>fact</th>
      <td><p>A positive integer that defines by how much <code>x</code> should be aggregated (see <code><a href='https://rdrr.io/pkg/raster/man/aggregate.html'>aggregate</a></code>).</p></td>
    </tr>
    <tr>
      <th>stat</th>
      <td><p>A named list of functions used to aggregate <code>x</code> (see the <code>fun</code> argument of <code><a href='https://rdrr.io/pkg/raster/man/aggregate.html'>aggregate</a></code>).</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Additional arguments passed to <code><a href='https://rdrr.io/pkg/raster/man/aggregate.html'>aggregate</a></code> to control aggregation.</p></td>
    </tr>
    <tr>
      <th>plot</th>
      <td><p>A logical input that defines whether or not to plot a summary of the differences between the original <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> (<code>x</code>) and the aggregated <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>(s). If specified, the minimum, median and maximum difference are shown for each statistic (<code>stat</code>).</p></td>
    </tr>
    <tr>
      <th>cl, varlist</th>
      <td><p>(optional) Parallelisation options. <code>cl</code> is (a) a cluster object from <code><a href='https://rdrr.io/r/parallel/makeCluster.html'>makeCluster</a></code> or (b) an integer that defines the number of child processes. <code>varlist</code> is a character vector of variables for export (see <code><a href='cl.html'>cl_export</a></code>). Exported variables must be located in the global environment. If a cluster is supplied, the connection to the cluster is closed within the function (see <code><a href='cl.html'>cl_stop</a></code>). For further information, see <code><a href='cl.html'>cl_lapply</a></code> and <code><a href='flapper-tips-parallel.html'>flapper-tips-parallel</a></code>.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>A logical input that defines whether or not to print messages to the console to relay function progress.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The function returns a plot of the differences between the original and aggregated <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>(s), if <code>plot = TRUE</code>, and a named list of (a) the aggregated <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>(s) (`agg_by_stat'), (b) the aggregated, resampled <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code>(s) (`agg_by_stat_rs') and (c) the summary statistics plotted.</p>
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>This function was motivated by the particle filtering algorithms in <code><a href='flapper.html'>flapper</a></code> (e.g., <code><a href='pf.html'>pf</a></code>). For these algorithms, it is computationally beneficial to reduce <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> resolution, where possible, by aggregation. To facilitate this process, this function quantifies the relative error induced by different aggregation functions. If appropriate, the particle filtering algorithm(s) can then be implemented using the aggregated <code><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></code> that minimises the error, with the magnitude of that error propagated via the <code>depth_error</code> parameter.</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p><code><a href='https://rdrr.io/pkg/raster/man/aggregate.html'>aggregate</a></code>, <code><a href='https://rdrr.io/pkg/raster/man/resample.html'>resample</a></code></p></div>
    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Edward Lavender</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'># Define the raster for which to implement the function</span>
<span class='va'>x</span> <span class='op'>&lt;-</span> <span class='va'>dat_gebco</span>
<span class='va'>blank</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/raster.html'>raster</a></span><span class='op'>(</span><span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/extent.html'>extent</a></span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span>, crs <span class='op'>=</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/projection.html'>crs</a></span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span>, resolution <span class='op'>=</span> <span class='fl'>250</span><span class='op'>)</span>
<span class='va'>x</span> <span class='op'>&lt;-</span> <span class='fu'>raster</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/raster/man/resample.html'>resample</a></span><span class='op'>(</span><span class='va'>x</span>, <span class='va'>blank</span>, method <span class='op'>=</span> <span class='st'>"bilinear"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of columns</span></div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of rows</span></div><div class='input'><span class='co'># Implement function using a list of statistics</span>
<span class='va'>out</span> <span class='op'>&lt;-</span> <span class='fu'>process_surface</span><span class='op'>(</span><span class='va'>x</span>, fact <span class='op'>=</span> <span class='fl'>2</span>, stat <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>min <span class='op'>=</span> <span class='va'>min</span>, mean <span class='op'>=</span> <span class='va'>mean</span>, median <span class='op'>=</span> <span class='va'>median</span>, max <span class='op'>=</span> <span class='va'>max</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; flapper::process_surface() called (@ 2022-06-17 10:08:17)... 
#&gt; ... Aggregating raster... </div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of columns</span></div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of rows</span></div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of columns</span></div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of rows</span></div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of columns</span></div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of rows</span></div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of columns</span></div><div class='output co'>#&gt; <span class='warning'>Warning: aggregation factor is larger than the number of rows</span></div><div class='output co'>#&gt; ... Resampling aggregated raster(s) back onto the original resolution... 
#&gt; ... Computing differences between the original and aggregated raster(s)... 
#&gt; ... Summarising the differences between rasters across statistic(s)... </div><div class='output co'>#&gt; <span class='warning'>Warning: no non-missing arguments to min; returning Inf</span></div><div class='output co'>#&gt; <span class='warning'>Warning: no non-missing arguments to min; returning Inf</span></div><div class='output co'>#&gt; <span class='warning'>Warning: no non-missing arguments to min; returning Inf</span></div><div class='output co'>#&gt; <span class='warning'>Warning: no non-missing arguments to min; returning Inf</span></div><div class='output co'>#&gt; <span class='warning'>Warning: no non-missing arguments to max; returning -Inf</span></div><div class='output co'>#&gt; <span class='warning'>Warning: no non-missing arguments to max; returning -Inf</span></div><div class='output co'>#&gt; <span class='warning'>Warning: no non-missing arguments to max; returning -Inf</span></div><div class='output co'>#&gt; <span class='warning'>Warning: no non-missing arguments to max; returning -Inf</span></div><div class='output co'>#&gt; <span class='message'>4 observation pair(s) in x are NA; these are removed.</span></div><div class='output co'>#&gt; <span class='error'>Error in (function (side = 1:4, x = list(), lim = list(), pretty = list(n = 5),     units = list(), axis = list(), pi_notation = NULL, control_axis = list(las = TRUE),     control_sci_notation = list(), control_digits = NULL, control_factor_lim = 0.5,     axis_ls = NULL, add = FALSE, return_list = TRUE, ...) {    if (is.null(axis_ls)) {        if (length(side) == 3)             stop("Three axis sides are not currently supported.")        if (length(side) &gt; 1) {            if (!(side[1] %in% c(1, 3)))                 stop("side[1] should refer to an x axis (i.e., side[1] = 1 or 3).")            if (!(side[2] %in% c(2, 4)))                 stop("side[2] should refer to a y axis (i.e., side[2] = 2 or 4).")        }        if (length(x) == 0) {            if (length(lim) == 0) {                stop("'x' or 'lim' must be supplied.")            }            else {                message("pretty_axis() 'x' values taken from 'lim'.")                x &lt;- lim            }        }        check_input_class(arg = "x", input = x, if_class = NULL,             to_class = "list", type = "stop")        lim &lt;- empty_list_to_list_null("lim", lim)        pretty &lt;- empty_list_to_list_null("pretty", pretty)        units &lt;- empty_list_to_list_null("units", units)        axis &lt;- empty_list_to_list_null("axis", axis)        if (is.null(pi_notation))             pi_notation &lt;- lapply(1:length(side), function(x) -1)        pi_notation &lt;- empty_list_to_list_null("pi_notation",             pi_notation)        mapply(list(x, lim, units), list("x", "lim", "units"),             FUN = function(elm, elm_name) {                if (length(elm) &gt; 0 &amp; length(elm) &gt; length(side)) {                  stop(paste0(length(side), " side(s) supplied but argument '",                     elm_name, "' contains ", length(elm), " elements."))                }            })        x &lt;- mapply(x, 1:length(x), FUN = function(elm, i) {            arg &lt;- paste0("x[[", i, "]]")            elm &lt;- check_input_class(arg = arg, input = elm,                 if_class = "character", to_class = "factor",                 type = "warning", coerce_input = factor)            elm &lt;- check_tz(arg, elm)            return(elm)        }, SIMPLIFY = FALSE)        lim &lt;- mapply(lim, 1:length(lim), FUN = function(elm,             i) {            arg &lt;- paste0("lim[[", i, "]]")            elm &lt;- check_tz(arg, elm)            return(elm)        }, SIMPLIFY = FALSE)        lx &lt;- sapply(x, length)        if (length(unique(lx)) != 1) {            message("'x' contains elements with different numbers of observations; collapsing each element (i) in 'x' to range(i).")            x &lt;- lapply(x, function(e) {                if (inherits(e, "factor")) {                  rng &lt;- range_factor(e)                }                else {                  rng &lt;- range(e, na.rm = TRUE)                }                return(rng)            })            lx &lt;- c(2, 2)        }        dat &lt;- data.frame(do.call(cbind, x))        dat &lt;- dat[stats::complete.cases(dat), , drop = FALSE]        nrw &lt;- nrow(dat)        if (nrw != lx[1]) {            lna &lt;- lx[1] - nrw            message(paste(lna, "observation pair(s) in x are NA; these are removed."))            x &lt;- lapply(1:ncol(dat), function(i) return(dat[,                 i]))            if (length(x[[1]]) &lt; 1)                 stop("No non NA observations left in x.")        }        lim &lt;- list_adjust(l = lim, f = length, side = side)        pretty &lt;- list_adjust(l = pretty, f = list_depth, side = side)        units &lt;- list_adjust(l = units, f = length, side = side)        axis &lt;- list_adjust(l = axis, f = list_depth, side = side)        pi_notation &lt;- list_adjust(l = pi_notation, f = list_depth,             side = side)        dots &lt;- list(...)        dnms &lt;- names(dots)        if (!is.null(dnms)) {            for (param in c("cex.axis", "cex.lab", "col.axis",                 "col.lab", "font.axis", "font.lab", "las")) {                if (param %in% dnms)                   control_axis[[param]] &lt;- dots[[param]]            }        }        axis_ls &lt;- mapply(side, x, lim, pretty, units, axis,             pi_notation, SIMPLIFY = FALSE, FUN = function(iside,                 ix, ilim, ipretty, iunits, iaxis, ipi) {                testing &lt;- FALSE                if (testing) {                  iside &lt;- side[1]                  ix &lt;- x[[1]]                  ilim &lt;- lim[[1]]                  ipretty &lt;- pretty[[1]]                  iunits &lt;- units[[1]]                  iaxis &lt;- axis[[1]]                  ipi &lt;- pi_notation[[1]]                }                if (inherits(ilim, "list"))                   ilim &lt;- Reduce(c, ilim)                ipretty &lt;- compact(ipretty)                iunits &lt;- unlist(compact(iunits))                iaxis &lt;- compact(iaxis)                ipi &lt;- compact(ipi)                ipi &lt;- compact(ipi)                if (all(sapply(1:length(ipi), function(i) isTRUE(unlist(ipi)[i] ==                   -1))))                   ipi &lt;- NULL                if (is_number(ix)) {                  if (!is.null(ipi)) {                    ix &lt;- ix/pi                    if (!is.null(ilim))                       ilim &lt;- ilim/pi                  }                }                else {                  if (!is.null(ipi))                     warning("pi_notation argument(s) ignored for non-numeric variable(s).")                }                iunits_warn &lt;- ifelse(length(iunits) != 0, TRUE,                   FALSE)                iunits &lt;- units_x(iunits, x = ix)                ilim &lt;- define_lim_init(x = ix, at = iaxis$at,                   lim = ilim)                if (is.null(iaxis$at)) {                  if (length(ipretty) &gt; 0) {                    if (iunits_warn)                       warning("Both pretty and units specified for an axis. pretty arguments implemented.")                    pretty_seq_ls &lt;- pretty_seq(x = ix, lim = ilim,                       pretty_args = ipretty)                    iaxis$at &lt;- pretty_seq_ls$at                    ilim &lt;- pretty_seq_ls$lim                  }                  else {                    iaxis$at &lt;- seq_x(ilim[1], ilim[2], units = iunits)                  }                }                if (is.factor(ix)) {                  ilim &lt;- c(min(ilim) - control_factor_lim, max(ilim) +                     control_factor_lim)                  attributes(ilim)$user &lt;- c(FALSE, FALSE)                }                if (is.null(iaxis$labels))                   iaxis$labels &lt;- pretty_labels(x = ix, at = iaxis$at,                     n = control_digits, pi_notation_args = ipi,                     sci_notation_args = control_sci_notation)                if (is_number(ix) &amp; !is.null(ipi)) {                  ilim &lt;- ilim * pi                  iaxis$at &lt;- iaxis$at * pi                }                iaxis$side &lt;- iside                if (length(control_axis) &gt; 0)                   iaxis &lt;- rlist::list.merge(iaxis, control_axis)                out &lt;- list(axis = iaxis, lim = ilim)                return(out)            })        names(axis_ls) &lt;- side        s1s &lt;- c("1", "2", "3", "4")        s2s &lt;- list(c("2", "4"), c("1", "3"), c("2", "4"), c("1",             "3"))        sfs &lt;- list(min, min, max, max)        for (s in 1:4) {            s1 &lt;- s1s[s]            s2 &lt;- s2s[[s]]            s21 &lt;- s2[1]            s22 &lt;- s2[2]            sf &lt;- sfs[[s]]            if (s1 %in% side) {                if (is.null(axis_ls[[s1]]$axis$pos) &amp; !is.null(axis_ls[[s21]]$axis) |                   !is.null(axis_ls[[s22]]$axis)) {                  s2select &lt;- s2[which(c(!is.null(axis_ls[[s21]]$axis),                     !is.null(axis_ls[[s22]]$axis)))]                  s2select &lt;- s2select[1]                  axis_ls[[s1]]$axis$pos &lt;- sf(axis_ls[[s2select]]$lim)                }            }        }    }    if (any(is.na(names(axis_ls)))) {        stop("names(axis_ls) contains NA(s). The number of sides and the number of elements in argument lists is not aligned.")    }    if (add) {        lapply(axis_ls, function(elem) {            tmp_axis_args &lt;- elem$axis            tmp_axis_args$at &lt;- elem$lim            tmp_axis_args$lwd.ticks &lt;- c(0, 0)            tmp_axis_args$labels &lt;- c("", "")            at &lt;- elem$axis$at            add_axis &lt;- choose_foo_axis(at)            do.call(add_axis, tmp_axis_args)            do.call(add_axis, elem$axis)        })    }    if (return_list)         return(axis_ls)})(add = FALSE, type = "n", side = 1:2, pretty = list(n = 5),     x = list(structure(1:4, .Label = c("min", "mean", "median",     "max"), class = "factor"), c(min = NaN, mean = NaN, median = NaN,     max = NaN)), lim = list(x = NULL, y = c(-Inf, Inf))): No non NA observations left in x.</span></div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span><span class='op'>(</span><span class='va'>out</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='error'>Error in summary(out): object 'out' not found</span></div><div class='input'>
</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Edward Lavender.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


