if(lrunknown > 0){
pos <- which(acoustics$receiver_id %in% runknown)
lpos <- length(pos)
warn <- paste0("Check 1 (receiver identity): failed. ",
lrunknown, " receiver identities unknown (", paste(runknown, collapse = ", "), "), ",
"corresponding to ", lpos, " observations in acoustics. \n")
warning(warn)
acoustics <- acoustics[-pos, ]
} else{
message("Check 1 (receiver identity): passed. \n")
}
match_receiver <- match(acoustics$receiver_id, moorings$receiver_id)
acoustics$receiver_start_date <- moorings$receiver_start_date[match_receiver]
acoustics$receiver_end_date <- moorings$receiver_end_date[match_receiver]
acoustics$interval <- lubridate::interval(acoustics$receiver_start_date, acoustics$receiver_end_date)
acoustics$not_within <- !(acoustics$timestamp %within% acoustics$interval)
if(length(which(acoustics$not_within)) > 0){
pos <- which(acoustics$not_within)
lpos <- length(pos)
warn <- paste0("Check 3 (receiver deployment windows): failed. ",
lpos, " observations in acoustics outside of receiver deployment windows. \n")
warning(warn)
acoustics <- acoustics[-pos, ]
} else{
message("Check 3 (receiver deployment windows): passed. \n")
}
?dat_ids
head(acoustics)
ids = dat_ids
library(glatos)
?false_detections
return()
?return
f <- function() return())
f <- function() return()
f(1)
f <- function(x) return()
f(1)
f(2)
f <- function(x)
f(2)
f <- function(x)
f <- function(x) x * 1
f(1)
f(2)
void()
?void
#### Define a convenience function to add erroneous data to
# ... acoustics to demonstrate quality_check()
add_erroneous_row <- function(acoustics, row = nrow(acoustics), col, val){
tmp_ls <- lapply(val, function(v){
tmp <- acoustics[row, ]
tmp[1, col] <- v
return(tmp)
})
tmp <- dplyr::bind_rows(tmp_ls)
acoustics <- rbind(acoustics, tmp)
return(acoustics)
}
rm(list = )
library(lubridate) # %within%
library(flapper)
acoustics = dat_acoustics
moorings = dat_moorings
ids = dat_ids
#### Add erroneous data to acoustics for demonstrating quality_check()
## Define a convenience function to add erroneous data to
# ... acoustics to demonstrate quality_check()
add_erroneous_row <- function(acoustics, row = nrow(acoustics), col, val){
tmp_ls <- lapply(val, function(v){
tmp <- acoustics[row, ]
tmp[1, col] <- v
return(tmp)
})
tmp <- dplyr::bind_rows(tmp_ls)
acoustics <- rbind(acoustics, tmp)
return(acoustics)
}
## Add erroneous receiver ids
nrw <- nrow(acoustics)
acoustics <- add_erroneous_row(acoustics,
row = nrw,
col = "receiver_id",
val = c(100, 200, 300))
## Add erroneous timestamps (outside receiver/individual id deployment periods )
acoustics <- add_erroneous_row(acoustics,
row = nrw,
col = "timestamp",
val = as.POSIXct(c("2019-01-01", "2019-03-01"), tz = "UTC"))
## Add erroneous individual ids
acoustics <- add_erroneous_row(acoustics,
row = nrw,
col = "individual_id",
val = c(100, 200, 300))
utils::tail(acoustics, 10)
quality_check(acoustics, dat_moorings, dat_ids)
source('~/Documents/PhD/Academic_PhD_Work/Data and Modelling/Scripts/3, Chapters/Geolocation/flapper/supporting/in_development/quality_check.R')
source('~/Documents/PhD/Academic_PhD_Work/Data and Modelling/Scripts/3, Chapters/Geolocation/flapper/supporting/in_development/quality_check.R')
rm(list = ls())
library(lubridate) # %within%
library(flapper)
acoustics = dat_acoustics
moorings = dat_moorings
ids = dat_ids
#### Add erroneous data to acoustics for demonstrating quality_check()
## Define a convenience function to add erroneous data to
# ... acoustics to demonstrate quality_check()
add_erroneous_row <- function(acoustics, row = nrow(acoustics), col, val){
tmp_ls <- lapply(val, function(v){
tmp <- acoustics[row, ]
tmp[1, col] <- v
return(tmp)
})
tmp <- dplyr::bind_rows(tmp_ls)
acoustics <- rbind(acoustics, tmp)
return(acoustics)
}
## Add erroneous receiver ids
nrw <- nrow(acoustics)
acoustics <- add_erroneous_row(acoustics,
row = nrw,
col = "receiver_id",
val = c(100, 200, 300))
## Add erroneous timestamps (outside receiver/individual id deployment periods )
acoustics <- add_erroneous_row(acoustics,
row = nrw,
col = "timestamp",
val = as.POSIXct(c("2019-01-01", "2019-03-01"), tz = "UTC"))
## Add erroneous individual ids
acoustics <- add_erroneous_row(acoustics,
row = nrw,
col = "individual_id",
val = c(100, 200, 300))
## Examine erroneous data:
utils::tail(acoustics, 10)
quality_check(acoustics, dat_moorings, dat_ids)
quality_check <-
function(acoustics,
moorings,
ids){
#### Checks
## acoustics colnames
check_names(arg = "acoustics", input = acoustics,
req = c("timestamp", "receiver_id", "individual_id"),
extract_names = colnames, type = all)
## moorings colnames
check_names(arg = "moorings",
input = moorings,
req = c("receiver_id", "receiver_start_date", "receiver_end_date"),
extract_names = names, type = all)
## ids colnames
check_names(arg = "ids",
input = ids,
req = c("individual_id", "tag_start_date", "tag_end_date"),
extract_names = names, type = all)
## format of times and timezones
times_ls <-
mapply(list("acoustics$timestamp",
"moorings$receiver_start_date", "moorings$receiver_end_date",
"ids$tag_start_date", "ids$tag_end_date"),
list(acoustics$timestamp,
moorings$receiver_start_date, moorings$receiver_end_date,
ids$tag_start_date, ids$tag_end_date),
FUN = function(arg, elm){
out <- check_input_class(arg = arg,
input = elm,
if_class = NULL,
to_class = "POSIXct",
type = "warning",
coerce_input = function(x) as.POSIXct(x, tz = "UTC"))
out <- check_tz(arg, elm)
return(out)
}, SIMPLIFY = FALSE)
acoustics$timestamp          <- times_ls[[1]]
moorings$receiver_start_date <- times_ls[[2]]
moorings$receiver_end_date   <- times_ls[[3]]
ids$tag_start_date           <- times_ls[[4]]
ids$tag_end_date             <- times_ls[[5]]
#### Receiver identity
# All receivers should have been deployed in the study in question.
runknown <- unique(acoustics$receiver_id)[!(unique(acoustics$receiver_id) %in% moorings$receiver_id)]
lrunknown <- length(runknown)
if(lrunknown > 0){
pos <- which(acoustics$receiver_id %in% runknown)
lpos <- length(pos)
warn <- paste0("Check 1 (receiver identity): failed. ",
lrunknown, " receiver identities unknown (", paste(runknown, collapse = ", "), "), ",
"corresponding to ", lpos, " observations in acoustics. \n")
warning(warn)
acoustics <- acoustics[-pos, ]
} else{
message("Check 1 (receiver identity): passed. \n")
}
#### Receiver loss
# Not currently implemented.
#### Receiver operation window
match_receiver <- match(acoustics$receiver_id, moorings$receiver_id)
acoustics$receiver_start_date  <- moorings$receiver_start_date[match_receiver]
acoustics$receiver_end_date    <- moorings$receiver_end_date[match_receiver]
acoustics$interval   <- lubridate::interval(acoustics$receiver_start_date, acoustics$receiver_end_date)
acoustics$not_within <- !(acoustics$timestamp %within% acoustics$interval)
if(length(which(acoustics$not_within)) > 0){
pos  <- which(acoustics$not_within)
lpos <- length(pos)
warn <- paste0("Check 3 (receiver deployment windows): failed. ",
lpos, " observations in acoustics outside of receiver deployment windows. \n")
warning(warn)
acoustics <- acoustics[-pos, ]
} else{
message("Check 3 (receiver deployment windows): passed. \n")
}
#### Receiver servicing dates.
# Not currently implemented.
#### Tag identity
tunknown <- unique(acoustics$individual_id)[!(unique(acoustics$individual_id) %in% ids$individual_id)]
tunknown <- length(runknown)
if(trunknown > 0){
pos <- which(acoustics$individual_id %in% tunknown)
lpos <- length(pos)
warn <- paste0("Check X (tag identity): failed. ",
trunknown, " tag identities unknown (", paste(runknown, collapse = ", "), "), ",
"corresponding to ", lpos, " observations in acoustics. \n")
warning(warn)
acoustics <- acoustics[-pos, ]
} else{
message("Check X (tag identity): passed. \n")
}
#### Tag loss
# Not currently implemented.
#### Tag operation window
match_tag <- match(acoustics$individual_id, ids$individual_id)
acoustics$tag_start_date <- ids$tag_start_date[match_tag]
acoustics$tag_end_date   <- ids$tag_end_date[match_tag]
acoustics$interval   <- lubridate::interval(acoustics$tag_start_date, acoustics$tag_end_date)
acoustics$not_within <- !(acoustics$timestamp %within% acoustics$interval)
if(length(which(acoustics$not_within)) > 0){
pos  <- which(acoustics$not_within)
lpos <- length(pos)
warn <- paste0("Check 3 (receiver deployment windows): failed. ",
lpos, " observations in acoustics outside of receiver deployment windows. \n")
warning(warn)
acoustics <- acoustics[-pos, ]
} else{
message("Check 3 (receiver deployment windows): passed. \n")
}
#### Tag recapture
# Not currently implemented.
#### False detections
if(rlang::has_name(acoustics, "passed_filter")){
warn <- "Check X (false detections): 'passed_filter' column not found in acoustics. See glatos::false_detections() to analyse false detections."
warning(warn)
} else{
lpos <- length(acoustics$passed_filter == 0)
if(lpos > 1){
warn <- paste0("There are ", lpos, " false detections in the acoustics$passed_filter column.")
warning(warn)
} else{
message("Check X (false detections) passed: acoustics$passed_filter does not contain false detections. \n")
}
}
}
quality_check(acoustics, dat_moorings, dat_ids)
#### Prepare data
dat_ids$tag_end_date <- as.Date("2020-01-01", tz = "UTC")
#### Add erroneous data to acoustics for demonstrating quality_check()
## Define a convenience function to add erroneous data to
# ... acoustics to demonstrate quality_check()
add_erroneous_row <- function(acoustics, row = nrow(acoustics), col, val){
tmp_ls <- lapply(val, function(v){
tmp <- acoustics[row, ]
tmp[1, col] <- v
return(tmp)
})
tmp <- dplyr::bind_rows(tmp_ls)
acoustics <- rbind(acoustics, tmp)
return(acoustics)
}
## Add erroneous receiver ids
nrw <- nrow(dat_acoustics)
acoustics_wth_errors <- add_erroneous_row(dat_acoustics,
row = nrw,
col = "receiver_id",
val = c(100, 200, 300))
## Add erroneous timestamps (outside receiver/individual id deployment periods )
acoustics_wth_errors <- add_erroneous_row(acoustics_wth_errors,
row = nrw,
col = "timestamp",
val = as.POSIXct(c("2019-01-01", "2019-03-01"), tz = "UTC"))
## Add erroneous individual ids
acoustics_wth_errors <- add_erroneous_row(acoustics_wth_errors,
row = nrw,
col = "individual_id",
val = c(100, 200, 300))
## Examine erroneous data:
utils::tail(acoustics_wth_errors, 10)
quality_check(acoustics, dat_moorings, dat_ids)
source('~/Documents/PhD/Academic_PhD_Work/Data and Modelling/Scripts/3, Chapters/Geolocation/flapper/supporting/in_development/quality_check.R')
source('~/Documents/PhD/Academic_PhD_Work/Data and Modelling/Scripts/3, Chapters/Geolocation/flapper/supporting/in_development/quality_check.R')
View(dat_ids)
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date, tz = "UTC")
dat_moorings$receiver_end_date   <-  as.POSIXct(dat_moorings$receiver_end_date, tz = "UTC")
dat_ids$tag_start_date <- as.POSIXct(dat_ids$tag_start_date, tz = "UTC")
dat_ids$tag_end_date   <- as.POSIXct("2020-01-01", tz = "UTC")
library(flapper)
devtools::spell_check()
library(flapper)
?quality_check
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date, tz = "UTC")
dat_moorings$receiver_end_date   <-  as.POSIXct(dat_moorings$receiver_end_date, tz = "UTC")
dat_ids$tag_start_date <- as.POSIXct(dat_ids$tag_start_date, tz = "UTC")
dat_ids$tag_end_date   <- as.POSIXct("2020-01-01", tz = "UTC")
#### Implement quality_check() on processed data as a final check for any issues
quality_check(dat_acoustics, dat_moorings, dat_ids)
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date, tz = "UTC")
lubridate::tz(dat_moorings$receiver_start_date)
library(flapper)
?quality_check
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date)
lubridate::tz(dat_moorings$receiver_start_date) <- "UTC"
dat_moorings$receiver_end_date   <-  as.POSIXct(dat_moorings$receiver_end_date)
lubridate::tz(dat_moorings$receiver_end_date) <- "UTC"
dat_ids$tag_start_date <- as.POSIXct(dat_ids$tag_start_date)
lubridate::tz(dat_ids$tag_start_date) <- "UTC"
## tag_end_date column needed in dat_ids
dat_ids$tag_end_date   <- as.POSIXct("2020-01-01", tz = "UTC")
#### Implement quality_check() on processed data as a final check for any issues
quality_check(dat_acoustics, dat_moorings, dat_ids)
library(flapper)
#### Prepare data
## Times should be in POSIXct format
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date)
lubridate::tz(dat_moorings$receiver_start_date) <- "UTC"
dat_moorings$receiver_end_date   <-  as.POSIXct(dat_moorings$receiver_end_date)
lubridate::tz(dat_moorings$receiver_end_date) <- "UTC"
dat_ids$tag_start_date <- as.POSIXct(dat_ids$tag_start_date)
lubridate::tz(dat_ids$tag_start_date) <- "UTC"
## tag_end_date column needed in dat_ids
dat_ids$tag_end_date   <- as.POSIXct("2020-01-01", tz = "UTC")
#### Implement quality_check() on processed data as a final check for any issues
quality_check(dat_acoustics, dat_moorings, dat_ids)
library(flapper)
## Times should be in POSIXct format
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date)
lubridate::tz(dat_moorings$receiver_start_date) <- "UTC"
dat_moorings$receiver_end_date   <-  as.POSIXct(dat_moorings$receiver_end_date)
lubridate::tz(dat_moorings$receiver_end_date) <- "UTC"
dat_ids$tag_start_date <- as.POSIXct(dat_ids$tag_start_date)
lubridate::tz(dat_ids$tag_start_date) <- "UTC"
## tag_end_date column needed in dat_ids
dat_ids$tag_end_date   <- as.POSIXct("2020-01-01", tz = "UTC")
#### Implement quality_check() on processed data as a final check for any issues
quality_check(dat_acoustics, dat_moorings, dat_ids)
## All data have previously passed false detection filters (see glatos::false_detections())
dat_acoustics$passed_filter <- 1
## Times should be in POSIXct format
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date)
lubridate::tz(dat_moorings$receiver_start_date) <- "UTC"
dat_moorings$receiver_end_date   <-  as.POSIXct(dat_moorings$receiver_end_date)
lubridate::tz(dat_moorings$receiver_end_date) <- "UTC"
dat_ids$tag_start_date <- as.POSIXct(dat_ids$tag_start_date)
lubridate::tz(dat_ids$tag_start_date) <- "UTC"
## tag_end_date column needed in dat_ids
dat_ids$tag_end_date   <- as.POSIXct("2020-01-01", tz = "UTC")
#### Implement quality_check() on processed data as a final check for any issues
quality_check(dat_acoustics, dat_moorings, dat_ids)
?glatos::false_detections
head(acoustics_wth_errors)
head(dat_acoustics)
table(acoustics$passed_filter == 0)
table(dat_acoustics$passed_filter == 0)
library(flapper)
## All data have previously passed false detection filters (see glatos::false_detections())
dat_acoustics$passed_filter <- 1
## Times should be in POSIXct format
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date)
lubridate::tz(dat_moorings$receiver_start_date) <- "UTC"
dat_moorings$receiver_end_date   <-  as.POSIXct(dat_moorings$receiver_end_date)
lubridate::tz(dat_moorings$receiver_end_date) <- "UTC"
dat_ids$tag_start_date <- as.POSIXct(dat_ids$tag_start_date)
lubridate::tz(dat_ids$tag_start_date) <- "UTC"
## tag_end_date column needed in dat_ids
dat_ids$tag_end_date   <- as.POSIXct("2020-01-01", tz = "UTC")
#### Implement quality_check() on processed data as a final check for any issues
quality_check(dat_acoustics, dat_moorings, dat_ids)
#### Add erroneous data to acoustics for demonstrating quality_check()
## Define a convenience function to add erroneous data to
# ... acoustics to demonstrate quality_check()
add_erroneous_row <- function(acoustics, row = nrow(acoustics), col, val){
tmp_ls <- lapply(val, function(v){
tmp <- acoustics[row, ]
tmp[1, col] <- v
return(tmp)
})
tmp <- dplyr::bind_rows(tmp_ls)
acoustics <- rbind(acoustics, tmp)
return(acoustics)
}
## Add erroneous receiver ids
nrw <- nrow(dat_acoustics)
acoustics_wth_errors <- add_erroneous_row(dat_acoustics,
row = nrw,
col = "receiver_id",
val = c(100, 200, 300))
## Add erroneous timestamps (outside receiver/individual id deployment periods )
acoustics_wth_errors <- add_erroneous_row(acoustics_wth_errors,
row = nrw,
col = "timestamp",
val = as.POSIXct(c("2019-01-01", "2019-03-01"),
tz = "UTC"))
## Add erroneous individual ids
acoustics_wth_errors <- add_erroneous_row(acoustics_wth_errors,
row = nrw,
col = "individual_id",
val = c(100, 200, 300))
## Examine erroneous data:
utils::tail(acoustics_wth_errors, 10)
#### Implement quality_check()
quality_check(acoustics_wth_errors, dat_moorings, dat_ids)
library(flapper)
#### Add erroneous data to acoustics for demonstrating quality_check()
## Define a convenience function to add erroneous data to
# ... acoustics to demonstrate quality_check()
add_erroneous_row <- function(acoustics, row = nrow(acoustics), col, val){
tmp_ls <- lapply(val, function(v){
tmp <- acoustics[row, ]
tmp[1, col] <- v
return(tmp)
})
tmp <- dplyr::bind_rows(tmp_ls)
acoustics <- rbind(acoustics, tmp)
return(acoustics)
}
## Add erroneous receiver ids
nrw <- nrow(dat_acoustics)
acoustics_wth_errors <- add_erroneous_row(dat_acoustics,
row = nrw,
col = "receiver_id",
val = c(100, 200, 300))
## Add erroneous timestamps (outside receiver/individual id deployment periods )
acoustics_wth_errors <- add_erroneous_row(acoustics_wth_errors,
row = nrw,
col = "timestamp",
val = as.POSIXct(c("2019-01-01", "2019-03-01"),
tz = "UTC"))
## Add erroneous individual ids
acoustics_wth_errors <- add_erroneous_row(acoustics_wth_errors,
row = nrw,
col = "individual_id",
val = c(100, 200, 300))
## Examine erroneous data:
utils::tail(acoustics_wth_errors, 10)
#### Implement quality_check()
quality_check(acoustics_wth_errors, dat_moorings, dat_ids)
?warning
library(flapper)
#### Prepare data
## All data have previously passed false detection filters (see glatos::false_detections())
dat_acoustics$passed_filter <- 1
## Times should be in POSIXct format
dat_moorings$receiver_start_date <-  as.POSIXct(dat_moorings$receiver_start_date)
lubridate::tz(dat_moorings$receiver_start_date) <- "UTC"
dat_moorings$receiver_end_date   <-  as.POSIXct(dat_moorings$receiver_end_date)
lubridate::tz(dat_moorings$receiver_end_date) <- "UTC"
dat_ids$tag_start_date <- as.POSIXct(dat_ids$tag_start_date)
lubridate::tz(dat_ids$tag_start_date) <- "UTC"
## tag_end_date column needed in dat_ids
dat_ids$tag_end_date   <- as.POSIXct("2020-01-01", tz = "UTC")
#### Implement quality_check() on processed data as a final check for any issues
quality_check(dat_acoustics, dat_moorings, dat_ids)
#### Add erroneous data to acoustics for demonstrating quality_check()
## Define a convenience function to add erroneous data to
# ... acoustics to demonstrate quality_check()
add_erroneous_row <- function(acoustics, row = nrow(acoustics), col, val){
tmp_ls <- lapply(val, function(v){
tmp <- acoustics[row, ]
tmp[1, col] <- v
return(tmp)
})
tmp <- dplyr::bind_rows(tmp_ls)
acoustics <- rbind(acoustics, tmp)
return(acoustics)
}
## Add erroneous receiver ids
nrw <- nrow(dat_acoustics)
acoustics_wth_errors <- add_erroneous_row(dat_acoustics,
row = nrw,
col = "receiver_id",
val = c(100, 200, 300))
## Add erroneous timestamps (outside receiver/individual id deployment periods )
acoustics_wth_errors <- add_erroneous_row(acoustics_wth_errors,
row = nrw,
col = "timestamp",
val = as.POSIXct(c("2019-01-01", "2019-03-01"),
tz = "UTC"))
## Add erroneous individual ids
acoustics_wth_errors <- add_erroneous_row(acoustics_wth_errors,
row = nrw,
col = "individual_id",
val = c(100, 200, 300))
## Examine erroneous data:
utils::tail(acoustics_wth_errors, 10)
#### Implement quality_check()
quality_check(acoustics_wth_errors, dat_moorings, dat_ids)
library(flapper)
?quality_check
library(flapper)
install.packages("glatos")
library(remotes)
install_url("https://gitlab.oceantrack.org/GreatLakes/glatos/repository/master/archive.zip",
build_opts = c("--no-resave-data", "--no-manual"))
library(flapper)
library(flapper)
