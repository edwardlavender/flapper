# JT recommends removing these data (default state of receivers is to be on)
# e.g. continue to record on the boat.
d <- d %>% filter(!is.na(receiver_number))
# final check: there are no records after the date of last retrieval of the receivers (good)
table(d$date_time > as.POSIXct("27-07-2017", format = "%d-%m-%Y"))
#################################################################
#### Remove all data on servicing days
head(d)
d$date <- as.Date(d$date_time)
d$service <- FALSE
servicing_ls <- mapply(servicing_ls, names(servicing_ls), FUN = function(s1, rid){
s1$receiver_number <- rid
return(s1)
}, SIMPLIFY = FALSE)
servicing <- servicing_ls %>% dplyr::bind_rows()
servicing$hour <- WeStCOMSExploreR::hour_dbl(servicing$timestamp)
range(servicing$hour) # from 7 am until 2 pm --> potentially inaccurate?
# TO BE COMPLETED.
#
#
#
#
#
#################################################################
### 7) All detections of acoustic codes that are not recorded in the skate ids dataframe will be removed
# ... this reflects ghost detections
# ... and also all records of the acoustic tags built into receivers will be removed
# ... (this data concentrates on skate movement)
# if all reduced acoustic ids have been specified correctly,
# then there are no other detections:
table(levels(d$reduced_acoustic_id) %ni% levels(skateids$reduced_acoustic_id))
# check for no confusion with tags built in having possibly had acoustic ids mis-specified
builtin <- substr(as.character(moorings$receiver_transmitter_acoustic_id), start= 3, stop=5)
builtin <- as.factor(builtin)
table(builtin %in% levels(skateids$reduced_acoustic_id)) # looks good.
#################################################################
#### False detections
#### glatos approach
det <- data.frame(detection_timestamp_utc = d$date_time,
transmitter_codespace = substr(d$transmitter, 1, 8),
transmitter_id = d$reduced_acoustic_id,
receiver_sn = d$receiver_number)
det <- glatos::min_lag(det)
det <- glatos::false_detections(det, tf = 3600, show_plot = TRUE)
# The filter identified 850 (0.41%) of 208338 detections as potentially false.
#### The effects of incorporating spatial information
# Define distances between receivers
dist <- flapper::dist_btw_receivers(moorings = data.frame(ID = moorings$receiver_number,
lat = moorings$lat_receiver,
long = moorings$long_receiver))
head(dist); range(dist$dist)
# Implement false_detections_sf()
det2 <- flapper::false_detections_sf(det = det,
tf = 3600,
sf = 5,
dist = dist)
det2_details <- attr(det2, "details")
#det2pass <- det2[which(det2 == 1)]
#det2_details_pass <- det2_details[which(det2 == 1), ]
#View(det2pass)
#View(det2_details_pass)
det <- cbind(det, det2_details)
det_pass_sf <- det[det$passed_filter_sf == 1, ]
View(det_pass_sf)
library(flapper)
#################################################################
#################################################################
#### Skate Acoustic Data Processing (1)
#### E. Lavender
#### 17/10/2018
#### Steps preceeding this code:
# 1) a, skateids_processed.R script --> skateids_processed.csv file
# 2) b, moorings_processed.R script --> moorings_processed.csv file
#### This code:
# 1) Loads the acoustic data (three excel files)
# 2) Processes the acoustic data
# 3) saves a single .csv file
#################################################################
#################################################################
#### Set Up
# clear workspace
rm(list = ls())
# load necessary packages
library(dplyr)  # for manipulations
library(chron)  # to deal with dates
# define functions
"%ni%" <- Negate("%in%")
"isnt.na" <- Negate("is.na")
#################################################################
#### load the processed skate id data
# set working directory
setwd(paste0("/Users/el72/Documents/PhD/",
"Academic_PhD_Work/Data and Modelling/",
"Data/Processed Data/Basic Data Processed Outputs"))
# load the processed skateids:
skateids <- readRDS("skateids.rds")
str(skateids)
# skateids <- read.csv("a_skateids_processed.csv", header = T, sep = ",")
# deal with dates:
skateids$date_deployment_tag[1:10]
skateids$date_deployment_tag <- as.POSIXct(skateids$date_deployment_tag, tz = "UTC")
skateids$date_removal_tag_acc <- as.POSIXct(skateids$date_removal_tag_acc, tz = "UTC")
# make reduced acoustic id a factor
skateids$reduced_acoustic_id <- as.factor(skateids$reduced_acoustic_id)
#################################################################
#### load the processed moorings data
# load the data
moorings <- readRDS("moorings.rds")
str(moorings)
# moorings <- read.csv("b_moorings_processed.csv", header = T, sep = ",")
# create a receiver column which matches that in the acoustics df
# first make receiver type a character
# moorings$receiver_type <- as.character(moorings$receiver_type)
# receivers refered to as AR need to be called VR2AR
# moorings$receiver_type[moorings$receiver_type == "AR"] <- "VR2AR"
# join receiver type and id numbers:
# moorings$receiver <- paste(moorings$receiver_type, moorings$receiver_id, sep = "-")
# make a factor:
# moorings$receiver <- as.factor(moorings$receiver)
# update dates
# moorings$date_deployment_receiver <- as.POSIXct(moorings$date_deployment_receiver,
#                                        format = "%d-%m-%Y",
#                                        tz = "UTC")
# moorings$date_removal_receiver <- as.POSIXct(moorings$date_removal_receiver,
#                                     format = "%d-%m-%Y",
#                                     tz = "UTC")
moorings$date_operation_start_receiver <- as.POSIXct(moorings$date_operation_start_receiver)
moorings$date_operation_end_receiver <- as.POSIXct(moorings$date_operation_end_receiver)
#################################################################
#### load distances between receivers
# distances
dists <- read.csv("dists_btw_receivers.csv", header = T, sep = ",")
#################################################################
#### load recaptures
recaptures <- readRDS("recaptures_processed.rds")
str(recaptures)
# recaptures$date <- as.POSIXct(as.character(recaptures$date), format = "%d/%m/%Y", tz = "UTC") # note UTC time
#################################################################
#### Load servicing dates
servicing_ls <- rlist::list.load("receiver_service_dates_ls.RData")
str(servicing_ls)
#################################################################
#### load the data for acoustics
# set working directory
setwd(paste0("/Users/el72/Documents/PhD/",
"Academic_PhD_Work/Data and Modelling/",
"Data/R Data Directory/Acoustic/Skate"))
# load the .csv data
# note the "na.strings = c("", "NA") added to the end of the code
# this adds NAs to blank cells (e.g. many blank cells in the station name column)
skate_200s <- read.csv("skate_200s.csv", header = T, sep = ",",  na.strings = c("", "NA"))
skate_500s <- read.csv("skate_500s.csv", header = T, sep = ",", na.strings = c("", "NA"))
skate_40000s <- read.csv("skate_40000s.csv", header = T, sep = ",", na.strings = c("", "NA"))
#################################################################
#################################################################
#### Merging the three dataframes
# all of the spreadsheets have the same structure to start with:
colnames(skate_200s) == colnames(skate_500s)
colnames(skate_500s) == colnames(skate_40000s)
# hence:
# so we can merge them immediately
# and process the overall data frame in one go
d <- rbind(skate_200s, skate_500s, skate_40000s)
# view the structure of d
str(d)
#################################################################
#################################################################
#### First stage cleaning of accoustic data
#################################################################
#### Edit column names and remove unwanted columns
# remove unwanted columns (keep lat and long columns)
d$Transmitter.Name <- NULL
d$Transmitter.Serial <- NULL
# adjust col names
colnames(d) <- c(
"date_time",
"receiver",
"transmitter",
"sensor_value",
"sensor_unit",
"station_name",
"lat_receiver",
"long_receiver")
#################################################################
#### checks for NAs
# there are no NAs in the date/time
table(is.na(d$date_time))
class(d$date_time)
#################################################################
#### creating acoustic ids
# the transmitter code is comprised of two components:
# ... the code map; then the individual acoustic pinger id
# make a new column of reduced acoustic code:
# for acoustic codes of this form: A69-1105-246 [12 characters] we only want the last 3 letters
# for acoustic codes of this form: A69-1601-41265 [14 characters] we want the last 5 letters
# a) identify the row numbers of the dataframe which have full acoustic ids of 12 characters
pos1 <- which(nchar(as.character(d$transmitter)) == 12)
pos2 <- which(nchar(as.character(d$transmitter)) == 14)
# b) custom function to extract the last n characters of a word
substr.end <- function(x, n){
x <- as.character(x)
x <- substr(x, nchar(x)-n+1, nchar(x))
return(x)}
# c) create a blank new column:
d$reduced_acoustic_id <- NA
# c) extract the last n = 3 characters for positions with a transmitter code of 12
d$reduced_acoustic_id[pos1] <- substr.end(d$transmitter[pos1], 3)
# d) extract the last 5 positions for transmitter code of 14
d$reduced_acoustic_id[pos2] <- substr.end(d$transmitter[pos2], 5)
#################################################################
#### dealing with dates and times
# convert dates and times to POSITct class
# note that it is necessary to specify the time zone (GMT) to avoid NAs
d$date_time <- as.POSIXct(d$date_time, format="%Y-%m-%d %H:%M:%S", tz = "UTC")
# we can convert the POSIXct object to a single number for plotting purposes
# this is the number of seconds since 1st January 1970
# different from the number in excel which is the number of days since 1st Jan 1900
d$date_time_numeric <- as.numeric(d$date_time)
# recheck for NAs in dates/ times
table(is.na(d$date_time))
#################################################################
#################################################################
#### Removing erroneous data
# 1) All detections of acoustic tag number 168252 need to be removed
# ...(tag fell off immediately and this individual is excluded from the analysis)
# 2) All detections of individuals before they were tagged need to be removed
# ...due to checking processes, range testing etc.
# 3) All detections of individuals after the removal of their tags need to be removed
# ...(detections after these dates due to range testing and deployment on spurdog)
# 4) All receivers that are not in the moorings.xlxs dataframe need to be removed
# ...these are present because they were later deployed in loch etive and the data needs to be cleaned
# 5) Two receivers were lost in the FoL and later redeployed in Loch Etive
# ... 112985; 5634; all records from these receivers need to be removed
# 6) All receivers with records after the date at which those receivers were collected need to be removed
# ...this is due to their redeployment in loch etive
# 7) All detections of acoustic codes that are not recorded in the skate ids dataframe will be removed
# ... this reflects ghost detections
# ... and also all records of the acoustic tags built into receivers will be removed
# ... (this data concentrates on skate movement)
# 8) Remove all detections detections of any single individual at a single receiver
# ... if only one detection of that individual at that receiver is recorded in a one hour period
# ... these could be erroneous (technology problem, false detections, see quality checks in literature)
#################################################################
#### 1) All detections of acoustic tag number 168252 need to be removed
# ...(tag fell off immediately and this individual is excluded from the analysis)
# check the specification of a factor level with quotes is recognised
table(d$reduced_acoustic_id == "255")
# check the specification of a factor level with quotes is recognised
table(d$reduced_acoustic_id == "252")
# no records of this tag anyway.
#################################################################
#### 2) All detections of individuals before they were tagged need to be removed
# ...due to checking processes, range testing etc.
# add the date of deployment to the acoustics (d) dataframe
d$date_deployment_tag <- skateids$date_deployment_tag[match(d$reduced_acoustic_id, skateids$reduced_acoustic_id)]
# there are 26 cases of an acoustic record prior or on the same day as deployment
table(d$date_time < d$date_deployment_tag)
# at these rows in the dataframe:
which(d$date_time < d$date_deployment_tag)
# for these individuals:
levels(as.factor(as.character(d$reduced_acoustic_id[which(d$date_time < d$date_deployment_tag)])))
error_individuals <- c("250", "41269", "563")
# make a subset of the acoustics (d) dataframe for all of these individuals
# and check dates of deployment versus dates of detection
# sbst_250 <- subset(d, d$reduced_acoustic_id == error_individuals[1])
# sbst_41269 <- subset(d, d$reduced_acoustic_id == error_individuals[2])
# sbst_563 <- subset(d, d$reduced_acoustic_id == error_individuals[3])
# dates of deployment versus dates of first detection:
# reduced id 250: tagged on 2016-03-07; first records from 2016-03-04 (n = 3)
# reduced id 563: tagged on 2016-03-16; first records from 2016-03-15 (n = 1)
# reduced id 41269: tagged on 2016-03-16; first records from 2016-07-22 (n = 22)
# this is due to these tags being used for range testing, error checking etc (JT)
# e.g. 41269 was a range testing tag
# remove these data:
d <- d[-c(which(d$date_time < d$date_deployment_tag)), ]
#################################################################
#### 3) All detections of individuals after the removal of their tags need to be removed
# ...(detections after these dates due to range testing and deployment on spurdog)
# there should be no records of individuals after the date
# ... at which their tag has been collected
# add retrieval date to acoustics df:
d$date_removal_tag_acc <- skateids$date_removal_tag_acc[match(d$reduced_acoustic_id, skateids$reduced_acoustic_id)]
# there are 215537 records where the date of a record is on he same day as or after
# ... the time at which that acoustic tag is thought to have been removed
table(d$date_time >= d$date_removal_tag_acc)
# positions of these:
pos <- which(d$date_time >= d$date_removal_tag_acc)
# individuals they refer to:
unique(d$reduced_acoustic_id[pos])
# all of these detections can be explained by range testing/ tag redeployment in loch etive (JT)
# exclude all records on the same day as or after tag removal
# (BD: since the time of day at which acoustic tags were removed, we have to exclude all of the last day)
d <- d[-c(pos), ]
# checking, e.g. for individual 247
# sbst <- subset(d, reduced_acoustic_id == "247")
# sbst <- subset(sbst, sbst$date_time > sbst$date_removal_tag_acc+60*60*24)
# nrow(sbst[, c("reduced_acoustic_id", "date_time", "date_removal_tag_acc", "station_name")])
# View(sbst[, c("reduced_acoustic_id", "date_time", "date_removal_tag_acc", "station_name")])
#################################################################
#### 4) All receivers that are not in the moorings.xlxs dataframe need to be removed
# ...these are present because they were later deployed in loch etive and the data needs to be cleaned
# not all receivers in the acoustics dataframe are in the moorings dataframe
table(levels(d$receiver) %in% levels(moorings$receiver))
# these levels are not found
receivers_not_found <-
levels(d$receiver)[levels(d$receiver) %ni% levels(moorings$receiver)]
# this is because these receivers were deployed in loch etive (i.e. spurdog data)
# remove data associated with these receivers:
d <- subset(d, d$receiver %ni% receivers_not_found)
d$receiver <- factor(d$receiver)
#################################################################
#### 5) Two receivers were lost in the FoL and later redeployed in Loch Etive
# ... 112985; 5634; all records from these receivers need to be removed
# neither of these receivers made any detections:
table(d$receiver == "VR2W-112985")
table(d$receiver == "VR2-5634")
# test another random receiver:
table(d$receiver == "VR2AR-546583") # yes this made, 194 detections, good, the other receivers really made no detections
#################################################################
#### 6) All receivers with records before or after the date at which those receivers were collected need to be removed
# ...e.g. this is due to their redeployment in loch etive
# Update:
# This is based on operation start and end dates, not provided deployment and retreval dates
# (see Chp2 and moorings data processing)
# Method:
# 1) Add receiver_number to acoustics df (d)
# ... some receivers were deployed multiple times
# ... so receiver name is not a unique lable of a deployment
# ... however, receiver_number from the moorings dataframe is
# ... we will add receiver_number using a for loop below
# ... this is very explicit, but better than using match[()] because
# ... we have erroneous records outside of dates of receiver deployment and removal
# ... that can cause issues
# ... later we will also use receiver_number (not receiver) to add details about receivers to the dataframe (e.g. lat, long)
# 2)
# make sure receivers are recognised as character variables
moorings$receiver <- as.character(moorings$receiver)
d$receiver <- as.character(d$receiver)
# add receiver_number to the acoustics dataframe (blank for now)
d$receiver_number <- rep(NA, nrow(d))
# define a vector of receivers that were deployed; and deployed more than once (duplicates = dups)
recs <- unique(moorings$receiver)
dups <- moorings$receiver[duplicated(moorings$receiver)]
# Using a for loop, we will add the receiver_number
# for each receiver that was deployed:
for(i in recs){
# print i to monitor loop progress
print(i)
# subset the moorings dataframe to only consider that receiver
# and order the subset by deployment data
moorings_sbt <-
moorings %>% filter(receiver == i) %>% arrange(date_operation_start_receiver)
# define the positions in d which correpsond to that receiver
# ... and are between the first dates of deployment and removal
pos1 <- which(d$receiver == i &
d$date_time >= moorings_sbt$date_operation_start_receiver[1] &
d$date_time <= moorings_sbt$date_operation_end_receiver[1])
# if the receiver was deployed more than once,
# define the positions in d which correpsond to that receiver
# ... and are between the second dates of deployment and removal
if(i %in% dups){
pos2 <- which(d$receiver == i &
d$date_time >= moorings_sbt$date_operation_start_receiver[2] &
d$date_time <= moorings_sbt$date_operation_end_receiver[2])}
# define the receiver_number in each case appropriately:
d$receiver_number[pos1] <- moorings_sbt$receiver_number[1]
# if the receiver was deployed twice, define the receiver number
# ... appropriately for the second deployments
if(i %in% dups){
d$receiver_number[pos2] <- moorings_sbt$receiver_number[2] }
# manually check for one reciver that was deployed twice
# (everything below should add up perfectly)
if(i == dups[length(dups)]){
# print the moorings_sbt dataframe to check output and date deployment/removal
print(moorings_sbt)
# subset acoustics dataframe (d) to only that receiver
ck <- d %>% filter(receiver == i)
# print a frequency table of thr frequency of different receiver_numbers for that receiver
print("Receiver numbers and frequencies:")
print(table(ck$receiver_number))
# print the length of pos1 and pos2
# ... (i.e. the number of records correpeonding to 1st and 2nd deployment of that receiver)
print("Length of pos1 and pos2")
print(c(length(pos1), length(pos2)))
# subset ck to only consider first deployments and check the receiver_numbers added:
ck1 <- ck %>% filter(date_time >= moorings_sbt$date_operation_start_receiver[1] &
date_time <= moorings_sbt$date_operation_end_receiver[1])
print("receiver_number of first deployment:")
print(table(ck1$receiver_number))
# repeat for the second deployment:
ck2 <- ck %>% filter(date_time >= moorings_sbt$date_operation_start_receiver[2] &
date_time <= moorings_sbt$date_operation_end_receiver[2])
print("receiver_number of second deployment:")
print(table(ck2$receiver_number))
# close if loop
}
# close for loop
}
# make station_name the same as receiver number
d$station_name <- d$receiver_number
# note that some records have have "NA" for their receiver number,
# This is because these records are not inside the dates of deployment/removal for a given receiver
table(is.na(d$receiver_number))
# These records are associated with associated with these receivers:
# frequency table:
table(d$receiver[which(is.na(d$receiver_number))])
# vector of receivers:
na_rec_no <- unique(d$receiver[which(is.na(d$receiver_number))])
# manual checking... Look carefully at all the outputs of the loop below
# for each receiver that is associated with NAs in the receiver_number
# ... i.e. with records of dates outside dates of deployment/removal
for(i in na_rec_no){
# print i
print(i)
# subset of the moorings dataframe only showing that receiver
moorings_sbt <-
moorings %>%
filter(receiver == i) %>%
arrange(date_operation_start_receiver) %>%
dplyr::select(receiver_number, receiver, date_operation_start_receiver, date_operation_end_receiver)
# print mooorings
print(moorings_sbt)
# subset d to only consider the rows with NAs in receiver_number for that receiver
d_sbt <- d %>%
filter(receiver == i) %>%
filter(is.na(receiver_number)) %>%
dplyr::select("date_time", "receiver", "receiver_number")
# print the first two records from the subsetted dataframe
print(head(d_sbt, 2))
# print the last two records
print(tail(d_sbt, 2))
# confirm all records lie outisde of dates of deployment and removal
# should always return TRUE
ifelse(nrow(moorings_sbt) == 1,
print(
table(d_sbt$date_time < moorings_sbt$date_operation_start_receiver[1] | d_sbt$date_time > moorings_sbt$date_operation_end_receiver[1])
),
print(
table(
d_sbt$date_time < moorings_sbt$date_operation_start_receiver[1] |
d_sbt$date_time > moorings_sbt$date_operation_end_receiver[1] & d_sbt$date_time < moorings_sbt$date_operation_start_receiver[2] |
d_sbt$date_time > moorings_sbt$date_operation_end_receiver[2])
)
)
# close the loop
}
# remove records with NA for receiver_name
# the above loop confirms these are all due to records outside of dates of deployment/removal
# JT recommends removing these data (default state of receivers is to be on)
# e.g. continue to record on the boat.
d <- d %>% filter(!is.na(receiver_number))
# final check: there are no records after the date of last retrieval of the receivers (good)
table(d$date_time > as.POSIXct("27-07-2017", format = "%d-%m-%Y"))
#################################################################
#### Remove all data on servicing days
head(d)
d$date <- as.Date(d$date_time)
d$service <- FALSE
servicing_ls <- mapply(servicing_ls, names(servicing_ls), FUN = function(s1, rid){
s1$receiver_number <- rid
return(s1)
}, SIMPLIFY = FALSE)
servicing <- servicing_ls %>% dplyr::bind_rows()
servicing$hour <- WeStCOMSExploreR::hour_dbl(servicing$timestamp)
range(servicing$hour) # from 7 am until 2 pm --> potentially inaccurate?
# TO BE COMPLETED.
#
#
#
#
#
#################################################################
### 7) All detections of acoustic codes that are not recorded in the skate ids dataframe will be removed
# ... this reflects ghost detections
# ... and also all records of the acoustic tags built into receivers will be removed
# ... (this data concentrates on skate movement)
# if all reduced acoustic ids have been specified correctly,
# then there are no other detections:
table(levels(d$reduced_acoustic_id) %ni% levels(skateids$reduced_acoustic_id))
# check for no confusion with tags built in having possibly had acoustic ids mis-specified
builtin <- substr(as.character(moorings$receiver_transmitter_acoustic_id), start= 3, stop=5)
builtin <- as.factor(builtin)
table(builtin %in% levels(skateids$reduced_acoustic_id)) # looks good.
#################################################################
#### False detections
#### glatos approach
det <- data.frame(detection_timestamp_utc = d$date_time,
transmitter_codespace = substr(d$transmitter, 1, 8),
transmitter_id = d$reduced_acoustic_id,
receiver_sn = d$receiver_number)
det <- glatos::min_lag(det)
det <- glatos::false_detections(det, tf = 3600, show_plot = TRUE)
# The filter identified 850 (0.41%) of 208338 detections as potentially false.
#### The effects of incorporating spatial information
# Define distances between receivers
dist <- flapper::dist_btw_receivers(moorings = data.frame(ID = moorings$receiver_number,
lat = moorings$lat_receiver,
long = moorings$long_receiver))
head(dist); range(dist$dist)
# Implement false_detections_sf()
det2 <- flapper::false_detections_sf(det = det,
tf = 3600,
sf = 5,
dist = dist)
det2_details <- attr(det2, "details")
#det2pass <- det2[which(det2 == 1)]
#det2_details_pass <- det2_details[which(det2 == 1), ]
#View(det2pass)
#View(det2_details_pass)
det <- cbind(det, det2_details)
det_pass_sf <- det[det$passed_filter_sf == 1, ]
View(det_pass_sf)
